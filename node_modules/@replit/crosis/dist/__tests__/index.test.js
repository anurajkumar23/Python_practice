"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("..");
var helpers_1 = require("../util/helpers");
var genConnectionMetadata = require('../../debug/genConnectionMetadata');
var WebSocket = require('ws');
function genToken() {
    return genConnectionMetadata().token;
}
jest.setTimeout(10 * 1000);
test('client connect', function (done) {
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(done);
    var ctx = { username: 'zyzz' };
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: ctx,
    }, function (_a) {
        var channel = _a.channel, error = _a.error, context = _a.context;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(context).toBe(ctx);
        expect(error).toEqual(null);
        client.close();
        return function () {
            done();
        };
    });
});
test('client connect with connection metadata retry', function (done) {
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(done);
    var ctx = { username: 'zyzz' };
    var tryCount = 0;
    client.open({
        fetchConnectionMetadata: function () {
            tryCount += 1;
            if (tryCount === 1) {
                return Promise.resolve({
                    error: __1.FetchConnectionMetadataError.Retriable,
                });
            }
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: ctx,
    }, function (_a) {
        var channel = _a.channel, error = _a.error, context = _a.context;
        expect(tryCount).toBe(2);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(context).toBe(ctx);
        expect(error).toEqual(null);
        client.close();
        return function () {
            done();
        };
    });
});
test('client connect (fetchToken)', function (done) {
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(done);
    var ctx = { username: 'zyzz' };
    client.open({
        fetchToken: function () { return Promise.resolve({ token: genToken(), aborted: false }); },
        WebSocketClass: WebSocket,
        context: ctx,
    }, function (_a) {
        var channel = _a.channel, error = _a.error, context = _a.context;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(context).toBe(ctx);
        expect(error).toEqual(null);
        client.close();
        return function () {
            done();
        };
    });
});
test('client retries', function (done) {
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(done);
    var tryCount = 0;
    client.open({
        fetchConnectionMetadata: function () {
            tryCount += 1;
            if (tryCount === 1) {
                return Promise.resolve({
                    token: 'test - bad connection metadata retries',
                    gurl: 'ws://invalid.example.com',
                    conmanURL: 'http://invalid.example.com',
                    error: null,
                });
            }
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(tryCount).toBe(2);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(error).toEqual(null);
        client.close();
        return function () {
            done();
        };
    });
});
test('channel closing itself when client willReconnect', function (done) {
    var disconnectTriggered = false;
    var clientOpenCount = 0;
    var channelOpenCount = 0;
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(done);
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, function (_a) {
        var channel = _a.channel, error = _a.error;
        clientOpenCount += 1;
        expect(error).toEqual(null);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        if (!disconnectTriggered) {
            setTimeout(function () {
                disconnectTriggered = true;
                client.ws.close();
            }, 1000);
        }
        else {
            client.close();
        }
        return function (_a) {
            var willReconnect = _a.willReconnect;
            if (willReconnect) {
                return;
            }
            expect(clientOpenCount).toEqual(2);
            expect(channelOpenCount).toEqual(1);
            done();
        };
    });
    var close = client.openChannel({ service: 'shell' }, function (_a) {
        var channel = _a.channel, error = _a.error;
        channelOpenCount += 1;
        expect(error).toBe(null);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        return function (_a) {
            var willReconnect = _a.willReconnect;
            expect(willReconnect).toBeTruthy();
            close();
        };
    });
});
test('channel open and close', function (done) {
    var onUnrecoverableError = jest.fn();
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(done);
    var channelClose = jest.fn();
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(error).toEqual(null);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        return function () {
            expect(channelClose).toHaveBeenCalled();
            expect(onUnrecoverableError).toHaveBeenCalledTimes(0);
            done();
        };
    });
    var close = client.openChannel({ service: 'shell' }, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(error).toBe(null);
        setTimeout(function () {
            close();
            expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closing');
        });
        return function (_a) {
            var willReconnect = _a.willReconnect;
            expect(willReconnect).toBeFalsy();
            expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closed');
            channelClose();
            client.close();
        };
    });
});
test('channel accepts a thunk for service', function (done) {
    var onUnrecoverableError = jest.fn();
    var context = { username: 'aghanim' };
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(done);
    var channelClose = jest.fn();
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: context,
    }, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(error).toEqual(null);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        return function () {
            expect(channelClose).toHaveBeenCalled();
            expect(onUnrecoverableError).toHaveBeenCalledTimes(0);
            done();
        };
    });
    var close = client.openChannel({
        service: function (ctx) {
            expect(ctx.username).toEqual('aghanim');
            return 'exec';
        },
    }, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(error).toBe(null);
        setTimeout(function () {
            close();
            expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closing');
        });
        return function (_a) {
            var willReconnect = _a.willReconnect;
            expect(willReconnect).toBeFalsy();
            expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closed');
            channelClose();
            client.close();
        };
    });
});
test('channel open and close from within openChannelCb synchornously', function (done) {
    var onUnrecoverableError = jest.fn();
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(done);
    var channelClose = jest.fn();
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(error).toEqual(null);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        return function () {
            expect(channelClose).toHaveBeenCalled();
            expect(onUnrecoverableError).toHaveBeenCalledTimes(0);
            done();
        };
    });
    var close = client.openChannel({ service: 'shell' }, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(error).toBe(null);
        close();
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closing');
        return function (_a) {
            var willReconnect = _a.willReconnect;
            expect(willReconnect).toBeFalsy();
            expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closed');
            channelClose();
            client.close();
        };
    });
});
test('channel open and close from within openChannelCb synchornously', function (done) {
    var onUnrecoverableError = jest.fn();
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(done);
    var channelClose = jest.fn();
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(error).toEqual(null);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        return function () {
            expect(channelClose).toHaveBeenCalled();
            expect(onUnrecoverableError).toHaveBeenCalledTimes(0);
            done();
        };
    });
    var close = client.openChannel({ service: 'shell' }, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(error).toBe(null);
        close();
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closing');
        return function (_a) {
            var willReconnect = _a.willReconnect;
            expect(willReconnect).toBeFalsy();
            expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closed');
            channelClose();
            client.close();
        };
    });
});
test('channel skips opening', function (done) {
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(done);
    var service = 'shell';
    var ctx = { username: 'midas' };
    var skipfn = jest.fn().mockImplementation(function () { return true; });
    var opencb = jest.fn();
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: ctx,
    }, function (_a) {
        var error = _a.error;
        expect(error).toBeNull();
        setTimeout(function () {
            expect(skipfn).toHaveBeenCalledTimes(1);
            expect(skipfn).toHaveBeenCalledWith(ctx);
            expect(opencb).not.toHaveBeenCalled();
            client.close();
        }, 0);
        return function () {
            done();
        };
    });
    client.openChannel({
        service: service,
        skip: skipfn,
    }, opencb);
});
test('channel skips opening conditionally', function (done) {
    var unexpectedDisconnectTriggered = false;
    var clientOpenCount = 0;
    var channelOpenCount = 0;
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(done);
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, function (_a) {
        var channel = _a.channel, error = _a.error;
        clientOpenCount += 1;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(error).toEqual(null);
        if (unexpectedDisconnectTriggered) {
            client.close();
        }
        return function (_a) {
            var willReconnect = _a.willReconnect;
            if (willReconnect) {
                return;
            }
            expect(clientOpenCount).toEqual(2);
            expect(channelOpenCount).toEqual(1);
            done();
        };
    });
    client.openChannel({
        skip: function () { return channelOpenCount > 0; },
        service: 'shell',
    }, function (_a) {
        var channel = _a.channel, error = _a.error;
        if (!unexpectedDisconnectTriggered) {
            setTimeout(function () {
                client.ws.close();
                unexpectedDisconnectTriggered = true;
            }, 1000);
            expect(error).toBe(null);
            expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
            channelOpenCount += 1;
            return;
        }
        expect(error).toBeTruthy();
        expect(error === null || error === void 0 ? void 0 : error.message).toBe('Failed to open');
    });
});
test('openChannel before open', function (done) {
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(done);
    client.openChannel({ service: 'exec' }, function (_a) {
        var channel = _a.channel;
        expect(channel).toBeTruthy();
        client.close();
        done();
    });
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, function (_a) {
        var channel = _a.channel;
        expect(channel).toBeTruthy();
        return function () { };
    });
});
test('closing maintains openChannel requests', function (done) {
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(done);
    var first = true;
    client.openChannel({ service: 'exec' }, function (_a) {
        var channel = _a.channel;
        expect(channel).toBeTruthy();
        if (first) {
            client.close();
            first = false;
            setTimeout(function () {
                client.open({
                    fetchConnectionMetadata: function () {
                        return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
                    },
                    WebSocketClass: WebSocket,
                    context: null,
                }, function () { });
            }, 200);
        }
        else {
            client.close();
            done();
        }
    });
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, function (_a) {
        var channel = _a.channel;
        expect(channel).toBeTruthy();
        return function () { };
    });
});
test('client rejects opening same channel twice', function () {
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(function () { });
    var name = Math.random().toString();
    client.openChannel({ name: name, service: 'exec' }, function () { });
    expect(function () {
        client.openChannel({ name: name, service: 'exec' }, function () { });
    }).toThrow();
});
test('allows opening channel with the same name while if others are closing', function (done) {
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(done);
    var name = Math.random().toString();
    var close = client.openChannel({ name: name, service: 'exec' }, function () {
        setTimeout(function () {
            close();
            client.openChannel({ name: name, service: 'exec' }, function (_a) {
                var channel = _a.channel;
                expect(channel).toBeTruthy();
                client.close();
                done();
            });
        });
    });
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, function () { });
});
test('client reconnects unexpected disconnects', function (done) {
    var onUnrecoverableError = jest.fn();
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(onUnrecoverableError);
    var disconnectTriggered = false;
    var timesConnected = 0;
    var timesClosedUnintentionally = 0;
    var timesClosedIntentionally = 0;
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(error).toEqual(null);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toEqual('open');
        timesConnected += 1;
        if (!disconnectTriggered) {
            setTimeout(function () {
                var _a;
                (_a = client.ws) === null || _a === void 0 ? void 0 : _a.close();
                disconnectTriggered = true;
            });
        }
        else {
            client.close();
        }
        return function (closeReason) {
            if (closeReason.initiator !== 'client') {
                throw new Error('Expected "client" initiator');
            }
            if (closeReason.willReconnect) {
                timesClosedUnintentionally += 1;
            }
            else if (closeReason.willReconnect === false) {
                timesClosedIntentionally += 1;
            }
            if (timesConnected === 2) {
                expect(timesClosedUnintentionally).toEqual(1);
                expect(timesClosedIntentionally).toEqual(1);
                expect(onUnrecoverableError).toHaveBeenCalledTimes(0);
                done();
            }
        };
    });
});
test('client is closed while reconnecting', function (done) {
    var didOpen = false;
    var onOpen = jest.fn();
    var onClose = jest.fn();
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(done);
    var fetchConnectionMetadata = function () {
        if (didOpen) {
            setTimeout(function () {
                client.close();
                expect(onOpen).toHaveBeenCalledTimes(1);
                expect(onClose).toHaveBeenCalledTimes(1);
                done();
            });
        }
        return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
    };
    client.open({
        fetchConnectionMetadata: fetchConnectionMetadata,
        WebSocketClass: WebSocket,
        context: null,
    }, function (_a) {
        var channel = _a.channel;
        if (channel) {
            onOpen();
            didOpen = true;
            setTimeout(function () {
                var _a;
                (_a = client.ws) === null || _a === void 0 ? void 0 : _a.close();
            });
        }
        return function () {
            onClose();
        };
    });
});
test('closing before ever connecting', function (done) {
    var client = new __1.Client();
    var open = jest.fn();
    var openError = jest.fn();
    var close = jest.fn();
    client.open({
        fetchConnectionMetadata: function () {
            setTimeout(function () {
                client.close();
            }, 0);
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, function (_a) {
        var error = _a.error;
        if (error) {
            openError();
            expect(open).not.toHaveBeenCalled();
            expect(openError).toHaveBeenCalledTimes(1);
            expect(close).not.toHaveBeenCalled();
            done();
        }
        else {
            open();
        }
        return function () {
            close();
        };
    });
});
test('fallback to polling', function (done) {
    var onUnrecoverableError = jest.fn();
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(onUnrecoverableError);
    var WebsocketThatNeverConnects = (function () {
        function WebsocketThatNeverConnects() {
        }
        WebsocketThatNeverConnects.OPEN = 1;
        return WebsocketThatNeverConnects;
    }());
    expect(function () { return helpers_1.getWebSocketClass(WebsocketThatNeverConnects); }).not.toThrow();
    expect(helpers_1.getWebSocketClass(WebsocketThatNeverConnects)).toEqual(WebsocketThatNeverConnects);
    var didLogFallback = false;
    client.setDebugFunc(function (log) {
        if (log.type === 'breadcrumb' && log.message === 'polling fallback') {
            didLogFallback = true;
        }
    });
    client.open({
        timeout: 2000,
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebsocketThatNeverConnects,
        context: null,
    }, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(error).toBeNull();
        expect(channel).not.toBeNull();
        expect(didLogFallback).toBe(true);
        expect(onUnrecoverableError).not.toHaveBeenCalled();
        client.close();
        return function () {
            done();
        };
    });
}, 30000);
test('fetch token fail', function (done) {
    var chan0Cb = jest.fn();
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(function (e) {
        expect(chan0Cb).toHaveBeenCalledTimes(1);
        expect(e.message).toContain('fail');
        done();
    });
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve({
                error: new Error('fail'),
            });
        },
        WebSocketClass: WebSocket,
        context: null,
    }, chan0Cb);
});
test('fetch abort signal works as expected', function (done) {
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(function () {
        done(new Error('did not expect fatal to be called'));
    });
    var onAbort = jest.fn();
    client.open({
        fetchConnectionMetadata: function (abortSignal) {
            return new Promise(function (r) {
                abortSignal.onabort = function () {
                    onAbort();
                    r({
                        error: __1.FetchConnectionMetadataError.Aborted,
                    });
                };
                setTimeout(function () {
                    client.close();
                }, 0);
            });
        },
        WebSocketClass: WebSocket,
        context: null,
    }, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(channel).toBe(null);
        expect(error).toBeTruthy();
        expect(error === null || error === void 0 ? void 0 : error.message).toBe('Failed to open');
        expect(onAbort).toHaveBeenCalledTimes(1);
        done();
        return function () { };
    });
});
test('can close and open in synchronously without aborting fetch token', function (done) {
    var client = new __1.Client();
    client.setUnrecoverableErrorHandler(function () {
        done(new Error('did not expect fatal to be called'));
    });
    var onAbort = jest.fn();
    var firstChan0Cb = jest.fn();
    var resolveFetchToken = null;
    client.open({
        fetchConnectionMetadata: function (abortSignal) {
            return new Promise(function (r) {
                resolveFetchToken = r;
                abortSignal.onabort = function () {
                    onAbort();
                };
            });
        },
        WebSocketClass: WebSocket,
        context: null,
    }, firstChan0Cb);
    client.close();
    expect(resolveFetchToken).toBeTruthy();
    resolveFetchToken({ error: __1.FetchConnectionMetadataError.Aborted });
    expect(onAbort).toHaveBeenCalledTimes(1);
    expect(firstChan0Cb).toHaveBeenCalledTimes(1);
    expect(firstChan0Cb).toHaveBeenLastCalledWith(expect.objectContaining({
        channel: null,
        context: null,
        error: expect.any(Error),
    }));
    client.setUnrecoverableErrorHandler(done);
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(error).toEqual(null);
        client.close();
        return function () {
            expect(firstChan0Cb).toHaveBeenCalledTimes(1);
            done();
        };
    });
});
//# sourceMappingURL=index.test.js.map