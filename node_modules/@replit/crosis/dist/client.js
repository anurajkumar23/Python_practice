"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
var protocol_1 = require("@replit/protocol");
var channel_1 = require("./channel");
var helpers_1 = require("./util/helpers");
var EIOCompat_1 = require("./util/EIOCompat");
var types_1 = require("./types");
var ClientCloseReason;
(function (ClientCloseReason) {
    ClientCloseReason["Intentional"] = "Intentional";
    ClientCloseReason["Disconnected"] = "Disconnected";
    ClientCloseReason["Error"] = "Error";
})(ClientCloseReason || (ClientCloseReason = {}));
var defaultUrlOptions = {
    secure: true,
    host: 'eval.global.replit.com',
    port: '443',
};
var Client = (function () {
    function Client() {
        var _this = this;
        this.open = function (options, cb) {
            if (_this.chan0Cb) {
                var error = new Error('You must call `close` before opening the client again');
                _this.onUnrecoverableError(error);
                throw error;
            }
            var fetchConnectionMetadata = options.fetchConnectionMetadata;
            if (!fetchConnectionMetadata || typeof fetchConnectionMetadata !== 'function') {
                var fetchToken_1 = options.fetchToken;
                if (!fetchToken_1 || typeof fetchToken_1 !== 'function') {
                    var error = new Error('You must provide a fetchConnectionMetadata/fetchToken function');
                    _this.onUnrecoverableError(error);
                    throw error;
                }
                var _a = options.urlOptions || defaultUrlOptions, secure_1 = _a.secure, host_1 = _a.host, port_1 = _a.port;
                fetchConnectionMetadata = function (abortSignal) { return __awaiter(_this, void 0, void 0, function () {
                    var _a, token, aborted, e_1;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                _b.trys.push([0, 2, , 3]);
                                return [4, fetchToken_1(abortSignal)];
                            case 1:
                                _a = _b.sent(), token = _a.token, aborted = _a.aborted;
                                if (aborted || !token) {
                                    return [2, { error: types_1.FetchConnectionMetadataError.Aborted }];
                                }
                                return [2, {
                                        token: token,
                                        gurl: "ws" + (secure_1 ? 's' : '') + "://" + host_1 + ":" + port_1,
                                        conmanURL: "http" + (secure_1 ? 's' : '') + "://" + host_1 + ":" + port_1,
                                        error: null,
                                    }];
                            case 2:
                                e_1 = _b.sent();
                                return [2, {
                                        error: e_1,
                                    }];
                            case 3: return [2];
                        }
                    });
                }); };
            }
            if (_this.destroyed) {
                var error = new Error('Client has been destroyed and cannot be re-used');
                _this.onUnrecoverableError(error);
                throw error;
            }
            _this.connectOptions = __assign({ fetchConnectionMetadata: fetchConnectionMetadata, timeout: 10000 }, options);
            _this.debug({
                type: 'breadcrumb',
                message: 'open',
                data: { polling: false },
            });
            _this.chan0Cb = cb;
            _this.connect({ tryCount: 0, websocketFailureCount: 0 });
        };
        this.openChannel = function (options, cb) {
            if (options.name &&
                _this.channelRequests.some(function (cr) { return !cr.closeRequested && cr.options.name === options.name; })) {
                var error = new Error("Channel with name " + options.name + " already opened");
                _this.onUnrecoverableError(error);
                throw error;
            }
            if (_this.destroyed) {
                var error = new Error('Client has been destroyed and is unusable');
                _this.onUnrecoverableError(error);
                throw error;
            }
            var channelRequest = {
                options: options,
                openChannelCb: cb,
                isOpen: false,
                channelId: null,
                cleanupCb: null,
                closeRequested: false,
            };
            _this.channelRequests.push(channelRequest);
            if (_this.connectionState === types_1.ConnectionState.CONNECTED) {
                _this.requestOpenChannel(channelRequest);
            }
            var calledClose = false;
            var closeChannel = function () {
                if (calledClose) {
                    return;
                }
                calledClose = true;
                channelRequest.closeRequested = true;
                if (!channelRequest.isOpen) {
                    _this.channelRequests = _this.channelRequests.filter(function (cr) { return cr !== channelRequest; });
                    return;
                }
                _this.requestCloseChannel(channelRequest);
            };
            return closeChannel;
        };
        this.requestOpenChannel = function (channelRequest) {
            var options = channelRequest.options, openChannelCb = channelRequest.openChannelCb;
            if (!_this.connectOptions) {
                _this.onUnrecoverableError(new Error('Expected connectionOptions'));
                return;
            }
            var skip = options.skip;
            if (skip && skip(_this.connectOptions.context)) {
                return;
            }
            var action = options.action;
            if (!action) {
                action =
                    options.name == null
                        ? protocol_1.api.OpenChannel.Action.CREATE
                        : protocol_1.api.OpenChannel.Action.ATTACH_OR_CREATE;
            }
            if (channelRequest.channelId) {
                _this.onUnrecoverableError(new Error('Unexpected channelId'));
                return;
            }
            var service = typeof options.service === 'string'
                ? options.service
                : options.service(_this.connectOptions.context);
            _this.debug({
                type: 'breadcrumb',
                message: 'handleOpenChannel',
                data: {
                    name: options.name,
                    service: service,
                    action: action,
                },
            });
            var chan0 = _this.getChannel(0);
            var ref = Number(Math.random().toString().split('.')[1]).toString(36);
            chan0.send({
                ref: ref,
                openChan: {
                    name: options.name,
                    service: service,
                    action: action,
                },
            });
            var dispose = chan0.onCommand(function (cmd) {
                if (ref !== cmd.ref) {
                    return;
                }
                dispose();
                if (cmd.openChanRes == null) {
                    _this.onUnrecoverableError(new Error('Expected openChanRes on command'));
                    return;
                }
                var _a = cmd.openChanRes, id = _a.id, state = _a.state, error = _a.error;
                _this.debug({ type: 'breadcrumb', message: 'openChanres' });
                if (!_this.connectOptions) {
                    _this.onUnrecoverableError(new Error('Expected connectionOptions'));
                    return;
                }
                if (state === protocol_1.api.OpenChannelRes.State.ERROR) {
                    _this.onUnrecoverableError(new Error("Channel open resulted with an error: " + (error || 'with no message')));
                    return;
                }
                if (typeof id !== 'number' || typeof state !== 'number') {
                    _this.onUnrecoverableError(new Error('Expected state and channel id'));
                    return;
                }
                var channel = new channel_1.Channel({
                    id: id,
                    onUnrecoverableError: _this.onUnrecoverableError,
                    send: _this.send,
                });
                _this.channels[id] = channel;
                channelRequest.channelId = id;
                channelRequest.isOpen = true;
                var closeRequested = channelRequest.closeRequested;
                channelRequest.cleanupCb = openChannelCb({
                    channel: channel,
                    error: null,
                    context: _this.connectOptions.context,
                });
                if (closeRequested) {
                    _this.requestCloseChannel(channelRequest);
                }
            });
        };
        this.requestCloseChannel = function (channelRequest) { return __awaiter(_this, void 0, void 0, function () {
            var channelId, chan, chan0, res, id;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!channelRequest.isOpen) {
                            this.onUnrecoverableError(new Error('Tried to request a channel close before opening'));
                            return [2];
                        }
                        channelId = channelRequest.channelId;
                        chan = this.getChannel(channelRequest.channelId);
                        chan.status = 'closing';
                        chan0 = this.getChannel(0);
                        if (!chan0) {
                            this.onUnrecoverableError(new Error('Tried to request a channel close but there was no chan0'));
                            return [2];
                        }
                        this.debug({
                            type: 'breadcrumb',
                            message: 'requestChannelClose',
                            data: {
                                id: channelId,
                                name: channelRequest.options.name,
                                service: channelRequest.options.service,
                            },
                        });
                        return [4, chan0.request({
                                closeChan: {
                                    action: protocol_1.api.CloseChannel.Action.TRY_CLOSE,
                                    id: channelRequest.channelId,
                                },
                            })];
                    case 1:
                        res = _a.sent();
                        if (res.channelClosed) {
                            this.debug({
                                type: 'breadcrumb',
                                message: 'requestChannelClose:chan0Closed',
                                data: {
                                    id: channelId,
                                    name: channelRequest.options.name,
                                    service: channelRequest.options.service,
                                },
                            });
                        }
                        else {
                            if (res.closeChanRes == null) {
                                this.onUnrecoverableError(new Error('Expected closeChanRes'));
                                return [2];
                            }
                            id = res.closeChanRes.id;
                            if (id == null) {
                                this.onUnrecoverableError(new Error("Expected id, got " + id));
                                return [2];
                            }
                            if (id !== channelId) {
                                this.onUnrecoverableError(new Error("Expected id from closeChanRes to be " + channelId + " got " + id));
                                return [2];
                            }
                            this.debug({
                                type: 'breadcrumb',
                                message: 'requestChannelClose:closeChanRes',
                                data: {
                                    id: channelId,
                                    name: channelRequest.options.name,
                                    service: channelRequest.options.service,
                                    closeStatus: res.closeChanRes.status,
                                },
                            });
                        }
                        this.channelRequests = this.channelRequests.filter(function (cr) { return cr !== channelRequest; });
                        delete this.channels[channelId];
                        chan.handleClose({ initiator: 'channel', willReconnect: false });
                        if (channelRequest.cleanupCb) {
                            channelRequest.cleanupCb({ initiator: 'channel', willReconnect: false });
                        }
                        return [2];
                }
            });
        }); };
        this.close = function () {
            _this.debug({ type: 'breadcrumb', message: 'user close' });
            if (!_this.chan0Cb || !_this.connectOptions) {
                var error = new Error('Must call client.open before closing');
                _this.onUnrecoverableError(error);
                throw error;
            }
            if (_this.fetchTokenAbortController) {
                _this.fetchTokenAbortController.abort();
                _this.fetchTokenAbortController = null;
            }
            _this.handleClose({ closeReason: ClientCloseReason.Intentional });
        };
        this.destroy = function () {
            _this.destroyed = true;
            _this.debug({ type: 'breadcrumb', message: 'destroy' });
            if (_this.connectionState !== types_1.ConnectionState.DISCONNECTED) {
                _this.close();
            }
            _this.debug = function () { };
            _this.userUnrecoverableErrorHandler = null;
            _this.channelRequests = [];
            _this.destroyed = true;
        };
        this.getChannel = function (id) {
            var chan = _this.channels[id];
            if (!chan) {
                var error = new Error("No channel with number " + id);
                _this.onUnrecoverableError(error);
                throw error;
            }
            return chan;
        };
        this.setDebugFunc = function (debugFunc) {
            _this.debug = debugFunc;
        };
        this.setUnrecoverableErrorHandler = function (onUnrecoverableError) {
            _this.userUnrecoverableErrorHandler = onUnrecoverableError;
        };
        this.getConnectionMetadata = function () { return _this.connectionMetadata; };
        this.connect = function (_a) {
            var tryCount = _a.tryCount, websocketFailureCount = _a.websocketFailureCount;
            return __awaiter(_this, void 0, void 0, function () {
                var error, error, error, chan0, abortController, connectionMetadataFetchResult, e_2, connectionMetadata, aborted, isPolling, WebSocketClass, connStr, ws, onFailed, resetTimeout, cancelTimeout, timeout, timeoutId_1, didReceiveAnyCommand, unlistenChan0;
                var _this = this;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            this.debug({
                                type: 'breadcrumb',
                                message: 'connecting',
                                data: {
                                    connectionState: this.connectionState,
                                    connectTries: tryCount,
                                    websocketFailureCount: websocketFailureCount,
                                    readyState: this.ws ? this.ws.readyState : undefined,
                                    chan0CbExists: Boolean(this.chan0Cb),
                                },
                            });
                            if (this.connectionState !== types_1.ConnectionState.DISCONNECTED) {
                                error = new Error('Client must be disconnected to connect');
                                this.onUnrecoverableError(error);
                                throw error;
                            }
                            if (this.ws) {
                                error = new Error('Unexpected existing websocket instance');
                                this.onUnrecoverableError(error);
                                throw error;
                            }
                            if (!this.connectOptions) {
                                error = new Error('Expected connectionOptions');
                                this.onUnrecoverableError(error);
                                throw error;
                            }
                            if (!this.chan0Cb) {
                                this.onUnrecoverableError(new Error('Expected chan0Cb'));
                                return [2];
                            }
                            if (this.chan0CleanupCb) {
                                this.onUnrecoverableError(new Error('Unexpected chan0CleanupCb, are you sure you closed'));
                                return [2];
                            }
                            if (this.channelRequests.some(function (cr) { return cr.isOpen; })) {
                                this.onUnrecoverableError(new Error('All channels should be closed when we connect'));
                                return [2];
                            }
                            if (Object.keys(this.channels).length) {
                                this.onUnrecoverableError(new Error('Found an an unexpected existing channels'));
                                return [2];
                            }
                            this.connectionState = types_1.ConnectionState.CONNECTING;
                            chan0 = new channel_1.Channel({
                                id: 0,
                                onUnrecoverableError: this.onUnrecoverableError,
                                send: this.send,
                            });
                            this.channels[0] = chan0;
                            if (this.fetchTokenAbortController) {
                                this.onUnrecoverableError(new Error('Expected fetchTokenAbortController to be null'));
                                return [2];
                            }
                            abortController = new AbortController();
                            this.fetchTokenAbortController = abortController;
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 3, , 4]);
                            return [4, this.connectOptions.fetchConnectionMetadata(abortController.signal)];
                        case 2:
                            connectionMetadataFetchResult = _b.sent();
                            return [3, 4];
                        case 3:
                            e_2 = _b.sent();
                            this.onUnrecoverableError(e_2);
                            return [2];
                        case 4:
                            this.fetchTokenAbortController = null;
                            connectionMetadata = connectionMetadataFetchResult;
                            aborted = connectionMetadata.error === types_1.FetchConnectionMetadataError.Aborted;
                            if (abortController.signal.aborted !== aborted) {
                                if (abortController.signal.aborted) {
                                    this.onUnrecoverableError(new Error('Expected abort returned from fetchConnectionMetadata to be truthy when the controller aborts'));
                                    return [2];
                                }
                                this.onUnrecoverableError(new Error('Abort should only be truthy returned when the abort signal is triggered'));
                                return [2];
                            }
                            if (connectionMetadata.error === types_1.FetchConnectionMetadataError.Aborted) {
                                return [2];
                            }
                            if (connectionMetadata.error === types_1.FetchConnectionMetadataError.Retriable) {
                                this.retryConnect({
                                    tryCount: tryCount + 1,
                                    websocketFailureCount: websocketFailureCount,
                                    chan0: chan0,
                                    error: new Error('Retriable error'),
                                });
                                return [2];
                            }
                            if (this.connectionState !== types_1.ConnectionState.CONNECTING) {
                                this.onUnrecoverableError(new Error('Client was closed before connecting'));
                                return [2];
                            }
                            if (connectionMetadata.error) {
                                this.onUnrecoverableError(connectionMetadata.error);
                                return [2];
                            }
                            if (websocketFailureCount === 3) {
                                this.debug({
                                    type: 'breadcrumb',
                                    message: 'polling fallback',
                                });
                            }
                            isPolling = websocketFailureCount >= 3;
                            WebSocketClass = isPolling
                                ? EIOCompat_1.EIOCompat
                                : helpers_1.getWebSocketClass(this.connectOptions.WebSocketClass);
                            connStr = helpers_1.getConnectionStr(connectionMetadata, isPolling);
                            ws = new WebSocketClass(connStr);
                            ws.binaryType = 'arraybuffer';
                            ws.onmessage = this.onSocketMessage;
                            this.ws = ws;
                            this.connectionMetadata = connectionMetadata;
                            onFailed = null;
                            ws.onerror = function () {
                                if (!onFailed) {
                                    _this.onUnrecoverableError(new Error('Got websocket error but no `onFailed` cb'));
                                    return;
                                }
                                onFailed(new Error('WebSocket errored'));
                            };
                            ws.onclose = function () {
                                if (!onFailed) {
                                    _this.onUnrecoverableError(new Error('Got websocket closure but no `onFailed` cb'));
                                    return;
                                }
                                onFailed(new Error('WebSocket closed before we got READY'));
                            };
                            resetTimeout = function () { };
                            cancelTimeout = function () { };
                            timeout = this.connectOptions.timeout;
                            if (timeout !== null) {
                                cancelTimeout = function () {
                                    _this.debug({ type: 'breadcrumb', message: 'cancel timeout' });
                                    clearTimeout(timeoutId_1);
                                };
                                resetTimeout = function () {
                                    _this.debug({ type: 'breadcrumb', message: 'reset timeout' });
                                    clearTimeout(timeoutId_1);
                                    timeoutId_1 = setTimeout(function () {
                                        _this.debug({ type: 'breadcrumb', message: 'connect timeout' });
                                        if (!onFailed) {
                                            _this.onUnrecoverableError(new Error('Connecting timed out but there was no `onFailed` cb'));
                                            return;
                                        }
                                        onFailed(new Error('timeout'));
                                    }, timeout);
                                };
                                resetTimeout();
                            }
                            didReceiveAnyCommand = false;
                            unlistenChan0 = chan0.onCommand(function (cmd) {
                                didReceiveAnyCommand = true;
                                resetTimeout();
                                if (cmd.containerState == null) {
                                    return;
                                }
                                if (cmd.containerState.state == null) {
                                    _this.onUnrecoverableError(new Error('Got containterState but state was not defined'));
                                    return;
                                }
                                var state = cmd.containerState.state;
                                _this.debug({
                                    type: 'breadcrumb',
                                    message: 'containerState',
                                    data: state,
                                });
                                var StateEnum = protocol_1.api.ContainerState.State;
                                switch (state) {
                                    case StateEnum.READY: {
                                        unlistenChan0();
                                        cancelTimeout();
                                        if (!_this.connectOptions) {
                                            _this.onUnrecoverableError(new Error('Expected connectionOptions'));
                                            return;
                                        }
                                        if (!chan0) {
                                            _this.onUnrecoverableError(new Error('Expected chan0 to be truthy'));
                                            return;
                                        }
                                        if (!_this.chan0Cb) {
                                            _this.onUnrecoverableError(new Error('Expected chan0Cb to be truthy'));
                                            return;
                                        }
                                        _this.handleConnect();
                                        var originalClose_1 = _this.close;
                                        _this.close = function () {
                                            return setTimeout(function () {
                                                originalClose_1();
                                            }, 0);
                                        };
                                        _this.chan0CleanupCb = _this.chan0Cb({
                                            channel: chan0,
                                            error: null,
                                            context: _this.connectOptions.context,
                                        });
                                        _this.close = originalClose_1;
                                        break;
                                    }
                                    case StateEnum.SLEEP:
                                        if (!onFailed) {
                                            _this.onUnrecoverableError(new Error('Got SLEEP but there was no `onFailed` cb'));
                                            return;
                                        }
                                        onFailed(new Error('Got SLEEP as container state'));
                                        break;
                                    default:
                                }
                            });
                            onFailed = function (error) {
                                onFailed = null;
                                _this.cleanupSocket();
                                cancelTimeout();
                                unlistenChan0();
                                _this.retryConnect({
                                    tryCount: tryCount + 1,
                                    websocketFailureCount: didReceiveAnyCommand ? 0 : websocketFailureCount + 1,
                                    chan0: chan0,
                                    error: error,
                                });
                            };
                            return [2];
                    }
                });
            });
        };
        this.retryConnect = function (_a) {
            var tryCount = _a.tryCount, websocketFailureCount = _a.websocketFailureCount, chan0 = _a.chan0, error = _a.error;
            if (_this.retryTimeoutId) {
                _this.onUnrecoverableError(new Error('unexpected existing retryTimeoutId'));
                return;
            }
            if (!_this.chan0Cb) {
                return;
            }
            _this.retryTimeoutId = setTimeout(function () {
                if (!_this.chan0Cb) {
                    _this.onUnrecoverableError(new Error('Scheduled retry is called after we closed?'));
                    return;
                }
                _this.retryTimeoutId = null;
                _this.debug({
                    type: 'breadcrumb',
                    message: 'retrying',
                    data: {
                        connectionState: _this.connectionState,
                        connectTries: tryCount,
                        websocketFailureCount: websocketFailureCount,
                        error: error,
                        wsReadyState: _this.ws ? _this.ws.readyState : undefined,
                    },
                });
                chan0.handleClose({ initiator: 'client', willReconnect: true });
                delete _this.channels[0];
                _this.connectionState = types_1.ConnectionState.DISCONNECTED;
                _this.connect({ tryCount: tryCount, websocketFailureCount: websocketFailureCount });
            }, helpers_1.getNextRetryDelay(tryCount));
        };
        this.send = function (cmd) {
            _this.debug({ type: 'log', log: { direction: 'out', cmd: cmd } });
            var cmdBuf = protocol_1.api.Command.encode(cmd).finish();
            var buffer = cmdBuf.buffer.slice(cmdBuf.byteOffset, cmdBuf.byteOffset + cmdBuf.length);
            if (_this.ws == null) {
                _this.onUnrecoverableError(new Error('Calling send on a closed client'));
                return;
            }
            _this.ws.send(buffer);
        };
        this.onSocketMessage = function (_a) {
            var data = _a.data;
            var d = new Uint8Array(data);
            var cmd = protocol_1.api.Command.decode(d);
            _this.debug({ type: 'log', log: { direction: 'in', cmd: cmd } });
            _this.getChannel(cmd.channel).handleCommand(cmd);
        };
        this.handleConnect = function () {
            _this.connectionState = types_1.ConnectionState.CONNECTED;
            _this.debug({ type: 'breadcrumb', message: 'connected!' });
            if (!_this.ws) {
                _this.onUnrecoverableError(new Error('Expected Websocket instance'));
                return;
            }
            var onClose = function (event) {
                if (_this.connectionState === types_1.ConnectionState.DISCONNECTED) {
                    _this.onUnrecoverableError(new Error('Got a close event on socket but client is in disconnected state'));
                    return;
                }
                _this.debug({
                    type: 'breadcrumb',
                    message: 'wsclose',
                    data: {
                        event: event,
                    },
                });
                _this.handleClose({
                    closeReason: ClientCloseReason.Disconnected,
                    wsEvent: event,
                });
            };
            _this.ws.onclose = onClose;
            _this.ws.onerror = onClose;
            _this.channelRequests.forEach(function (channelRequest) {
                _this.requestOpenChannel(channelRequest);
            });
        };
        this.handleClose = function (closeResult) {
            if (closeResult.closeReason !== ClientCloseReason.Error) {
                if (_this.connectionState === types_1.ConnectionState.DISCONNECTED) {
                    _this.onUnrecoverableError(new Error('handleClose is called but client already disconnected'));
                    return;
                }
                if (_this.ws && _this.fetchTokenAbortController) {
                    _this.onUnrecoverableError(new Error('fetchTokenAbortController and websocket exist simultaneously'));
                    return;
                }
            }
            _this.cleanupSocket();
            if (_this.retryTimeoutId) {
                clearTimeout(_this.retryTimeoutId);
            }
            var willClientReconnect = closeResult.closeReason === ClientCloseReason.Disconnected;
            _this.channelRequests.forEach(function (channelRequest) {
                var willChannelReconnect = willClientReconnect && !channelRequest.closeRequested;
                if (channelRequest.isOpen) {
                    var channel = _this.getChannel(channelRequest.channelId);
                    channel.handleClose({
                        initiator: 'client',
                        willReconnect: willChannelReconnect,
                    });
                    delete _this.channels[channelRequest.channelId];
                }
                else if (!willChannelReconnect) {
                    if (_this.connectOptions) {
                        channelRequest.openChannelCb({
                            channel: null,
                            error: new Error('Failed to open'),
                            context: _this.connectOptions.context,
                        });
                    }
                    else if (closeResult.closeReason !== ClientCloseReason.Error) {
                        _this.onUnrecoverableError(new Error('Expected connectionOptions'));
                        return;
                    }
                }
                var cleanupCb = channelRequest.cleanupCb;
                channelRequest.channelId = null;
                channelRequest.isOpen = false;
                channelRequest.cleanupCb = null;
                channelRequest.closeRequested = false;
                if (cleanupCb) {
                    cleanupCb({
                        initiator: 'client',
                        willReconnect: willChannelReconnect,
                    });
                }
            });
            if (_this.channels[0]) {
                _this.channels[0].handleClose({
                    initiator: 'client',
                    willReconnect: willClientReconnect,
                });
                delete _this.channels[0];
            }
            if (Object.keys(_this.channels).length !== 0) {
                _this.channels = {};
                if (closeResult.closeReason !== ClientCloseReason.Error) {
                    _this.onUnrecoverableError(new Error('channels object should be empty after channelRequests and chan0 cleanup'));
                    return;
                }
            }
            if (_this.chan0CleanupCb) {
                _this.chan0CleanupCb({
                    initiator: 'client',
                    willReconnect: willClientReconnect,
                });
                _this.chan0CleanupCb = null;
            }
            else if (!willClientReconnect) {
                if (_this.chan0Cb && _this.connectOptions) {
                    _this.chan0Cb({
                        channel: null,
                        error: new Error('Failed to open'),
                        context: _this.connectOptions.context,
                    });
                }
                else if (closeResult.closeReason !== ClientCloseReason.Error) {
                    _this.onUnrecoverableError(new Error('open should have been called before `handleClose`'));
                    return;
                }
            }
            _this.connectionState = types_1.ConnectionState.DISCONNECTED;
            if (!willClientReconnect) {
                _this.chan0Cb = null;
                _this.connectOptions = null;
                return;
            }
            _this.debug({
                type: 'breadcrumb',
                message: 'reconnecting',
            });
            _this.connect({ tryCount: 0, websocketFailureCount: 0 });
        };
        this.cleanupSocket = function () {
            var ws = _this.ws;
            _this.debug({
                type: 'breadcrumb',
                message: 'cleanupSocket',
                data: {
                    hasWs: Boolean(ws),
                    readyState: ws ? ws.readyState : null,
                    connectionState: _this.connectionState,
                },
            });
            if (!ws) {
                return;
            }
            _this.ws = null;
            _this.connectionMetadata = null;
            ws.onmessage = null;
            ws.onclose = null;
            ws.onerror = function () { };
            if (ws.readyState === 0 || ws.readyState === 1) {
                _this.debug({
                    type: 'breadcrumb',
                    message: 'wsclose',
                });
                ws.close();
            }
        };
        this.onUnrecoverableError = function (e) {
            _this.debug({
                type: 'breadcrumb',
                message: 'unrecoverable error',
                data: {
                    message: e.message,
                },
            });
            if (_this.connectionState !== types_1.ConnectionState.DISCONNECTED) {
                try {
                    _this.handleClose({
                        closeReason: ClientCloseReason.Error,
                        error: e,
                    });
                }
                catch (handleCloseErr) {
                    console.error('handleClose errored during unrecoverable error');
                    console.error(handleCloseErr);
                }
            }
            if (_this.userUnrecoverableErrorHandler) {
                _this.userUnrecoverableErrorHandler(e);
                return;
            }
            console.error('Please supply your own unrecoverable error handling function');
            throw e;
        };
        this.ws = null;
        this.channels = {};
        this.connectOptions = null;
        this.chan0Cb = null;
        this.chan0CleanupCb = null;
        this.connectionState = types_1.ConnectionState.DISCONNECTED;
        this.debug = function () { };
        this.userUnrecoverableErrorHandler = null;
        this.channelRequests = [];
        this.retryTimeoutId = null;
        this.fetchTokenAbortController = null;
        this.destroyed = false;
        this.connectionMetadata = null;
        this.debug({ type: 'breadcrumb', message: 'constructor' });
    }
    return Client;
}());
exports.Client = Client;
//# sourceMappingURL=client.js.map