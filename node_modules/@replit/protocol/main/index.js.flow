/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.14.1
 * @flow
 */

import * as $protobuf from "protobufjs";
export var replit = npm$namespace$replit;

declare var npm$namespace$replit: {|
  goval: typeof npm$namespace$replit$goval,
|};

declare var npm$namespace$replit$goval: {|
  api: typeof npm$namespace$replit$goval$api,
|};

declare var npm$namespace$replit$goval$api: {|
  FileAuthMethod: typeof replit$goval$api$FileAuthMethod,
  State: typeof replit$goval$api$State,
  TokenVersion: typeof replit$goval$api$TokenVersion,
  FlagClaim: typeof replit$goval$api$FlagClaim,
  ICommand: Class<replit$goval$api$ICommand>,
  INixPackageAddRequest: Class<replit$goval$api$INixPackageAddRequest>,
  INixPackageAddResponse: Class<replit$goval$api$INixPackageAddResponse>,
  INixPackageRemoveRequest: Class<replit$goval$api$INixPackageRemoveRequest>,
  INixPackageRemoveResponse: Class<replit$goval$api$INixPackageRemoveResponse>,
  INixPackageListRequest: Class<replit$goval$api$INixPackageListRequest>,
  INixPackageListResponse: Class<replit$goval$api$INixPackageListResponse>,
  INixPackage: Class<replit$goval$api$INixPackage>,
  INixChannelsRequest: Class<replit$goval$api$INixChannelsRequest>,
  INixChannelsResponse: Class<replit$goval$api$INixChannelsResponse>,
  INixChannelLatestStableRequest: Class<replit$goval$api$INixChannelLatestStableRequest>,
  INixChannelLatestStableResponse: Class<replit$goval$api$INixChannelLatestStableResponse>,
  INixPackageSearchRequest: Class<replit$goval$api$INixPackageSearchRequest>,
  INixPackageSearchResponse: Class<replit$goval$api$INixPackageSearchResponse>,
  IStartLSP: Class<replit$goval$api$IStartLSP>,
  IAudio: Class<replit$goval$api$IAudio>,
  IAudio2: Class<replit$goval$api$IAudio2>,
  IPreconditions: Class<replit$goval$api$IPreconditions>,
  IReadMetaRequest: Class<replit$goval$api$IReadMetaRequest>,
  IReadMetaResponse: Class<replit$goval$api$IReadMetaResponse>,
  IWriteMetaRequest: Class<replit$goval$api$IWriteMetaRequest>,
  IWriteMetaResponse: Class<replit$goval$api$IWriteMetaResponse>,
  IAppendMetaRequest: Class<replit$goval$api$IAppendMetaRequest>,
  IAppendMetaResponse: Class<replit$goval$api$IAppendMetaResponse>,
  IBootStatus: Class<replit$goval$api$IBootStatus>,
  IPid1Config: Class<replit$goval$api$IPid1Config>,
  IFSLock: Class<replit$goval$api$IFSLock>,
  IFSSnapshot: Class<replit$goval$api$IFSSnapshot>,
  IFSSnapshotEvent: Class<replit$goval$api$IFSSnapshotEvent>,
  ISnapshotEvent: Class<replit$goval$api$ISnapshotEvent>,
  ISubscribeFile: Class<replit$goval$api$ISubscribeFile>,
  IFileEvent: Class<replit$goval$api$IFileEvent>,
  IFlush: Class<replit$goval$api$IFlush>,
  IOTLinkFile: Class<replit$goval$api$IOTLinkFile>,
  IOTLinkFileResponse: Class<replit$goval$api$IOTLinkFileResponse>,
  IAuth: Class<replit$goval$api$IAuth>,
  IVCREntry: Class<replit$goval$api$IVCREntry>,
  IStartVCR: Class<replit$goval$api$IStartVCR>,
  IReadVCR: Class<replit$goval$api$IReadVCR>,
  IVCRLog: Class<replit$goval$api$IVCRLog>,
  IExecInfo: Class<replit$goval$api$IExecInfo>,
  IDebug: Class<replit$goval$api$IDebug>,
  IFileAuthReq: Class<replit$goval$api$IFileAuthReq>,
  IMultiFileAuthRes: Class<replit$goval$api$IMultiFileAuthRes>,
  IFileAuthRes: Class<replit$goval$api$IFileAuthRes>,
  IListObjects: Class<replit$goval$api$IListObjects>,
  IListObjectsResp: Class<replit$goval$api$IListObjectsResp>,
  IDisconnect: Class<replit$goval$api$IDisconnect>,
  ISend: Class<replit$goval$api$ISend>,
  IRecv: Class<replit$goval$api$IRecv>,
  IConnect: Class<replit$goval$api$IConnect>,
  IHint: Class<replit$goval$api$IHint>,
  IPing: Class<replit$goval$api$IPing>,
  IPong: Class<replit$goval$api$IPong>,
  IHello: Class<replit$goval$api$IHello>,
  IGoodbye: Class<replit$goval$api$IGoodbye>,
  ICheckChanges: Class<replit$goval$api$ICheckChanges>,
  IEnsurePackages: Class<replit$goval$api$IEnsurePackages>,
  IStart: Class<replit$goval$api$IStart>,
  IDebugStatus: Class<replit$goval$api$IDebugStatus>,
  IStackFrame: Class<replit$goval$api$IStackFrame>,
  IContainedTest: Class<replit$goval$api$IContainedTest>,
  ITestResult: Class<replit$goval$api$ITestResult>,
  ITestFailure: Class<replit$goval$api$ITestFailure>,
  IResizeTerm: Class<replit$goval$api$IResizeTerm>,
  ISaneTerm: Class<replit$goval$api$ISaneTerm>,
  ILintResults: Class<replit$goval$api$ILintResults>,
  ILintResult: Class<replit$goval$api$ILintResult>,
  IOK: Class<replit$goval$api$IOK>,
  IMove: Class<replit$goval$api$IMove>,
  IFiles: Class<replit$goval$api$IFiles>,
  IStatResult: Class<replit$goval$api$IStatResult>,
  IFile: Class<replit$goval$api$IFile>,
  ITransfer: Class<replit$goval$api$ITransfer>,
  ITransferStart: Class<replit$goval$api$ITransferStart>,
  ITransferChunk: Class<replit$goval$api$ITransferChunk>,
  ITransferComplete: Class<replit$goval$api$ITransferComplete>,
  IClear: Class<replit$goval$api$IClear>,
  IToast: Class<replit$goval$api$IToast>,
  IProtocolError: Class<replit$goval$api$IProtocolError>,
  IRedirect: Class<replit$goval$api$IRedirect>,
  IAlwaysOn: Class<replit$goval$api$IAlwaysOn>,
  IRunMain: Class<replit$goval$api$IRunMain>,
  IOpenChannel: Class<replit$goval$api$IOpenChannel>,
  IOpenChannelRes: Class<replit$goval$api$IOpenChannelRes>,
  ICloseChannel: Class<replit$goval$api$ICloseChannel>,
  ICloseChannelRes: Class<replit$goval$api$ICloseChannelRes>,
  IContainerState: Class<replit$goval$api$IContainerState>,
  IPortOpen: Class<replit$goval$api$IPortOpen>,
  IPortClose: Class<replit$goval$api$IPortClose>,
  IOTFetchRequest: Class<replit$goval$api$IOTFetchRequest>,
  IOTFetchResponse: Class<replit$goval$api$IOTFetchResponse>,
  IOTTransformSelectionRequest: Class<replit$goval$api$IOTTransformSelectionRequest>,
  IOTTransformSelectionResponse: Class<replit$goval$api$IOTTransformSelectionResponse>,
  IOTPacket: Class<replit$goval$api$IOTPacket>,
  IOTOpComponent: Class<replit$goval$api$IOTOpComponent>,
  IOTStatus: Class<replit$goval$api$IOTStatus>,
  IOTCursor: Class<replit$goval$api$IOTCursor>,
  IChatMessage: Class<replit$goval$api$IChatMessage>,
  IChatTyping: Class<replit$goval$api$IChatTyping>,
  IUser: Class<replit$goval$api$IUser>,
  IRoster: Class<replit$goval$api$IRoster>,
  IOpenFile: Class<replit$goval$api$IOpenFile>,
  IFileOpened: Class<replit$goval$api$IFileOpened>,
  IReplspaceApiOpenFile: Class<replit$goval$api$IReplspaceApiOpenFile>,
  IReplspaceApiCloseFile: Class<replit$goval$api$IReplspaceApiCloseFile>,
  IReplspaceApiGetGitHubToken: Class<replit$goval$api$IReplspaceApiGetGitHubToken>,
  IReplspaceApiGitHubToken: Class<replit$goval$api$IReplspaceApiGitHubToken>,
  IUpdateSessionTimestamp: Class<replit$goval$api$IUpdateSessionTimestamp>,
  ISessionTimestampUpdated: Class<replit$goval$api$ISessionTimestampUpdated>,
  IFollowUser: Class<replit$goval$api$IFollowUser>,
  IUnfollowUser: Class<replit$goval$api$IUnfollowUser>,
  IExec: Class<replit$goval$api$IExec>,
  IPackage: Class<replit$goval$api$IPackage>,
  IPackageSearch: Class<replit$goval$api$IPackageSearch>,
  IPackageSearchResp: Class<replit$goval$api$IPackageSearchResp>,
  IPackageInfo: Class<replit$goval$api$IPackageInfo>,
  IPackageInfoResp: Class<replit$goval$api$IPackageInfoResp>,
  IPackageAdd: Class<replit$goval$api$IPackageAdd>,
  IPackageRemove: Class<replit$goval$api$IPackageRemove>,
  IPackageInstall: Class<replit$goval$api$IPackageInstall>,
  IPackageListSpecfile: Class<replit$goval$api$IPackageListSpecfile>,
  IPackageListSpecfileResp: Class<replit$goval$api$IPackageListSpecfileResp>,
  IPackageCacheSave: Class<replit$goval$api$IPackageCacheSave>,
  IChatScrollback: Class<replit$goval$api$IChatScrollback>,
  IMetrics: Class<replit$goval$api$IMetrics>,
  IPprofRequest: Class<replit$goval$api$IPprofRequest>,
  IPprofAllocsProfileRequest: Class<replit$goval$api$IPprofAllocsProfileRequest>,
  IPprofBlockProfileRequest: Class<replit$goval$api$IPprofBlockProfileRequest>,
  IPprofCpuProfileRequest: Class<replit$goval$api$IPprofCpuProfileRequest>,
  IPprofHeapProfileRequest: Class<replit$goval$api$IPprofHeapProfileRequest>,
  IPprofMutexProfileRequest: Class<replit$goval$api$IPprofMutexProfileRequest>,
  IPprofResponse: Class<replit$goval$api$IPprofResponse>,
  IPTYConfig: Class<replit$goval$api$IPTYConfig>,
  IDebugMain: Class<replit$goval$api$IDebugMain>,
  IDebugMainReply: Class<replit$goval$api$IDebugMainReply>,
  IDebugState: Class<replit$goval$api$IDebugState>,
  IDebugInput: Class<replit$goval$api$IDebugInput>,
  IDebugOutput: Class<replit$goval$api$IDebugOutput>,
  IDebugStop: Class<replit$goval$api$IDebugStop>,
  IDebugLeave: Class<replit$goval$api$IDebugLeave>,
  IDebugSessions: Class<replit$goval$api$IDebugSessions>,
  IDotReplitGetRequest: Class<replit$goval$api$IDotReplitGetRequest>,
  IDotReplitGetResponse: Class<replit$goval$api$IDotReplitGetResponse>,
  IRunConfigGetRequest: Class<replit$goval$api$IRunConfigGetRequest>,
  IRunConfigGetResponse: Class<replit$goval$api$IRunConfigGetResponse>,
  IDotReplitUpdateOp: Class<replit$goval$api$IDotReplitUpdateOp>,
  IDotReplitUpdateRequest: Class<replit$goval$api$IDotReplitUpdateRequest>,
  IDotReplitUpdateResponse: Class<replit$goval$api$IDotReplitUpdateResponse>,
  IDebugAddBreakpointRequest: Class<replit$goval$api$IDebugAddBreakpointRequest>,
  IDebugUpdateBreakpointRequest: Class<replit$goval$api$IDebugUpdateBreakpointRequest>,
  IDebugRemoveBreakpointRequest: Class<replit$goval$api$IDebugRemoveBreakpointRequest>,
  IDebugBreakpointEvent: Class<replit$goval$api$IDebugBreakpointEvent>,
  IDebugBreakpoint: Class<replit$goval$api$IDebugBreakpoint>,
  IDotReplit: Class<replit$goval$api$IDotReplit>,
  IDotReplitEnvVar: Class<replit$goval$api$IDotReplitEnvVar>,
  IDotReplitPort: Class<replit$goval$api$IDotReplitPort>,
  IDotReplitHint: Class<replit$goval$api$IDotReplitHint>,
  IGitHubImportConfig: Class<replit$goval$api$IGitHubImportConfig>,
  IDeploymentConfig: Class<replit$goval$api$IDeploymentConfig>,
  INixConfig: Class<replit$goval$api$INixConfig>,
  IHostingConfig: Class<replit$goval$api$IHostingConfig>,
  IAuthConfig: Class<replit$goval$api$IAuthConfig>,
  IDotReplitInterp: Class<replit$goval$api$IDotReplitInterp>,
  IDotReplitLanguage: Class<replit$goval$api$IDotReplitLanguage>,
  ILanguageServerConfig: Class<replit$goval$api$ILanguageServerConfig>,
  IDotReplitPackager: Class<replit$goval$api$IDotReplitPackager>,
  IDotReplitPackagerFeatures: Class<replit$goval$api$IDotReplitPackagerFeatures>,
  IDotReplitUnitTest: Class<replit$goval$api$IDotReplitUnitTest>,
  IDebuggerConfig: Class<replit$goval$api$IDebuggerConfig>,
  ICompileConfig: Class<replit$goval$api$ICompileConfig>,
  IDapConfig: Class<replit$goval$api$IDapConfig>,
  ITimeTravelConfig: Class<replit$goval$api$ITimeTravelConfig>,
  IDapIntegratedAdapterConfig: Class<replit$goval$api$IDapIntegratedAdapterConfig>,
  IProxyGoingAway: Class<replit$goval$api$IProxyGoingAway>,
  IFirewallDenied: Class<replit$goval$api$IFirewallDenied>,
  IReplLogMessage: Class<replit$goval$api$IReplLogMessage>,
  IUserEvent: Class<replit$goval$api$IUserEvent>,
  IReplToken: Class<replit$goval$api$IReplToken>,
  ITLSCertificate: Class<replit$goval$api$ITLSCertificate>,
  IReplTransfer: Class<replit$goval$api$IReplTransfer>,
  IAllowReplRequest: Class<replit$goval$api$IAllowReplRequest>,
  IClusterMetadata: Class<replit$goval$api$IClusterMetadata>,
  IEvictReplRequest: Class<replit$goval$api$IEvictReplRequest>,
  IEvictReplResponse: Class<replit$goval$api$IEvictReplResponse>,
  IGovalSigningAuthority: Class<replit$goval$api$IGovalSigningAuthority>,
  ICertificateClaim: Class<replit$goval$api$ICertificateClaim>,
  IGovalCert: Class<replit$goval$api$IGovalCert>,
  IGovalToken: Class<replit$goval$api$IGovalToken>,
  IGovalReplIdentity: Class<replit$goval$api$IGovalReplIdentity>,
  ILoreCommand: Class<replit$goval$api$ILoreCommand>,
  IClusterTransfer: Class<replit$goval$api$IClusterTransfer>,
  ISoftTakedown: Class<replit$goval$api$ISoftTakedown>,
  IGovalCommand: Class<replit$goval$api$IGovalCommand>,
  IPartialUpdateMetadata: Class<replit$goval$api$IPartialUpdateMetadata>,
  IMultiGovalCommand: Class<replit$goval$api$IMultiGovalCommand>,
  IKillRepl: Class<replit$goval$api$IKillRepl>,
  IRestore: Class<replit$goval$api$IRestore>,
  IUpdateSourceRepl: Class<replit$goval$api$IUpdateSourceRepl>,
  IUpdateReplFlags: Class<replit$goval$api$IUpdateReplFlags>,
  Command: typeof replit$goval$api$Command,
  NixPackageAddRequest: typeof replit$goval$api$NixPackageAddRequest,
  NixPackageAddResponse: typeof replit$goval$api$NixPackageAddResponse,
  NixPackageRemoveRequest: typeof replit$goval$api$NixPackageRemoveRequest,
  NixPackageRemoveResponse: typeof replit$goval$api$NixPackageRemoveResponse,
  NixPackageListRequest: typeof replit$goval$api$NixPackageListRequest,
  NixPackageListResponse: typeof replit$goval$api$NixPackageListResponse,
  NixPackage: typeof replit$goval$api$NixPackage,
  NixChannelsRequest: typeof replit$goval$api$NixChannelsRequest,
  NixChannelsResponse: typeof replit$goval$api$NixChannelsResponse,
  NixChannelLatestStableRequest: typeof replit$goval$api$NixChannelLatestStableRequest,
  NixChannelLatestStableResponse: typeof replit$goval$api$NixChannelLatestStableResponse,
  NixPackageSearchRequest: typeof replit$goval$api$NixPackageSearchRequest,
  NixPackageSearchResponse: typeof replit$goval$api$NixPackageSearchResponse,
  StartLSP: typeof replit$goval$api$StartLSP,
  Audio: typeof replit$goval$api$Audio,
  Audio2: typeof replit$goval$api$Audio2,
  Preconditions: typeof replit$goval$api$Preconditions,
  ReadMetaRequest: typeof replit$goval$api$ReadMetaRequest,
  ReadMetaResponse: typeof replit$goval$api$ReadMetaResponse,
  WriteMetaRequest: typeof replit$goval$api$WriteMetaRequest,
  WriteMetaResponse: typeof replit$goval$api$WriteMetaResponse,
  AppendMetaRequest: typeof replit$goval$api$AppendMetaRequest,
  AppendMetaResponse: typeof replit$goval$api$AppendMetaResponse,
  BootStatus: typeof replit$goval$api$BootStatus,
  Pid1Config: typeof replit$goval$api$Pid1Config,
  FSLock: typeof replit$goval$api$FSLock,
  FSSnapshot: typeof replit$goval$api$FSSnapshot,
  FSSnapshotEvent: typeof replit$goval$api$FSSnapshotEvent,
  SnapshotEvent: typeof replit$goval$api$SnapshotEvent,
  SubscribeFile: typeof replit$goval$api$SubscribeFile,
  FileEvent: typeof replit$goval$api$FileEvent,
  Flush: typeof replit$goval$api$Flush,
  OTLinkFile: typeof replit$goval$api$OTLinkFile,
  OTLinkFileResponse: typeof replit$goval$api$OTLinkFileResponse,
  Auth: typeof replit$goval$api$Auth,
  VCREntry: typeof replit$goval$api$VCREntry,
  StartVCR: typeof replit$goval$api$StartVCR,
  ReadVCR: typeof replit$goval$api$ReadVCR,
  VCRLog: typeof replit$goval$api$VCRLog,
  ExecInfo: typeof replit$goval$api$ExecInfo,
  Debug: typeof replit$goval$api$Debug,
  FileAuthReq: typeof replit$goval$api$FileAuthReq,
  MultiFileAuthRes: typeof replit$goval$api$MultiFileAuthRes,
  FileAuthRes: typeof replit$goval$api$FileAuthRes,
  ListObjects: typeof replit$goval$api$ListObjects,
  ListObjectsResp: typeof replit$goval$api$ListObjectsResp,
  Disconnect: typeof replit$goval$api$Disconnect,
  Send: typeof replit$goval$api$Send,
  Recv: typeof replit$goval$api$Recv,
  Connect: typeof replit$goval$api$Connect,
  Hint: typeof replit$goval$api$Hint,
  Ping: typeof replit$goval$api$Ping,
  Pong: typeof replit$goval$api$Pong,
  Hello: typeof replit$goval$api$Hello,
  Goodbye: typeof replit$goval$api$Goodbye,
  CheckChanges: typeof replit$goval$api$CheckChanges,
  EnsurePackages: typeof replit$goval$api$EnsurePackages,
  Start: typeof replit$goval$api$Start,
  DebugStatus: typeof replit$goval$api$DebugStatus,
  StackFrame: typeof replit$goval$api$StackFrame,
  ContainedTest: typeof replit$goval$api$ContainedTest,
  TestResult: typeof replit$goval$api$TestResult,
  TestFailure: typeof replit$goval$api$TestFailure,
  ResizeTerm: typeof replit$goval$api$ResizeTerm,
  SaneTerm: typeof replit$goval$api$SaneTerm,
  LintResults: typeof replit$goval$api$LintResults,
  LintResult: typeof replit$goval$api$LintResult,
  OK: typeof replit$goval$api$OK,
  Move: typeof replit$goval$api$Move,
  Files: typeof replit$goval$api$Files,
  StatResult: typeof replit$goval$api$StatResult,
  File: typeof replit$goval$api$File,
  Transfer: typeof replit$goval$api$Transfer,
  TransferStart: typeof replit$goval$api$TransferStart,
  TransferChunk: typeof replit$goval$api$TransferChunk,
  TransferComplete: typeof replit$goval$api$TransferComplete,
  Clear: typeof replit$goval$api$Clear,
  Toast: typeof replit$goval$api$Toast,
  ProtocolError: typeof replit$goval$api$ProtocolError,
  Redirect: typeof replit$goval$api$Redirect,
  AlwaysOn: typeof replit$goval$api$AlwaysOn,
  RunMain: typeof replit$goval$api$RunMain,
  OpenChannel: typeof replit$goval$api$OpenChannel,
  OpenChannelRes: typeof replit$goval$api$OpenChannelRes,
  CloseChannel: typeof replit$goval$api$CloseChannel,
  CloseChannelRes: typeof replit$goval$api$CloseChannelRes,
  ContainerState: typeof replit$goval$api$ContainerState,
  PortOpen: typeof replit$goval$api$PortOpen,
  PortClose: typeof replit$goval$api$PortClose,
  OTFetchRequest: typeof replit$goval$api$OTFetchRequest,
  OTFetchResponse: typeof replit$goval$api$OTFetchResponse,
  OTTransformSelectionRequest: typeof replit$goval$api$OTTransformSelectionRequest,
  OTTransformSelectionResponse: typeof replit$goval$api$OTTransformSelectionResponse,
  OTPacket: typeof replit$goval$api$OTPacket,
  OTOpComponent: typeof replit$goval$api$OTOpComponent,
  OTStatus: typeof replit$goval$api$OTStatus,
  OTCursor: typeof replit$goval$api$OTCursor,
  ChatMessage: typeof replit$goval$api$ChatMessage,
  ChatTyping: typeof replit$goval$api$ChatTyping,
  User: typeof replit$goval$api$User,
  Roster: typeof replit$goval$api$Roster,
  OpenFile: typeof replit$goval$api$OpenFile,
  FileOpened: typeof replit$goval$api$FileOpened,
  ReplspaceApiOpenFile: typeof replit$goval$api$ReplspaceApiOpenFile,
  ReplspaceApiCloseFile: typeof replit$goval$api$ReplspaceApiCloseFile,
  ReplspaceApiGetGitHubToken: typeof replit$goval$api$ReplspaceApiGetGitHubToken,
  ReplspaceApiGitHubToken: typeof replit$goval$api$ReplspaceApiGitHubToken,
  UpdateSessionTimestamp: typeof replit$goval$api$UpdateSessionTimestamp,
  SessionTimestampUpdated: typeof replit$goval$api$SessionTimestampUpdated,
  FollowUser: typeof replit$goval$api$FollowUser,
  UnfollowUser: typeof replit$goval$api$UnfollowUser,
  Exec: typeof replit$goval$api$Exec,
  Package: typeof replit$goval$api$Package,
  PackageSearch: typeof replit$goval$api$PackageSearch,
  PackageSearchResp: typeof replit$goval$api$PackageSearchResp,
  PackageInfo: typeof replit$goval$api$PackageInfo,
  PackageInfoResp: typeof replit$goval$api$PackageInfoResp,
  PackageAdd: typeof replit$goval$api$PackageAdd,
  PackageRemove: typeof replit$goval$api$PackageRemove,
  PackageInstall: typeof replit$goval$api$PackageInstall,
  PackageListSpecfile: typeof replit$goval$api$PackageListSpecfile,
  PackageListSpecfileResp: typeof replit$goval$api$PackageListSpecfileResp,
  PackageCacheSave: typeof replit$goval$api$PackageCacheSave,
  ChatScrollback: typeof replit$goval$api$ChatScrollback,
  Metrics: typeof replit$goval$api$Metrics,
  PprofRequest: typeof replit$goval$api$PprofRequest,
  PprofAllocsProfileRequest: typeof replit$goval$api$PprofAllocsProfileRequest,
  PprofBlockProfileRequest: typeof replit$goval$api$PprofBlockProfileRequest,
  PprofCpuProfileRequest: typeof replit$goval$api$PprofCpuProfileRequest,
  PprofHeapProfileRequest: typeof replit$goval$api$PprofHeapProfileRequest,
  PprofMutexProfileRequest: typeof replit$goval$api$PprofMutexProfileRequest,
  PprofResponse: typeof replit$goval$api$PprofResponse,
  PTYConfig: typeof replit$goval$api$PTYConfig,
  DebugMain: typeof replit$goval$api$DebugMain,
  DebugMainReply: typeof replit$goval$api$DebugMainReply,
  DebugState: typeof replit$goval$api$DebugState,
  DebugInput: typeof replit$goval$api$DebugInput,
  DebugOutput: typeof replit$goval$api$DebugOutput,
  DebugStop: typeof replit$goval$api$DebugStop,
  DebugLeave: typeof replit$goval$api$DebugLeave,
  DebugSessions: typeof replit$goval$api$DebugSessions,
  DotReplitGetRequest: typeof replit$goval$api$DotReplitGetRequest,
  DotReplitGetResponse: typeof replit$goval$api$DotReplitGetResponse,
  RunConfigGetRequest: typeof replit$goval$api$RunConfigGetRequest,
  RunConfigGetResponse: typeof replit$goval$api$RunConfigGetResponse,
  DotReplitUpdateOp: typeof replit$goval$api$DotReplitUpdateOp,
  DotReplitUpdateRequest: typeof replit$goval$api$DotReplitUpdateRequest,
  DotReplitUpdateResponse: typeof replit$goval$api$DotReplitUpdateResponse,
  DebugAddBreakpointRequest: typeof replit$goval$api$DebugAddBreakpointRequest,
  DebugUpdateBreakpointRequest: typeof replit$goval$api$DebugUpdateBreakpointRequest,
  DebugRemoveBreakpointRequest: typeof replit$goval$api$DebugRemoveBreakpointRequest,
  DebugBreakpointEvent: typeof replit$goval$api$DebugBreakpointEvent,
  DebugBreakpoint: typeof replit$goval$api$DebugBreakpoint,
  DotReplit: typeof replit$goval$api$DotReplit,
  DotReplitEnvVar: typeof replit$goval$api$DotReplitEnvVar,
  DotReplitPort: typeof replit$goval$api$DotReplitPort,
  DotReplitHint: typeof replit$goval$api$DotReplitHint,
  GitHubImportConfig: typeof replit$goval$api$GitHubImportConfig,
  DeploymentConfig: typeof replit$goval$api$DeploymentConfig,
  NixConfig: typeof replit$goval$api$NixConfig,
  HostingConfig: typeof replit$goval$api$HostingConfig,
  AuthConfig: typeof replit$goval$api$AuthConfig,
  DotReplitInterp: typeof replit$goval$api$DotReplitInterp,
  DotReplitLanguage: typeof replit$goval$api$DotReplitLanguage,
  LanguageServerConfig: typeof replit$goval$api$LanguageServerConfig,
  DotReplitPackager: typeof replit$goval$api$DotReplitPackager,
  DotReplitPackagerFeatures: typeof replit$goval$api$DotReplitPackagerFeatures,
  DotReplitUnitTest: typeof replit$goval$api$DotReplitUnitTest,
  DebuggerConfig: typeof replit$goval$api$DebuggerConfig,
  CompileConfig: typeof replit$goval$api$CompileConfig,
  DapConfig: typeof replit$goval$api$DapConfig,
  TimeTravelConfig: typeof replit$goval$api$TimeTravelConfig,
  DapIntegratedAdapterConfig: typeof replit$goval$api$DapIntegratedAdapterConfig,
  ProxyGoingAway: typeof replit$goval$api$ProxyGoingAway,
  FirewallDenied: typeof replit$goval$api$FirewallDenied,
  ReplLogMessage: typeof replit$goval$api$ReplLogMessage,
  UserEvent: typeof replit$goval$api$UserEvent,
  ReplToken: typeof replit$goval$api$ReplToken,
  TLSCertificate: typeof replit$goval$api$TLSCertificate,
  ReplTransfer: typeof replit$goval$api$ReplTransfer,
  AllowReplRequest: typeof replit$goval$api$AllowReplRequest,
  ClusterMetadata: typeof replit$goval$api$ClusterMetadata,
  EvictReplRequest: typeof replit$goval$api$EvictReplRequest,
  EvictReplResponse: typeof replit$goval$api$EvictReplResponse,
  GovalSigningAuthority: typeof replit$goval$api$GovalSigningAuthority,
  CertificateClaim: typeof replit$goval$api$CertificateClaim,
  GovalCert: typeof replit$goval$api$GovalCert,
  GovalToken: typeof replit$goval$api$GovalToken,
  GovalReplIdentity: typeof replit$goval$api$GovalReplIdentity,
  LoreCommand: typeof replit$goval$api$LoreCommand,
  ClusterTransfer: typeof replit$goval$api$ClusterTransfer,
  SoftTakedown: typeof replit$goval$api$SoftTakedown,
  GovalCommand: typeof replit$goval$api$GovalCommand,
  PartialUpdateMetadata: typeof replit$goval$api$PartialUpdateMetadata,
  MultiGovalCommand: typeof replit$goval$api$MultiGovalCommand,
  KillRepl: typeof replit$goval$api$KillRepl,
  Restore: typeof replit$goval$api$Restore,
  UpdateSourceRepl: typeof replit$goval$api$UpdateSourceRepl,
  UpdateReplFlags: typeof replit$goval$api$UpdateReplFlags,
  features: typeof npm$namespace$replit$goval$api$features,
  repl: typeof npm$namespace$replit$goval$api$repl,
|};

/**
 * Properties of a Command.
 */
declare type replit$goval$api$ICommand = {|
  /**
   * Command channel
   */
  channel?: number | null,

  /**
   * Command session
   */
  session?: number | null,

  /**
   * Command openChan
   */
  openChan?:
    | replit$goval$api$OpenChannel
    | replit$goval$api$IOpenChannel
    | null,

  /**
   * Command openChanRes
   */
  openChanRes?:
    | replit$goval$api$OpenChannelRes
    | replit$goval$api$IOpenChannelRes
    | null,

  /**
   * Command closeChan
   */
  closeChan?:
    | replit$goval$api$CloseChannel
    | replit$goval$api$ICloseChannel
    | null,

  /**
   * Command closeChanRes
   */
  closeChanRes?:
    | replit$goval$api$CloseChannelRes
    | replit$goval$api$ICloseChannelRes
    | null,

  /**
   * Command containerState
   */
  containerState?:
    | replit$goval$api$ContainerState
    | replit$goval$api$IContainerState
    | null,

  /**
   * Command portOpen
   */
  portOpen?: replit$goval$api$PortOpen | replit$goval$api$IPortOpen | null,

  /**
   * Command portClose
   */
  portClose?: replit$goval$api$PortClose | replit$goval$api$IPortClose | null,

  /**
   * Command toast
   */
  toast?: replit$goval$api$Toast | replit$goval$api$IToast | null,

  /**
   * Command protocolError
   */
  protocolError?:
    | replit$goval$api$ProtocolError
    | replit$goval$api$IProtocolError
    | null,

  /**
   * Command redirect
   */
  redirect?: replit$goval$api$Redirect | replit$goval$api$IRedirect | null,

  /**
   * Command alwaysOn
   */
  alwaysOn?: replit$goval$api$AlwaysOn | replit$goval$api$IAlwaysOn | null,

  /**
   * Command runMain
   */
  runMain?: replit$goval$api$RunMain | replit$goval$api$IRunMain | null,

  /**
   * Command clear
   */
  clear?: replit$goval$api$Clear | replit$goval$api$IClear | null,

  /**
   * Command eval
   */
  eval?: string | null,

  /**
   * Command result
   */
  result?: string | null,

  /**
   * Command input
   */
  input?: string | null,

  /**
   * Command output
   */
  output?: string | null,

  /**
   * Command error
   */
  error?: string | null,

  /**
   * Command stderr
   */
  stderr?: string | null,

  /**
   * Command log
   */
  log?: string | null,

  /**
   * Command record
   */
  record?: string | null,

  /**
   * Command saneTerm
   */
  saneTerm?: replit$goval$api$SaneTerm | replit$goval$api$ISaneTerm | null,

  /**
   * Command resizeTerm
   */
  resizeTerm?:
    | replit$goval$api$ResizeTerm
    | replit$goval$api$IResizeTerm
    | null,

  /**
   * Command state
   */
  state?: $Values<typeof replit$goval$api$State> | null,

  /**
   * Command ok
   */
  ok?: replit$goval$api$OK | replit$goval$api$IOK | null,

  /**
   * Command persist
   */
  persist?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * Command persistMirror
   */
  persistMirror?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * Command write
   */
  write?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * Command remove
   */
  remove?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * Command move
   */
  move?: replit$goval$api$Move | replit$goval$api$IMove | null,

  /**
   * Command tryRemove
   */
  tryRemove?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * Command mkdir
   */
  mkdir?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * Command stat
   */
  stat?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * Command statRes
   */
  statRes?: replit$goval$api$StatResult | replit$goval$api$IStatResult | null,

  /**
   * Command transferStart
   */
  transferStart?:
    | replit$goval$api$TransferStart
    | replit$goval$api$ITransferStart
    | null,

  /**
   * Command transferChunk
   */
  transferChunk?:
    | replit$goval$api$TransferChunk
    | replit$goval$api$ITransferChunk
    | null,

  /**
   * Command transferComplete
   */
  transferComplete?:
    | replit$goval$api$TransferComplete
    | replit$goval$api$ITransferComplete
    | null,

  /**
   * Command transferCancel
   */
  transferCancel?:
    | replit$goval$api$Transfer
    | replit$goval$api$ITransfer
    | null,

  /**
   * Command transfer
   */
  transfer?: replit$goval$api$Transfer | replit$goval$api$ITransfer | null,

  /**
   * Command read
   */
  read?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * Command readdir
   */
  readdir?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * Command files
   */
  files?: replit$goval$api$Files | replit$goval$api$IFiles | null,

  /**
   * Command file
   */
  file?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * Command checkChanges
   */
  checkChanges?:
    | replit$goval$api$CheckChanges
    | replit$goval$api$ICheckChanges
    | null,

  /**
   * Command changedFiles
   */
  changedFiles?: replit$goval$api$Files | replit$goval$api$IFiles | null,

  /**
   * Command lintResults
   */
  lintResults?:
    | replit$goval$api$LintResults
    | replit$goval$api$ILintResults
    | null,

  /**
   * Command runContainedTest
   */
  runContainedTest?:
    | replit$goval$api$ContainedTest
    | replit$goval$api$IContainedTest
    | null,

  /**
   * Command testResult
   */
  testResult?:
    | replit$goval$api$TestResult
    | replit$goval$api$ITestResult
    | null,

  /**
   * Command debuggerStart
   */
  debuggerStart?: string | null,

  /**
   * Command debuggerStep
   */
  debuggerStep?: replit$goval$api$RunMain | replit$goval$api$IRunMain | null,

  /**
   * Command debuggerStatus
   */
  debuggerStatus?:
    | replit$goval$api$DebugStatus
    | replit$goval$api$IDebugStatus
    | null,

  /**
   * Command ensurePackages
   */
  ensurePackages?:
    | replit$goval$api$EnsurePackages
    | replit$goval$api$IEnsurePackages
    | null,

  /**
   * Command ping
   */
  ping?: replit$goval$api$Ping | replit$goval$api$IPing | null,

  /**
   * Command pong
   */
  pong?: replit$goval$api$Pong | replit$goval$api$IPong | null,

  /**
   * Command hello
   */
  hello?: replit$goval$api$Hello | replit$goval$api$IHello | null,

  /**
   * Command goodbye
   */
  goodbye?: replit$goval$api$Goodbye | replit$goval$api$IGoodbye | null,

  /**
   * Command proxyGoingAway
   */
  proxyGoingAway?:
    | replit$goval$api$ProxyGoingAway
    | replit$goval$api$IProxyGoingAway
    | null,

  /**
   * Command hint
   */
  hint?: replit$goval$api$Hint | replit$goval$api$IHint | null,

  /**
   * Command connect
   */
  connect?: replit$goval$api$Connect | replit$goval$api$IConnect | null,

  /**
   * Command send
   */
  send?: replit$goval$api$Send | replit$goval$api$ISend | null,

  /**
   * Command recv
   */
  recv?: replit$goval$api$Recv | replit$goval$api$IRecv | null,

  /**
   * Command disconnect
   */
  disconnect?:
    | replit$goval$api$Disconnect
    | replit$goval$api$IDisconnect
    | null,

  /**
   * Command fileAuthReq
   */
  fileAuthReq?:
    | replit$goval$api$FileAuthReq
    | replit$goval$api$IFileAuthReq
    | null,

  /**
   * Command fileAuthRes
   */
  fileAuthRes?:
    | replit$goval$api$FileAuthRes
    | replit$goval$api$IFileAuthRes
    | null,

  /**
   * Command mutliFileAuthRes
   */
  mutliFileAuthRes?:
    | replit$goval$api$MultiFileAuthRes
    | replit$goval$api$IMultiFileAuthRes
    | null,

  /**
   * Command listObjects
   */
  listObjects?:
    | replit$goval$api$ListObjects
    | replit$goval$api$IListObjects
    | null,

  /**
   * Command listObjectsResp
   */
  listObjectsResp?:
    | replit$goval$api$ListObjectsResp
    | replit$goval$api$IListObjectsResp
    | null,

  /**
   * Command ot
   */
  ot?: replit$goval$api$OTPacket | replit$goval$api$IOTPacket | null,

  /**
   * Command otstatus
   */
  otstatus?: replit$goval$api$OTStatus | replit$goval$api$IOTStatus | null,

  /**
   * Command otLinkFile
   */
  otLinkFile?:
    | replit$goval$api$OTLinkFile
    | replit$goval$api$IOTLinkFile
    | null,

  /**
   * Command otLinkFileResponse
   */
  otLinkFileResponse?:
    | replit$goval$api$OTLinkFileResponse
    | replit$goval$api$IOTLinkFileResponse
    | null,

  /**
   * Command otNewCursor
   */
  otNewCursor?: replit$goval$api$OTCursor | replit$goval$api$IOTCursor | null,

  /**
   * Command otDeleteCursor
   */
  otDeleteCursor?:
    | replit$goval$api$OTCursor
    | replit$goval$api$IOTCursor
    | null,

  /**
   * Command otFetchRequest
   */
  otFetchRequest?:
    | replit$goval$api$OTFetchRequest
    | replit$goval$api$IOTFetchRequest
    | null,

  /**
   * Command otFetchResponse
   */
  otFetchResponse?:
    | replit$goval$api$OTFetchResponse
    | replit$goval$api$IOTFetchResponse
    | null,

  /**
   * Command otTransformSelectionRequest
   */
  otTransformSelectionRequest?:
    | replit$goval$api$OTTransformSelectionRequest
    | replit$goval$api$IOTTransformSelectionRequest
    | null,

  /**
   * Command otTransformSelectionResponse
   */
  otTransformSelectionResponse?:
    | replit$goval$api$OTTransformSelectionResponse
    | replit$goval$api$IOTTransformSelectionResponse
    | null,

  /**
   * Command flush
   */
  flush?: replit$goval$api$Flush | replit$goval$api$IFlush | null,

  /**
   * Command debug
   */
  debug?: replit$goval$api$Debug | replit$goval$api$IDebug | null,

  /**
   * Command startVCR
   */
  startVCR?: replit$goval$api$StartVCR | replit$goval$api$IStartVCR | null,

  /**
   * Command readVCR
   */
  readVCR?: replit$goval$api$ReadVCR | replit$goval$api$IReadVCR | null,

  /**
   * Command VCRLog
   */
  VCRLog?: replit$goval$api$VCRLog | replit$goval$api$IVCRLog | null,

  /**
   * Command auth
   */
  auth?: replit$goval$api$Auth | replit$goval$api$IAuth | null,

  /**
   * Command execInfo
   */
  execInfo?: replit$goval$api$ExecInfo | replit$goval$api$IExecInfo | null,

  /**
   * Command subscribeFile
   */
  subscribeFile?:
    | replit$goval$api$SubscribeFile
    | replit$goval$api$ISubscribeFile
    | null,

  /**
   * Command fileEvent
   */
  fileEvent?: replit$goval$api$FileEvent | replit$goval$api$IFileEvent | null,

  /**
   * Command roster
   */
  roster?: replit$goval$api$Roster | replit$goval$api$IRoster | null,

  /**
   * Command join
   */
  join?: replit$goval$api$User | replit$goval$api$IUser | null,

  /**
   * Command part
   */
  part?: replit$goval$api$User | replit$goval$api$IUser | null,

  /**
   * Command openFile
   */
  openFile?: replit$goval$api$OpenFile | replit$goval$api$IOpenFile | null,

  /**
   * Command fileOpened
   */
  fileOpened?:
    | replit$goval$api$FileOpened
    | replit$goval$api$IFileOpened
    | null,

  /**
   * Command followUser
   */
  followUser?:
    | replit$goval$api$FollowUser
    | replit$goval$api$IFollowUser
    | null,

  /**
   * Command unfollowUser
   */
  unfollowUser?:
    | replit$goval$api$UnfollowUser
    | replit$goval$api$IUnfollowUser
    | null,

  /**
   * Command updateSessionTimestamp
   */
  updateSessionTimestamp?:
    | replit$goval$api$UpdateSessionTimestamp
    | replit$goval$api$IUpdateSessionTimestamp
    | null,

  /**
   * Command sessionTimestampUpdated
   */
  sessionTimestampUpdated?:
    | replit$goval$api$SessionTimestampUpdated
    | replit$goval$api$ISessionTimestampUpdated
    | null,

  /**
   * Command exec
   */
  exec?: replit$goval$api$Exec | replit$goval$api$IExec | null,

  /**
   * Command packageSearch
   */
  packageSearch?:
    | replit$goval$api$PackageSearch
    | replit$goval$api$IPackageSearch
    | null,

  /**
   * Command packageSearchResp
   */
  packageSearchResp?:
    | replit$goval$api$PackageSearchResp
    | replit$goval$api$IPackageSearchResp
    | null,

  /**
   * Command packageInfo
   */
  packageInfo?:
    | replit$goval$api$PackageInfo
    | replit$goval$api$IPackageInfo
    | null,

  /**
   * Command packageInfoResp
   */
  packageInfoResp?:
    | replit$goval$api$PackageInfoResp
    | replit$goval$api$IPackageInfoResp
    | null,

  /**
   * Command packageAdd
   */
  packageAdd?:
    | replit$goval$api$PackageAdd
    | replit$goval$api$IPackageAdd
    | null,

  /**
   * Command packageRemove
   */
  packageRemove?:
    | replit$goval$api$PackageRemove
    | replit$goval$api$IPackageRemove
    | null,

  /**
   * Command packageInstall
   */
  packageInstall?:
    | replit$goval$api$PackageInstall
    | replit$goval$api$IPackageInstall
    | null,

  /**
   * Command packageListSpecfile
   */
  packageListSpecfile?:
    | replit$goval$api$PackageListSpecfile
    | replit$goval$api$IPackageListSpecfile
    | null,

  /**
   * Command packageListSpecfileResp
   */
  packageListSpecfileResp?:
    | replit$goval$api$PackageListSpecfileResp
    | replit$goval$api$IPackageListSpecfileResp
    | null,

  /**
   * Command packageCacheSave
   */
  packageCacheSave?:
    | replit$goval$api$PackageCacheSave
    | replit$goval$api$IPackageCacheSave
    | null,

  /**
   * Command chatMessage
   */
  chatMessage?:
    | replit$goval$api$ChatMessage
    | replit$goval$api$IChatMessage
    | null,

  /**
   * Command chatTyping
   */
  chatTyping?:
    | replit$goval$api$ChatTyping
    | replit$goval$api$IChatTyping
    | null,

  /**
   * Command chatScrollback
   */
  chatScrollback?:
    | replit$goval$api$ChatScrollback
    | replit$goval$api$IChatScrollback
    | null,

  /**
   * Command fsSnapshot
   */
  fsSnapshot?:
    | replit$goval$api$FSSnapshot
    | replit$goval$api$IFSSnapshot
    | null,

  /**
   * Command fsSnapshotEvent
   */
  fsSnapshotEvent?:
    | replit$goval$api$FSSnapshotEvent
    | replit$goval$api$IFSSnapshotEvent
    | null,

  /**
   * Command fsTakeLock
   */
  fsTakeLock?: replit$goval$api$FSLock | replit$goval$api$IFSLock | null,

  /**
   * Command fsReleaseLock
   */
  fsReleaseLock?: replit$goval$api$FSLock | replit$goval$api$IFSLock | null,

  /**
   * Command hasCap
   */
  hasCap?: boolean | null,

  /**
   * Command snapshotEvent
   */
  snapshotEvent?:
    | replit$goval$api$SnapshotEvent
    | replit$goval$api$ISnapshotEvent
    | null,

  /**
   * Command NoninteractiveFSChangeEvent
   */
  NoninteractiveFSChangeEvent?: boolean | null,

  /**
   * Command pid1Config
   */
  pid1Config?:
    | replit$goval$api$Pid1Config
    | replit$goval$api$IPid1Config
    | null,

  /**
   * Command metrics
   */
  metrics?: replit$goval$api$Metrics | replit$goval$api$IMetrics | null,

  /**
   * Command bootStatus
   */
  bootStatus?:
    | replit$goval$api$BootStatus
    | replit$goval$api$IBootStatus
    | null,

  /**
   * Command readMetaRequest
   */
  readMetaRequest?:
    | replit$goval$api$ReadMetaRequest
    | replit$goval$api$IReadMetaRequest
    | null,

  /**
   * Command readMetaResponse
   */
  readMetaResponse?:
    | replit$goval$api$ReadMetaResponse
    | replit$goval$api$IReadMetaResponse
    | null,

  /**
   * Command writeMetaRequest
   */
  writeMetaRequest?:
    | replit$goval$api$WriteMetaRequest
    | replit$goval$api$IWriteMetaRequest
    | null,

  /**
   * Command writeMetaResponse
   */
  writeMetaResponse?:
    | replit$goval$api$WriteMetaResponse
    | replit$goval$api$IWriteMetaResponse
    | null,

  /**
   * Command appendMetaRequest
   */
  appendMetaRequest?:
    | replit$goval$api$AppendMetaRequest
    | replit$goval$api$IAppendMetaRequest
    | null,

  /**
   * Command appendMetaResponse
   */
  appendMetaResponse?:
    | replit$goval$api$AppendMetaResponse
    | replit$goval$api$IAppendMetaResponse
    | null,

  /**
   * Command audio
   */
  audio?: replit$goval$api$Audio | replit$goval$api$IAudio | null,

  /**
   * Command pprofRequest
   */
  pprofRequest?:
    | replit$goval$api$PprofRequest
    | replit$goval$api$IPprofRequest
    | null,

  /**
   * Command pprofResponse
   */
  pprofResponse?:
    | replit$goval$api$PprofResponse
    | replit$goval$api$IPprofResponse
    | null,

  /**
   * Command audio2
   */
  audio2?: replit$goval$api$Audio2 | replit$goval$api$IAudio2 | null,

  /**
   * Command PTYConfig
   */
  PTYConfig?: replit$goval$api$PTYConfig | replit$goval$api$IPTYConfig | null,

  /**
   * Command debugMain
   */
  debugMain?: replit$goval$api$DebugMain | replit$goval$api$IDebugMain | null,

  /**
   * Command debugState
   */
  debugState?:
    | replit$goval$api$DebugState
    | replit$goval$api$IDebugState
    | null,

  /**
   * Command debugMainReply
   */
  debugMainReply?:
    | replit$goval$api$DebugMainReply
    | replit$goval$api$IDebugMainReply
    | null,

  /**
   * Command debugInput
   */
  debugInput?:
    | replit$goval$api$DebugInput
    | replit$goval$api$IDebugInput
    | null,

  /**
   * Command debugOutput
   */
  debugOutput?:
    | replit$goval$api$DebugOutput
    | replit$goval$api$IDebugOutput
    | null,

  /**
   * Command debugStop
   */
  debugStop?: replit$goval$api$DebugStop | replit$goval$api$IDebugStop | null,

  /**
   * Command debugLeave
   */
  debugLeave?:
    | replit$goval$api$DebugLeave
    | replit$goval$api$IDebugLeave
    | null,

  /**
   * Command debugSessions
   */
  debugSessions?:
    | replit$goval$api$DebugSessions
    | replit$goval$api$IDebugSessions
    | null,

  /**
   * Command debugAddBreakpointRequest
   */
  debugAddBreakpointRequest?:
    | replit$goval$api$DebugAddBreakpointRequest
    | replit$goval$api$IDebugAddBreakpointRequest
    | null,

  /**
   * Command debugUpdateBreakpointRequest
   */
  debugUpdateBreakpointRequest?:
    | replit$goval$api$DebugUpdateBreakpointRequest
    | replit$goval$api$IDebugUpdateBreakpointRequest
    | null,

  /**
   * Command debugRemoveBreakpointRequest
   */
  debugRemoveBreakpointRequest?:
    | replit$goval$api$DebugRemoveBreakpointRequest
    | replit$goval$api$IDebugRemoveBreakpointRequest
    | null,

  /**
   * Command debugBreakpointEvent
   */
  debugBreakpointEvent?:
    | replit$goval$api$DebugBreakpointEvent
    | replit$goval$api$IDebugBreakpointEvent
    | null,

  /**
   * Command dotReplitGetRequest
   */
  dotReplitGetRequest?:
    | replit$goval$api$DotReplitGetRequest
    | replit$goval$api$IDotReplitGetRequest
    | null,

  /**
   * Command dotReplitGetResponse
   */
  dotReplitGetResponse?:
    | replit$goval$api$DotReplitGetResponse
    | replit$goval$api$IDotReplitGetResponse
    | null,

  /**
   * Command runConfigGetRequest
   */
  runConfigGetRequest?:
    | replit$goval$api$RunConfigGetRequest
    | replit$goval$api$IRunConfigGetRequest
    | null,

  /**
   * Command runConfigGetResponse
   */
  runConfigGetResponse?:
    | replit$goval$api$RunConfigGetResponse
    | replit$goval$api$IRunConfigGetResponse
    | null,

  /**
   * Command dotReplitUpdateRequest
   */
  dotReplitUpdateRequest?:
    | replit$goval$api$DotReplitUpdateRequest
    | replit$goval$api$IDotReplitUpdateRequest
    | null,

  /**
   * Command dotReplitUpdateResponse
   */
  dotReplitUpdateResponse?:
    | replit$goval$api$DotReplitUpdateResponse
    | replit$goval$api$IDotReplitUpdateResponse
    | null,

  /**
   * Command startLSP
   */
  startLSP?: replit$goval$api$StartLSP | replit$goval$api$IStartLSP | null,

  /**
   * Command firewallDenied
   */
  firewallDenied?:
    | replit$goval$api$FirewallDenied
    | replit$goval$api$IFirewallDenied
    | null,

  /**
   * Command nixPackageAddRequest
   */
  nixPackageAddRequest?:
    | replit$goval$api$NixPackageAddRequest
    | replit$goval$api$INixPackageAddRequest
    | null,

  /**
   * Command nixPackageAddResponse
   */
  nixPackageAddResponse?:
    | replit$goval$api$NixPackageAddResponse
    | replit$goval$api$INixPackageAddResponse
    | null,

  /**
   * Command nixPackageRemoveRequest
   */
  nixPackageRemoveRequest?:
    | replit$goval$api$NixPackageRemoveRequest
    | replit$goval$api$INixPackageRemoveRequest
    | null,

  /**
   * Command nixPackageRemoveResponse
   */
  nixPackageRemoveResponse?:
    | replit$goval$api$NixPackageRemoveResponse
    | replit$goval$api$INixPackageRemoveResponse
    | null,

  /**
   * Command nixPackageListRequest
   */
  nixPackageListRequest?:
    | replit$goval$api$NixPackageListRequest
    | replit$goval$api$INixPackageListRequest
    | null,

  /**
   * Command nixPackageListResponse
   */
  nixPackageListResponse?:
    | replit$goval$api$NixPackageListResponse
    | replit$goval$api$INixPackageListResponse
    | null,

  /**
   * Command nixChannelsRequest
   */
  nixChannelsRequest?:
    | replit$goval$api$NixChannelsRequest
    | replit$goval$api$INixChannelsRequest
    | null,

  /**
   * Command nixChannelsResponse
   */
  nixChannelsResponse?:
    | replit$goval$api$NixChannelsResponse
    | replit$goval$api$INixChannelsResponse
    | null,

  /**
   * Command nixChannelLatestStableRequest
   */
  nixChannelLatestStableRequest?:
    | replit$goval$api$NixChannelLatestStableRequest
    | replit$goval$api$INixChannelLatestStableRequest
    | null,

  /**
   * Command nixChannelLatestStableResponse
   */
  nixChannelLatestStableResponse?:
    | replit$goval$api$NixChannelLatestStableResponse
    | replit$goval$api$INixChannelLatestStableResponse
    | null,

  /**
   * Command nixPackageSearchRequest
   */
  nixPackageSearchRequest?:
    | replit$goval$api$NixPackageSearchRequest
    | replit$goval$api$INixPackageSearchRequest
    | null,

  /**
   * Command nixPackageSearchResponse
   */
  nixPackageSearchResponse?:
    | replit$goval$api$NixPackageSearchResponse
    | replit$goval$api$INixPackageSearchResponse
    | null,

  /**
   * Command userEvent
   */
  userEvent?: replit$goval$api$UserEvent | replit$goval$api$IUserEvent | null,

  /**
   * Command replspaceApiOpenFile
   */
  replspaceApiOpenFile?:
    | replit$goval$api$ReplspaceApiOpenFile
    | replit$goval$api$IReplspaceApiOpenFile
    | null,

  /**
   * Command replspaceApiCloseFile
   */
  replspaceApiCloseFile?:
    | replit$goval$api$ReplspaceApiCloseFile
    | replit$goval$api$IReplspaceApiCloseFile
    | null,

  /**
   * Command replspaceApiGetGitHubToken
   */
  replspaceApiGetGitHubToken?:
    | replit$goval$api$ReplspaceApiGetGitHubToken
    | replit$goval$api$IReplspaceApiGetGitHubToken
    | null,

  /**
   * Command replspaceApiGitHubToken
   */
  replspaceApiGitHubToken?:
    | replit$goval$api$ReplspaceApiGitHubToken
    | replit$goval$api$IReplspaceApiGitHubToken
    | null,

  /**
   * Command ref
   */
  ref?: string | null,

  /**
   * Command traceInfo
   */
  traceInfo?: {|
    [k: string]: string,
  |} | null,
|};

/**
 * Represents a Command.
 */
declare class replit$goval$api$Command {
  /**
   * Constructs a new Command.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ICommand): this;

  /**
   * Command channel.
   */
  channel: number;

  /**
   * Command session.
   */
  session: number;

  /**
   * Command openChan.
   */
  openChan?: replit$goval$api$OpenChannel | null;

  /**
   * Command openChanRes.
   */
  openChanRes?: replit$goval$api$OpenChannelRes | null;

  /**
   * Command closeChan.
   */
  closeChan?: replit$goval$api$CloseChannel | null;

  /**
   * Command closeChanRes.
   */
  closeChanRes?: replit$goval$api$CloseChannelRes | null;

  /**
   * Command containerState.
   */
  containerState?: replit$goval$api$ContainerState | null;

  /**
   * Command portOpen.
   */
  portOpen?: replit$goval$api$PortOpen | null;

  /**
   * Command portClose.
   */
  portClose?: replit$goval$api$PortClose | null;

  /**
   * Command toast.
   */
  toast?: replit$goval$api$Toast | null;

  /**
   * Command protocolError.
   */
  protocolError?: replit$goval$api$ProtocolError | null;

  /**
   * Command redirect.
   */
  redirect?: replit$goval$api$Redirect | null;

  /**
   * Command alwaysOn.
   */
  alwaysOn?: replit$goval$api$AlwaysOn | null;

  /**
   * Command runMain.
   */
  runMain?: replit$goval$api$RunMain | null;

  /**
   * Command clear.
   */
  clear?: replit$goval$api$Clear | null;

  /**
   * Command eval.
   */
  eval?: string | null;

  /**
   * Command result.
   */
  result?: string | null;

  /**
   * Command input.
   */
  input?: string | null;

  /**
   * Command output.
   */
  output?: string | null;

  /**
   * Command error.
   */
  error?: string | null;

  /**
   * Command stderr.
   */
  stderr?: string | null;

  /**
   * Command log.
   */
  log?: string | null;

  /**
   * Command record.
   */
  record?: string | null;

  /**
   * Command saneTerm.
   */
  saneTerm?: replit$goval$api$SaneTerm | null;

  /**
   * Command resizeTerm.
   */
  resizeTerm?: replit$goval$api$ResizeTerm | null;

  /**
   * Command state.
   */
  state?: $Values<typeof replit$goval$api$State> | null;

  /**
   * Command ok.
   */
  ok?: replit$goval$api$OK | null;

  /**
   * Command persist.
   */
  persist?: replit$goval$api$File | null;

  /**
   * Command persistMirror.
   */
  persistMirror?: replit$goval$api$File | null;

  /**
   * Command write.
   */
  write?: replit$goval$api$File | null;

  /**
   * Command remove.
   */
  remove?: replit$goval$api$File | null;

  /**
   * Command move.
   */
  move?: replit$goval$api$Move | null;

  /**
   * Command tryRemove.
   */
  tryRemove?: replit$goval$api$File | null;

  /**
   * Command mkdir.
   */
  mkdir?: replit$goval$api$File | null;

  /**
   * Command stat.
   */
  stat?: replit$goval$api$File | null;

  /**
   * Command statRes.
   */
  statRes?: replit$goval$api$StatResult | null;

  /**
   * Command transferStart.
   */
  transferStart?: replit$goval$api$TransferStart | null;

  /**
   * Command transferChunk.
   */
  transferChunk?: replit$goval$api$TransferChunk | null;

  /**
   * Command transferComplete.
   */
  transferComplete?: replit$goval$api$TransferComplete | null;

  /**
   * Command transferCancel.
   */
  transferCancel?: replit$goval$api$Transfer | null;

  /**
   * Command transfer.
   */
  transfer?: replit$goval$api$Transfer | null;

  /**
   * Command read.
   */
  read?: replit$goval$api$File | null;

  /**
   * Command readdir.
   */
  readdir?: replit$goval$api$File | null;

  /**
   * Command files.
   */
  files?: replit$goval$api$Files | null;

  /**
   * Command file.
   */
  file?: replit$goval$api$File | null;

  /**
   * Command checkChanges.
   */
  checkChanges?: replit$goval$api$CheckChanges | null;

  /**
   * Command changedFiles.
   */
  changedFiles?: replit$goval$api$Files | null;

  /**
   * Command lintResults.
   */
  lintResults?: replit$goval$api$LintResults | null;

  /**
   * Command runContainedTest.
   */
  runContainedTest?: replit$goval$api$ContainedTest | null;

  /**
   * Command testResult.
   */
  testResult?: replit$goval$api$TestResult | null;

  /**
   * Command debuggerStart.
   */
  debuggerStart?: string | null;

  /**
   * Command debuggerStep.
   */
  debuggerStep?: replit$goval$api$RunMain | null;

  /**
   * Command debuggerStatus.
   */
  debuggerStatus?: replit$goval$api$DebugStatus | null;

  /**
   * Command ensurePackages.
   */
  ensurePackages?: replit$goval$api$EnsurePackages | null;

  /**
   * Command ping.
   */
  ping?: replit$goval$api$Ping | null;

  /**
   * Command pong.
   */
  pong?: replit$goval$api$Pong | null;

  /**
   * Command hello.
   */
  hello?: replit$goval$api$Hello | null;

  /**
   * Command goodbye.
   */
  goodbye?: replit$goval$api$Goodbye | null;

  /**
   * Command proxyGoingAway.
   */
  proxyGoingAway?: replit$goval$api$ProxyGoingAway | null;

  /**
   * Command hint.
   */
  hint?: replit$goval$api$Hint | null;

  /**
   * Command connect.
   */
  connect?: replit$goval$api$Connect | null;

  /**
   * Command send.
   */
  send?: replit$goval$api$Send | null;

  /**
   * Command recv.
   */
  recv?: replit$goval$api$Recv | null;

  /**
   * Command disconnect.
   */
  disconnect?: replit$goval$api$Disconnect | null;

  /**
   * Command fileAuthReq.
   */
  fileAuthReq?: replit$goval$api$FileAuthReq | null;

  /**
   * Command fileAuthRes.
   */
  fileAuthRes?: replit$goval$api$FileAuthRes | null;

  /**
   * Command mutliFileAuthRes.
   */
  mutliFileAuthRes?: replit$goval$api$MultiFileAuthRes | null;

  /**
   * Command listObjects.
   */
  listObjects?: replit$goval$api$ListObjects | null;

  /**
   * Command listObjectsResp.
   */
  listObjectsResp?: replit$goval$api$ListObjectsResp | null;

  /**
   * Command ot.
   */
  ot?: replit$goval$api$OTPacket | null;

  /**
   * Command otstatus.
   */
  otstatus?: replit$goval$api$OTStatus | null;

  /**
   * Command otLinkFile.
   */
  otLinkFile?: replit$goval$api$OTLinkFile | null;

  /**
   * Command otLinkFileResponse.
   */
  otLinkFileResponse?: replit$goval$api$OTLinkFileResponse | null;

  /**
   * Command otNewCursor.
   */
  otNewCursor?: replit$goval$api$OTCursor | null;

  /**
   * Command otDeleteCursor.
   */
  otDeleteCursor?: replit$goval$api$OTCursor | null;

  /**
   * Command otFetchRequest.
   */
  otFetchRequest?: replit$goval$api$OTFetchRequest | null;

  /**
   * Command otFetchResponse.
   */
  otFetchResponse?: replit$goval$api$OTFetchResponse | null;

  /**
   * Command otTransformSelectionRequest.
   */
  otTransformSelectionRequest?: replit$goval$api$OTTransformSelectionRequest | null;

  /**
   * Command otTransformSelectionResponse.
   */
  otTransformSelectionResponse?: replit$goval$api$OTTransformSelectionResponse | null;

  /**
   * Command flush.
   */
  flush?: replit$goval$api$Flush | null;

  /**
   * Command debug.
   */
  debug?: replit$goval$api$Debug | null;

  /**
   * Command startVCR.
   */
  startVCR?: replit$goval$api$StartVCR | null;

  /**
   * Command readVCR.
   */
  readVCR?: replit$goval$api$ReadVCR | null;

  /**
   * Command VCRLog.
   */
  VCRLog?: replit$goval$api$VCRLog | null;

  /**
   * Command auth.
   */
  auth?: replit$goval$api$Auth | null;

  /**
   * Command execInfo.
   */
  execInfo?: replit$goval$api$ExecInfo | null;

  /**
   * Command subscribeFile.
   */
  subscribeFile?: replit$goval$api$SubscribeFile | null;

  /**
   * Command fileEvent.
   */
  fileEvent?: replit$goval$api$FileEvent | null;

  /**
   * Command roster.
   */
  roster?: replit$goval$api$Roster | null;

  /**
   * Command join.
   */
  join?: replit$goval$api$User | null;

  /**
   * Command part.
   */
  part?: replit$goval$api$User | null;

  /**
   * Command openFile.
   */
  openFile?: replit$goval$api$OpenFile | null;

  /**
   * Command fileOpened.
   */
  fileOpened?: replit$goval$api$FileOpened | null;

  /**
   * Command followUser.
   */
  followUser?: replit$goval$api$FollowUser | null;

  /**
   * Command unfollowUser.
   */
  unfollowUser?: replit$goval$api$UnfollowUser | null;

  /**
   * Command updateSessionTimestamp.
   */
  updateSessionTimestamp?: replit$goval$api$UpdateSessionTimestamp | null;

  /**
   * Command sessionTimestampUpdated.
   */
  sessionTimestampUpdated?: replit$goval$api$SessionTimestampUpdated | null;

  /**
   * Command exec.
   */
  exec?: replit$goval$api$Exec | null;

  /**
   * Command packageSearch.
   */
  packageSearch?: replit$goval$api$PackageSearch | null;

  /**
   * Command packageSearchResp.
   */
  packageSearchResp?: replit$goval$api$PackageSearchResp | null;

  /**
   * Command packageInfo.
   */
  packageInfo?: replit$goval$api$PackageInfo | null;

  /**
   * Command packageInfoResp.
   */
  packageInfoResp?: replit$goval$api$PackageInfoResp | null;

  /**
   * Command packageAdd.
   */
  packageAdd?: replit$goval$api$PackageAdd | null;

  /**
   * Command packageRemove.
   */
  packageRemove?: replit$goval$api$PackageRemove | null;

  /**
   * Command packageInstall.
   */
  packageInstall?: replit$goval$api$PackageInstall | null;

  /**
   * Command packageListSpecfile.
   */
  packageListSpecfile?: replit$goval$api$PackageListSpecfile | null;

  /**
   * Command packageListSpecfileResp.
   */
  packageListSpecfileResp?: replit$goval$api$PackageListSpecfileResp | null;

  /**
   * Command packageCacheSave.
   */
  packageCacheSave?: replit$goval$api$PackageCacheSave | null;

  /**
   * Command chatMessage.
   */
  chatMessage?: replit$goval$api$ChatMessage | null;

  /**
   * Command chatTyping.
   */
  chatTyping?: replit$goval$api$ChatTyping | null;

  /**
   * Command chatScrollback.
   */
  chatScrollback?: replit$goval$api$ChatScrollback | null;

  /**
   * Command fsSnapshot.
   */
  fsSnapshot?: replit$goval$api$FSSnapshot | null;

  /**
   * Command fsSnapshotEvent.
   */
  fsSnapshotEvent?: replit$goval$api$FSSnapshotEvent | null;

  /**
   * Command fsTakeLock.
   */
  fsTakeLock?: replit$goval$api$FSLock | null;

  /**
   * Command fsReleaseLock.
   */
  fsReleaseLock?: replit$goval$api$FSLock | null;

  /**
   * Command hasCap.
   */
  hasCap?: boolean | null;

  /**
   * Command snapshotEvent.
   */
  snapshotEvent?: replit$goval$api$SnapshotEvent | null;

  /**
   * Command NoninteractiveFSChangeEvent.
   */
  NoninteractiveFSChangeEvent?: boolean | null;

  /**
   * Command pid1Config.
   */
  pid1Config?: replit$goval$api$Pid1Config | null;

  /**
   * Command metrics.
   */
  metrics?: replit$goval$api$Metrics | null;

  /**
   * Command bootStatus.
   */
  bootStatus?: replit$goval$api$BootStatus | null;

  /**
   * Command readMetaRequest.
   */
  readMetaRequest?: replit$goval$api$ReadMetaRequest | null;

  /**
   * Command readMetaResponse.
   */
  readMetaResponse?: replit$goval$api$ReadMetaResponse | null;

  /**
   * Command writeMetaRequest.
   */
  writeMetaRequest?: replit$goval$api$WriteMetaRequest | null;

  /**
   * Command writeMetaResponse.
   */
  writeMetaResponse?: replit$goval$api$WriteMetaResponse | null;

  /**
   * Command appendMetaRequest.
   */
  appendMetaRequest?: replit$goval$api$AppendMetaRequest | null;

  /**
   * Command appendMetaResponse.
   */
  appendMetaResponse?: replit$goval$api$AppendMetaResponse | null;

  /**
   * Command audio.
   */
  audio?: replit$goval$api$Audio | null;

  /**
   * Command pprofRequest.
   */
  pprofRequest?: replit$goval$api$PprofRequest | null;

  /**
   * Command pprofResponse.
   */
  pprofResponse?: replit$goval$api$PprofResponse | null;

  /**
   * Command audio2.
   */
  audio2?: replit$goval$api$Audio2 | null;

  /**
   * Command PTYConfig.
   */
  PTYConfig?: replit$goval$api$PTYConfig | null;

  /**
   * Command debugMain.
   */
  debugMain?: replit$goval$api$DebugMain | null;

  /**
   * Command debugState.
   */
  debugState?: replit$goval$api$DebugState | null;

  /**
   * Command debugMainReply.
   */
  debugMainReply?: replit$goval$api$DebugMainReply | null;

  /**
   * Command debugInput.
   */
  debugInput?: replit$goval$api$DebugInput | null;

  /**
   * Command debugOutput.
   */
  debugOutput?: replit$goval$api$DebugOutput | null;

  /**
   * Command debugStop.
   */
  debugStop?: replit$goval$api$DebugStop | null;

  /**
   * Command debugLeave.
   */
  debugLeave?: replit$goval$api$DebugLeave | null;

  /**
   * Command debugSessions.
   */
  debugSessions?: replit$goval$api$DebugSessions | null;

  /**
   * Command debugAddBreakpointRequest.
   */
  debugAddBreakpointRequest?: replit$goval$api$DebugAddBreakpointRequest | null;

  /**
   * Command debugUpdateBreakpointRequest.
   */
  debugUpdateBreakpointRequest?: replit$goval$api$DebugUpdateBreakpointRequest | null;

  /**
   * Command debugRemoveBreakpointRequest.
   */
  debugRemoveBreakpointRequest?: replit$goval$api$DebugRemoveBreakpointRequest | null;

  /**
   * Command debugBreakpointEvent.
   */
  debugBreakpointEvent?: replit$goval$api$DebugBreakpointEvent | null;

  /**
   * Command dotReplitGetRequest.
   */
  dotReplitGetRequest?: replit$goval$api$DotReplitGetRequest | null;

  /**
   * Command dotReplitGetResponse.
   */
  dotReplitGetResponse?: replit$goval$api$DotReplitGetResponse | null;

  /**
   * Command runConfigGetRequest.
   */
  runConfigGetRequest?: replit$goval$api$RunConfigGetRequest | null;

  /**
   * Command runConfigGetResponse.
   */
  runConfigGetResponse?: replit$goval$api$RunConfigGetResponse | null;

  /**
   * Command dotReplitUpdateRequest.
   */
  dotReplitUpdateRequest?: replit$goval$api$DotReplitUpdateRequest | null;

  /**
   * Command dotReplitUpdateResponse.
   */
  dotReplitUpdateResponse?: replit$goval$api$DotReplitUpdateResponse | null;

  /**
   * Command startLSP.
   */
  startLSP?: replit$goval$api$StartLSP | null;

  /**
   * Command firewallDenied.
   */
  firewallDenied?: replit$goval$api$FirewallDenied | null;

  /**
   * Command nixPackageAddRequest.
   */
  nixPackageAddRequest?: replit$goval$api$NixPackageAddRequest | null;

  /**
   * Command nixPackageAddResponse.
   */
  nixPackageAddResponse?: replit$goval$api$NixPackageAddResponse | null;

  /**
   * Command nixPackageRemoveRequest.
   */
  nixPackageRemoveRequest?: replit$goval$api$NixPackageRemoveRequest | null;

  /**
   * Command nixPackageRemoveResponse.
   */
  nixPackageRemoveResponse?: replit$goval$api$NixPackageRemoveResponse | null;

  /**
   * Command nixPackageListRequest.
   */
  nixPackageListRequest?: replit$goval$api$NixPackageListRequest | null;

  /**
   * Command nixPackageListResponse.
   */
  nixPackageListResponse?: replit$goval$api$NixPackageListResponse | null;

  /**
   * Command nixChannelsRequest.
   */
  nixChannelsRequest?: replit$goval$api$NixChannelsRequest | null;

  /**
   * Command nixChannelsResponse.
   */
  nixChannelsResponse?: replit$goval$api$NixChannelsResponse | null;

  /**
   * Command nixChannelLatestStableRequest.
   */
  nixChannelLatestStableRequest?: replit$goval$api$NixChannelLatestStableRequest | null;

  /**
   * Command nixChannelLatestStableResponse.
   */
  nixChannelLatestStableResponse?: replit$goval$api$NixChannelLatestStableResponse | null;

  /**
   * Command nixPackageSearchRequest.
   */
  nixPackageSearchRequest?: replit$goval$api$NixPackageSearchRequest | null;

  /**
   * Command nixPackageSearchResponse.
   */
  nixPackageSearchResponse?: replit$goval$api$NixPackageSearchResponse | null;

  /**
   * Command userEvent.
   */
  userEvent?: replit$goval$api$UserEvent | null;

  /**
   * Command replspaceApiOpenFile.
   */
  replspaceApiOpenFile?: replit$goval$api$ReplspaceApiOpenFile | null;

  /**
   * Command replspaceApiCloseFile.
   */
  replspaceApiCloseFile?: replit$goval$api$ReplspaceApiCloseFile | null;

  /**
   * Command replspaceApiGetGitHubToken.
   */
  replspaceApiGetGitHubToken?: replit$goval$api$ReplspaceApiGetGitHubToken | null;

  /**
   * Command replspaceApiGitHubToken.
   */
  replspaceApiGitHubToken?: replit$goval$api$ReplspaceApiGitHubToken | null;

  /**
   * Command ref.
   */
  ref: string;

  /**
   * Command traceInfo.
   */
  traceInfo: {|
    [k: string]: string,
  |};

  /**
   * Command body.
   */
  body?:
    | "openChan"
    | "openChanRes"
    | "closeChan"
    | "closeChanRes"
    | "containerState"
    | "portOpen"
    | "portClose"
    | "toast"
    | "protocolError"
    | "redirect"
    | "alwaysOn"
    | "runMain"
    | "clear"
    | "eval"
    | "result"
    | "input"
    | "output"
    | "error"
    | "stderr"
    | "log"
    | "record"
    | "saneTerm"
    | "resizeTerm"
    | "state"
    | "ok"
    | "persist"
    | "persistMirror"
    | "write"
    | "remove"
    | "move"
    | "tryRemove"
    | "mkdir"
    | "stat"
    | "statRes"
    | "transferStart"
    | "transferChunk"
    | "transferComplete"
    | "transferCancel"
    | "transfer"
    | "read"
    | "readdir"
    | "files"
    | "file"
    | "checkChanges"
    | "changedFiles"
    | "lintResults"
    | "runContainedTest"
    | "testResult"
    | "debuggerStart"
    | "debuggerStep"
    | "debuggerStatus"
    | "ensurePackages"
    | "ping"
    | "pong"
    | "hello"
    | "goodbye"
    | "proxyGoingAway"
    | "hint"
    | "connect"
    | "send"
    | "recv"
    | "disconnect"
    | "fileAuthReq"
    | "fileAuthRes"
    | "mutliFileAuthRes"
    | "listObjects"
    | "listObjectsResp"
    | "ot"
    | "otstatus"
    | "otLinkFile"
    | "otLinkFileResponse"
    | "otNewCursor"
    | "otDeleteCursor"
    | "otFetchRequest"
    | "otFetchResponse"
    | "otTransformSelectionRequest"
    | "otTransformSelectionResponse"
    | "flush"
    | "debug"
    | "startVCR"
    | "readVCR"
    | "VCRLog"
    | "auth"
    | "execInfo"
    | "subscribeFile"
    | "fileEvent"
    | "roster"
    | "join"
    | "part"
    | "openFile"
    | "fileOpened"
    | "followUser"
    | "unfollowUser"
    | "updateSessionTimestamp"
    | "sessionTimestampUpdated"
    | "exec"
    | "packageSearch"
    | "packageSearchResp"
    | "packageInfo"
    | "packageInfoResp"
    | "packageAdd"
    | "packageRemove"
    | "packageInstall"
    | "packageListSpecfile"
    | "packageListSpecfileResp"
    | "packageCacheSave"
    | "chatMessage"
    | "chatTyping"
    | "chatScrollback"
    | "fsSnapshot"
    | "fsSnapshotEvent"
    | "fsTakeLock"
    | "fsReleaseLock"
    | "hasCap"
    | "snapshotEvent"
    | "NoninteractiveFSChangeEvent"
    | "pid1Config"
    | "metrics"
    | "bootStatus"
    | "readMetaRequest"
    | "readMetaResponse"
    | "writeMetaRequest"
    | "writeMetaResponse"
    | "appendMetaRequest"
    | "appendMetaResponse"
    | "audio"
    | "pprofRequest"
    | "pprofResponse"
    | "audio2"
    | "PTYConfig"
    | "debugMain"
    | "debugState"
    | "debugMainReply"
    | "debugInput"
    | "debugOutput"
    | "debugStop"
    | "debugLeave"
    | "debugSessions"
    | "debugAddBreakpointRequest"
    | "debugUpdateBreakpointRequest"
    | "debugRemoveBreakpointRequest"
    | "debugBreakpointEvent"
    | "dotReplitGetRequest"
    | "dotReplitGetResponse"
    | "runConfigGetRequest"
    | "runConfigGetResponse"
    | "dotReplitUpdateRequest"
    | "dotReplitUpdateResponse"
    | "startLSP"
    | "firewallDenied"
    | "nixPackageAddRequest"
    | "nixPackageAddResponse"
    | "nixPackageRemoveRequest"
    | "nixPackageRemoveResponse"
    | "nixPackageListRequest"
    | "nixPackageListResponse"
    | "nixChannelsRequest"
    | "nixChannelsResponse"
    | "nixChannelLatestStableRequest"
    | "nixChannelLatestStableResponse"
    | "nixPackageSearchRequest"
    | "nixPackageSearchResponse"
    | "userEvent"
    | "replspaceApiOpenFile"
    | "replspaceApiCloseFile"
    | "replspaceApiGetGitHubToken"
    | "replspaceApiGitHubToken";

  /**
   * Creates a new Command instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Command instance
   */
  static create(
    properties?: replit$goval$api$ICommand
  ): replit$goval$api$Command;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Command message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Command,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Command message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Command,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Command message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Command
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Command;

  /**
   * Decodes a Command message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Command
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Command;

  /**
   * Verifies a Command message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Command message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Command
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Command;

  /**
   * Creates a plain object from a Command message. Also converts values to other types if specified.
   * @param message Command
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Command,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Command to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a NixPackageAddRequest.
 */
declare type replit$goval$api$INixPackageAddRequest = {|
  /**
   * NixPackageAddRequest packages
   */
  packages?: string[] | null,
|};

/**
 * Represents a NixPackageAddRequest.
 */
declare class replit$goval$api$NixPackageAddRequest {
  /**
   * Constructs a new NixPackageAddRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$INixPackageAddRequest): this;

  /**
   * NixPackageAddRequest packages.
   */
  packages: string[];

  /**
   * Creates a new NixPackageAddRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns NixPackageAddRequest instance
   */
  static create(
    properties?: replit$goval$api$INixPackageAddRequest
  ): replit$goval$api$NixPackageAddRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageAddRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$NixPackageAddRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageAddRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$NixPackageAddRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a NixPackageAddRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns NixPackageAddRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$NixPackageAddRequest;

  /**
   * Decodes a NixPackageAddRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns NixPackageAddRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$NixPackageAddRequest;

  /**
   * Verifies a NixPackageAddRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a NixPackageAddRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns NixPackageAddRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$NixPackageAddRequest;

  /**
   * Creates a plain object from a NixPackageAddRequest message. Also converts values to other types if specified.
   * @param message NixPackageAddRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$NixPackageAddRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this NixPackageAddRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a NixPackageAddResponse.
 */
declare type replit$goval$api$INixPackageAddResponse = {||};

/**
 * Represents a NixPackageAddResponse.
 */
declare class replit$goval$api$NixPackageAddResponse {
  /**
   * Constructs a new NixPackageAddResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$INixPackageAddResponse): this;

  /**
   * Creates a new NixPackageAddResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns NixPackageAddResponse instance
   */
  static create(
    properties?: replit$goval$api$INixPackageAddResponse
  ): replit$goval$api$NixPackageAddResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageAddResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$NixPackageAddResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageAddResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$NixPackageAddResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a NixPackageAddResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns NixPackageAddResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$NixPackageAddResponse;

  /**
   * Decodes a NixPackageAddResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns NixPackageAddResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$NixPackageAddResponse;

  /**
   * Verifies a NixPackageAddResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a NixPackageAddResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns NixPackageAddResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$NixPackageAddResponse;

  /**
   * Creates a plain object from a NixPackageAddResponse message. Also converts values to other types if specified.
   * @param message NixPackageAddResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$NixPackageAddResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this NixPackageAddResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a NixPackageRemoveRequest.
 */
declare type replit$goval$api$INixPackageRemoveRequest = {|
  /**
   * NixPackageRemoveRequest packages
   */
  packages?: string[] | null,
|};

/**
 * Represents a NixPackageRemoveRequest.
 */
declare class replit$goval$api$NixPackageRemoveRequest {
  /**
   * Constructs a new NixPackageRemoveRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$INixPackageRemoveRequest): this;

  /**
   * NixPackageRemoveRequest packages.
   */
  packages: string[];

  /**
   * Creates a new NixPackageRemoveRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns NixPackageRemoveRequest instance
   */
  static create(
    properties?: replit$goval$api$INixPackageRemoveRequest
  ): replit$goval$api$NixPackageRemoveRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageRemoveRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$NixPackageRemoveRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageRemoveRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$NixPackageRemoveRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a NixPackageRemoveRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns NixPackageRemoveRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$NixPackageRemoveRequest;

  /**
   * Decodes a NixPackageRemoveRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns NixPackageRemoveRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$NixPackageRemoveRequest;

  /**
   * Verifies a NixPackageRemoveRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a NixPackageRemoveRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns NixPackageRemoveRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$NixPackageRemoveRequest;

  /**
   * Creates a plain object from a NixPackageRemoveRequest message. Also converts values to other types if specified.
   * @param message NixPackageRemoveRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$NixPackageRemoveRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this NixPackageRemoveRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a NixPackageRemoveResponse.
 */
declare type replit$goval$api$INixPackageRemoveResponse = {||};

/**
 * Represents a NixPackageRemoveResponse.
 */
declare class replit$goval$api$NixPackageRemoveResponse {
  /**
   * Constructs a new NixPackageRemoveResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$INixPackageRemoveResponse): this;

  /**
   * Creates a new NixPackageRemoveResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns NixPackageRemoveResponse instance
   */
  static create(
    properties?: replit$goval$api$INixPackageRemoveResponse
  ): replit$goval$api$NixPackageRemoveResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageRemoveResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$NixPackageRemoveResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageRemoveResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$NixPackageRemoveResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a NixPackageRemoveResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns NixPackageRemoveResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$NixPackageRemoveResponse;

  /**
   * Decodes a NixPackageRemoveResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns NixPackageRemoveResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$NixPackageRemoveResponse;

  /**
   * Verifies a NixPackageRemoveResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a NixPackageRemoveResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns NixPackageRemoveResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$NixPackageRemoveResponse;

  /**
   * Creates a plain object from a NixPackageRemoveResponse message. Also converts values to other types if specified.
   * @param message NixPackageRemoveResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$NixPackageRemoveResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this NixPackageRemoveResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a NixPackageListRequest.
 */
declare type replit$goval$api$INixPackageListRequest = {||};

/**
 * Represents a NixPackageListRequest.
 */
declare class replit$goval$api$NixPackageListRequest {
  /**
   * Constructs a new NixPackageListRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$INixPackageListRequest): this;

  /**
   * Creates a new NixPackageListRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns NixPackageListRequest instance
   */
  static create(
    properties?: replit$goval$api$INixPackageListRequest
  ): replit$goval$api$NixPackageListRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageListRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$NixPackageListRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageListRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$NixPackageListRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a NixPackageListRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns NixPackageListRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$NixPackageListRequest;

  /**
   * Decodes a NixPackageListRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns NixPackageListRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$NixPackageListRequest;

  /**
   * Verifies a NixPackageListRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a NixPackageListRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns NixPackageListRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$NixPackageListRequest;

  /**
   * Creates a plain object from a NixPackageListRequest message. Also converts values to other types if specified.
   * @param message NixPackageListRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$NixPackageListRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this NixPackageListRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a NixPackageListResponse.
 */
declare type replit$goval$api$INixPackageListResponse = {|
  /**
   * NixPackageListResponse packages
   */
  packages?:
    | (replit$goval$api$NixPackage | replit$goval$api$INixPackage)[]
    | null,
|};

/**
 * Represents a NixPackageListResponse.
 */
declare class replit$goval$api$NixPackageListResponse {
  /**
   * Constructs a new NixPackageListResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$INixPackageListResponse): this;

  /**
   * NixPackageListResponse packages.
   */
  packages: replit$goval$api$NixPackage[];

  /**
   * Creates a new NixPackageListResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns NixPackageListResponse instance
   */
  static create(
    properties?: replit$goval$api$INixPackageListResponse
  ): replit$goval$api$NixPackageListResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageListResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$NixPackageListResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageListResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$NixPackageListResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a NixPackageListResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns NixPackageListResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$NixPackageListResponse;

  /**
   * Decodes a NixPackageListResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns NixPackageListResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$NixPackageListResponse;

  /**
   * Verifies a NixPackageListResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a NixPackageListResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns NixPackageListResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$NixPackageListResponse;

  /**
   * Creates a plain object from a NixPackageListResponse message. Also converts values to other types if specified.
   * @param message NixPackageListResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$NixPackageListResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this NixPackageListResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a NixPackage.
 */
declare type replit$goval$api$INixPackage = {|
  /**
   * NixPackage name
   */
  name?: string | null,

  /**
   * NixPackage description
   */
  description?: string | null,

  /**
   * NixPackage version
   */
  version?: string | null,

  /**
   * NixPackage homepageURL
   */
  homepageURL?: string[] | null,

  /**
   * NixPackage maintainers
   */
  maintainers?: string[] | null,

  /**
   * NixPackage licenses
   */
  licenses?: string[] | null,
|};

/**
 * Represents a NixPackage.
 */
declare class replit$goval$api$NixPackage {
  /**
   * Constructs a new NixPackage.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$INixPackage): this;

  /**
   * NixPackage name.
   */
  name: string;

  /**
   * NixPackage description.
   */
  description: string;

  /**
   * NixPackage version.
   */
  version: string;

  /**
   * NixPackage homepageURL.
   */
  homepageURL: string[];

  /**
   * NixPackage maintainers.
   */
  maintainers: string[];

  /**
   * NixPackage licenses.
   */
  licenses: string[];

  /**
   * Creates a new NixPackage instance using the specified properties.
   * @param [properties] Properties to set
   * @returns NixPackage instance
   */
  static create(
    properties?: replit$goval$api$INixPackage
  ): replit$goval$api$NixPackage;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackage message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$NixPackage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackage message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$NixPackage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a NixPackage message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns NixPackage
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$NixPackage;

  /**
   * Decodes a NixPackage message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns NixPackage
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$NixPackage;

  /**
   * Verifies a NixPackage message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a NixPackage message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns NixPackage
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$NixPackage;

  /**
   * Creates a plain object from a NixPackage message. Also converts values to other types if specified.
   * @param message NixPackage
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$NixPackage,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this NixPackage to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a NixChannelsRequest.
 */
declare type replit$goval$api$INixChannelsRequest = {||};

/**
 * Represents a NixChannelsRequest.
 */
declare class replit$goval$api$NixChannelsRequest {
  /**
   * Constructs a new NixChannelsRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$INixChannelsRequest): this;

  /**
   * Creates a new NixChannelsRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns NixChannelsRequest instance
   */
  static create(
    properties?: replit$goval$api$INixChannelsRequest
  ): replit$goval$api$NixChannelsRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixChannelsRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$NixChannelsRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixChannelsRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$NixChannelsRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a NixChannelsRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns NixChannelsRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$NixChannelsRequest;

  /**
   * Decodes a NixChannelsRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns NixChannelsRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$NixChannelsRequest;

  /**
   * Verifies a NixChannelsRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a NixChannelsRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns NixChannelsRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$NixChannelsRequest;

  /**
   * Creates a plain object from a NixChannelsRequest message. Also converts values to other types if specified.
   * @param message NixChannelsRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$NixChannelsRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this NixChannelsRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a NixChannelsResponse.
 */
declare type replit$goval$api$INixChannelsResponse = {|
  /**
   * NixChannelsResponse channels
   */
  channels?: string[] | null,
|};

/**
 * Represents a NixChannelsResponse.
 */
declare class replit$goval$api$NixChannelsResponse {
  /**
   * Constructs a new NixChannelsResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$INixChannelsResponse): this;

  /**
   * NixChannelsResponse channels.
   */
  channels: string[];

  /**
   * Creates a new NixChannelsResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns NixChannelsResponse instance
   */
  static create(
    properties?: replit$goval$api$INixChannelsResponse
  ): replit$goval$api$NixChannelsResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixChannelsResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$NixChannelsResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixChannelsResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$NixChannelsResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a NixChannelsResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns NixChannelsResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$NixChannelsResponse;

  /**
   * Decodes a NixChannelsResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns NixChannelsResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$NixChannelsResponse;

  /**
   * Verifies a NixChannelsResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a NixChannelsResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns NixChannelsResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$NixChannelsResponse;

  /**
   * Creates a plain object from a NixChannelsResponse message. Also converts values to other types if specified.
   * @param message NixChannelsResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$NixChannelsResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this NixChannelsResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a NixChannelLatestStableRequest.
 */
declare type replit$goval$api$INixChannelLatestStableRequest = {||};

/**
 * Represents a NixChannelLatestStableRequest.
 */
declare class replit$goval$api$NixChannelLatestStableRequest {
  /**
   * Constructs a new NixChannelLatestStableRequest.
   * @param [properties] Properties to set
   */
  constructor(
    properties?: replit$goval$api$INixChannelLatestStableRequest
  ): this;

  /**
   * Creates a new NixChannelLatestStableRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns NixChannelLatestStableRequest instance
   */
  static create(
    properties?: replit$goval$api$INixChannelLatestStableRequest
  ): replit$goval$api$NixChannelLatestStableRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixChannelLatestStableRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$NixChannelLatestStableRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixChannelLatestStableRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$NixChannelLatestStableRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a NixChannelLatestStableRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns NixChannelLatestStableRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$NixChannelLatestStableRequest;

  /**
   * Decodes a NixChannelLatestStableRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns NixChannelLatestStableRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$NixChannelLatestStableRequest;

  /**
   * Verifies a NixChannelLatestStableRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a NixChannelLatestStableRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns NixChannelLatestStableRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$NixChannelLatestStableRequest;

  /**
   * Creates a plain object from a NixChannelLatestStableRequest message. Also converts values to other types if specified.
   * @param message NixChannelLatestStableRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$NixChannelLatestStableRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this NixChannelLatestStableRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a NixChannelLatestStableResponse.
 */
declare type replit$goval$api$INixChannelLatestStableResponse = {|
  /**
   * NixChannelLatestStableResponse channel
   */
  channel?: string | null,
|};

/**
 * Represents a NixChannelLatestStableResponse.
 */
declare class replit$goval$api$NixChannelLatestStableResponse {
  /**
   * Constructs a new NixChannelLatestStableResponse.
   * @param [properties] Properties to set
   */
  constructor(
    properties?: replit$goval$api$INixChannelLatestStableResponse
  ): this;

  /**
   * NixChannelLatestStableResponse channel.
   */
  channel: string;

  /**
   * Creates a new NixChannelLatestStableResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns NixChannelLatestStableResponse instance
   */
  static create(
    properties?: replit$goval$api$INixChannelLatestStableResponse
  ): replit$goval$api$NixChannelLatestStableResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixChannelLatestStableResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$NixChannelLatestStableResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixChannelLatestStableResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$NixChannelLatestStableResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a NixChannelLatestStableResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns NixChannelLatestStableResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$NixChannelLatestStableResponse;

  /**
   * Decodes a NixChannelLatestStableResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns NixChannelLatestStableResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$NixChannelLatestStableResponse;

  /**
   * Verifies a NixChannelLatestStableResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a NixChannelLatestStableResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns NixChannelLatestStableResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$NixChannelLatestStableResponse;

  /**
   * Creates a plain object from a NixChannelLatestStableResponse message. Also converts values to other types if specified.
   * @param message NixChannelLatestStableResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$NixChannelLatestStableResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this NixChannelLatestStableResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a NixPackageSearchRequest.
 */
declare type replit$goval$api$INixPackageSearchRequest = {|
  /**
   * NixPackageSearchRequest query
   */
  query?: string | null,
|};

/**
 * Represents a NixPackageSearchRequest.
 */
declare class replit$goval$api$NixPackageSearchRequest {
  /**
   * Constructs a new NixPackageSearchRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$INixPackageSearchRequest): this;

  /**
   * NixPackageSearchRequest query.
   */
  query: string;

  /**
   * Creates a new NixPackageSearchRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns NixPackageSearchRequest instance
   */
  static create(
    properties?: replit$goval$api$INixPackageSearchRequest
  ): replit$goval$api$NixPackageSearchRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageSearchRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$NixPackageSearchRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageSearchRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$NixPackageSearchRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a NixPackageSearchRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns NixPackageSearchRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$NixPackageSearchRequest;

  /**
   * Decodes a NixPackageSearchRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns NixPackageSearchRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$NixPackageSearchRequest;

  /**
   * Verifies a NixPackageSearchRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a NixPackageSearchRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns NixPackageSearchRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$NixPackageSearchRequest;

  /**
   * Creates a plain object from a NixPackageSearchRequest message. Also converts values to other types if specified.
   * @param message NixPackageSearchRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$NixPackageSearchRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this NixPackageSearchRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a NixPackageSearchResponse.
 */
declare type replit$goval$api$INixPackageSearchResponse = {|
  /**
   * NixPackageSearchResponse packages
   */
  packages?:
    | (replit$goval$api$NixPackage | replit$goval$api$INixPackage)[]
    | null,
|};

/**
 * Represents a NixPackageSearchResponse.
 */
declare class replit$goval$api$NixPackageSearchResponse {
  /**
   * Constructs a new NixPackageSearchResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$INixPackageSearchResponse): this;

  /**
   * NixPackageSearchResponse packages.
   */
  packages: replit$goval$api$NixPackage[];

  /**
   * Creates a new NixPackageSearchResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns NixPackageSearchResponse instance
   */
  static create(
    properties?: replit$goval$api$INixPackageSearchResponse
  ): replit$goval$api$NixPackageSearchResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageSearchResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$NixPackageSearchResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixPackageSearchResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$NixPackageSearchResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a NixPackageSearchResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns NixPackageSearchResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$NixPackageSearchResponse;

  /**
   * Decodes a NixPackageSearchResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns NixPackageSearchResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$NixPackageSearchResponse;

  /**
   * Verifies a NixPackageSearchResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a NixPackageSearchResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns NixPackageSearchResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$NixPackageSearchResponse;

  /**
   * Creates a plain object from a NixPackageSearchResponse message. Also converts values to other types if specified.
   * @param message NixPackageSearchResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$NixPackageSearchResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this NixPackageSearchResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a StartLSP.
 */
declare type replit$goval$api$IStartLSP = {|
  /**
   * StartLSP language
   */
  language?: string | null,
|};

/**
 * Represents a StartLSP.
 */
declare class replit$goval$api$StartLSP {
  /**
   * Constructs a new StartLSP.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IStartLSP): this;

  /**
   * StartLSP language.
   */
  language: string;

  /**
   * Creates a new StartLSP instance using the specified properties.
   * @param [properties] Properties to set
   * @returns StartLSP instance
   */
  static create(
    properties?: replit$goval$api$IStartLSP
  ): replit$goval$api$StartLSP;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StartLSP message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$StartLSP,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StartLSP message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$StartLSP,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a StartLSP message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns StartLSP
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$StartLSP;

  /**
   * Decodes a StartLSP message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns StartLSP
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$StartLSP;

  /**
   * Verifies a StartLSP message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a StartLSP message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns StartLSP
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$StartLSP;

  /**
   * Creates a plain object from a StartLSP message. Also converts values to other types if specified.
   * @param message StartLSP
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$StartLSP,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this StartLSP to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an Audio.
 */
declare type replit$goval$api$IAudio = {|
  /**
   * Audio data
   */
  data?: number[] | null,
|};

/**
 * Represents an Audio.
 */
declare class replit$goval$api$Audio {
  /**
   * Constructs a new Audio.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IAudio): this;

  /**
   * Audio data.
   */
  data: number[];

  /**
   * Creates a new Audio instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Audio instance
   */
  static create(properties?: replit$goval$api$IAudio): replit$goval$api$Audio;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Audio message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Audio,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Audio message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Audio,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an Audio message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Audio
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Audio;

  /**
   * Decodes an Audio message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Audio
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Audio;

  /**
   * Verifies an Audio message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an Audio message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Audio
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Audio;

  /**
   * Creates a plain object from an Audio message. Also converts values to other types if specified.
   * @param message Audio
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Audio,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Audio to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an Audio2.
 */
declare type replit$goval$api$IAudio2 = {|
  /**
   * Audio2 data
   */
  data?: number[] | null,

  /**
   * Audio2 samples
   */
  samples?: number | null,
|};

/**
 * Represents an Audio2.
 */
declare class replit$goval$api$Audio2 {
  /**
   * Constructs a new Audio2.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IAudio2): this;

  /**
   * Audio2 data.
   */
  data: number[];

  /**
   * Audio2 samples.
   */
  samples: number;

  /**
   * Creates a new Audio2 instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Audio2 instance
   */
  static create(properties?: replit$goval$api$IAudio2): replit$goval$api$Audio2;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Audio2 message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Audio2,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Audio2 message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Audio2,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an Audio2 message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Audio2
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Audio2;

  /**
   * Decodes an Audio2 message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Audio2
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Audio2;

  /**
   * Verifies an Audio2 message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an Audio2 message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Audio2
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Audio2;

  /**
   * Creates a plain object from an Audio2 message. Also converts values to other types if specified.
   * @param message Audio2
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Audio2,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Audio2 to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Preconditions.
 */
declare type replit$goval$api$IPreconditions = {|
  /**
   * Preconditions generation
   */
  generation?: number | null,

  /**
   * Preconditions metageneration
   */
  metageneration?: number | null,

  /**
   * Preconditions doesNotExist
   */
  doesNotExist?: boolean | null,
|};

/**
 * Represents a Preconditions.
 */
declare class replit$goval$api$Preconditions {
  /**
   * Constructs a new Preconditions.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPreconditions): this;

  /**
   * Preconditions generation.
   */
  generation: number;

  /**
   * Preconditions metageneration.
   */
  metageneration: number;

  /**
   * Preconditions doesNotExist.
   */
  doesNotExist: boolean;

  /**
   * Creates a new Preconditions instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Preconditions instance
   */
  static create(
    properties?: replit$goval$api$IPreconditions
  ): replit$goval$api$Preconditions;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Preconditions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Preconditions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Preconditions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Preconditions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Preconditions message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Preconditions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Preconditions;

  /**
   * Decodes a Preconditions message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Preconditions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Preconditions;

  /**
   * Verifies a Preconditions message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Preconditions message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Preconditions
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Preconditions;

  /**
   * Creates a plain object from a Preconditions message. Also converts values to other types if specified.
   * @param message Preconditions
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Preconditions,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Preconditions to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReadMetaRequest.
 */
declare type replit$goval$api$IReadMetaRequest = {|
  /**
   * ReadMetaRequest key
   */
  key?: string | null,

  /**
   * ReadMetaRequest exists
   */
  exists?: boolean | null,

  /**
   * ReadMetaRequest data
   */
  data?: Uint8Array | null,
|};

/**
 * Represents a ReadMetaRequest.
 */
declare class replit$goval$api$ReadMetaRequest {
  /**
   * Constructs a new ReadMetaRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IReadMetaRequest): this;

  /**
   * ReadMetaRequest key.
   */
  key: string;

  /**
   * ReadMetaRequest exists.
   */
  exists: boolean;

  /**
   * ReadMetaRequest data.
   */
  data: Uint8Array;

  /**
   * Creates a new ReadMetaRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReadMetaRequest instance
   */
  static create(
    properties?: replit$goval$api$IReadMetaRequest
  ): replit$goval$api$ReadMetaRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReadMetaRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ReadMetaRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReadMetaRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ReadMetaRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReadMetaRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReadMetaRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ReadMetaRequest;

  /**
   * Decodes a ReadMetaRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReadMetaRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ReadMetaRequest;

  /**
   * Verifies a ReadMetaRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReadMetaRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReadMetaRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ReadMetaRequest;

  /**
   * Creates a plain object from a ReadMetaRequest message. Also converts values to other types if specified.
   * @param message ReadMetaRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ReadMetaRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReadMetaRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReadMetaResponse.
 */
declare type replit$goval$api$IReadMetaResponse = {|
  /**
   * ReadMetaResponse key
   */
  key?: string | null,

  /**
   * ReadMetaResponse exists
   */
  exists?: boolean | null,

  /**
   * ReadMetaResponse data
   */
  data?: Uint8Array | null,

  /**
   * ReadMetaResponse generation
   */
  generation?: number | null,

  /**
   * ReadMetaResponse metageneration
   */
  metageneration?: number | null,
|};

/**
 * Represents a ReadMetaResponse.
 */
declare class replit$goval$api$ReadMetaResponse {
  /**
   * Constructs a new ReadMetaResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IReadMetaResponse): this;

  /**
   * ReadMetaResponse key.
   */
  key: string;

  /**
   * ReadMetaResponse exists.
   */
  exists: boolean;

  /**
   * ReadMetaResponse data.
   */
  data: Uint8Array;

  /**
   * ReadMetaResponse generation.
   */
  generation: number;

  /**
   * ReadMetaResponse metageneration.
   */
  metageneration: number;

  /**
   * Creates a new ReadMetaResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReadMetaResponse instance
   */
  static create(
    properties?: replit$goval$api$IReadMetaResponse
  ): replit$goval$api$ReadMetaResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReadMetaResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ReadMetaResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReadMetaResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ReadMetaResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReadMetaResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReadMetaResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ReadMetaResponse;

  /**
   * Decodes a ReadMetaResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReadMetaResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ReadMetaResponse;

  /**
   * Verifies a ReadMetaResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReadMetaResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReadMetaResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ReadMetaResponse;

  /**
   * Creates a plain object from a ReadMetaResponse message. Also converts values to other types if specified.
   * @param message ReadMetaResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ReadMetaResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReadMetaResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a WriteMetaRequest.
 */
declare type replit$goval$api$IWriteMetaRequest = {|
  /**
   * WriteMetaRequest key
   */
  key?: string | null,

  /**
   * WriteMetaRequest data
   */
  data?: Uint8Array | null,

  /**
   * WriteMetaRequest preconditions
   */
  preconditions?:
    | replit$goval$api$Preconditions
    | replit$goval$api$IPreconditions
    | null,
|};

/**
 * Represents a WriteMetaRequest.
 */
declare class replit$goval$api$WriteMetaRequest {
  /**
   * Constructs a new WriteMetaRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IWriteMetaRequest): this;

  /**
   * WriteMetaRequest key.
   */
  key: string;

  /**
   * WriteMetaRequest data.
   */
  data: Uint8Array;

  /**
   * WriteMetaRequest preconditions.
   */
  preconditions?: replit$goval$api$Preconditions | null;

  /**
   * Creates a new WriteMetaRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns WriteMetaRequest instance
   */
  static create(
    properties?: replit$goval$api$IWriteMetaRequest
  ): replit$goval$api$WriteMetaRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message WriteMetaRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$WriteMetaRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message WriteMetaRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$WriteMetaRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a WriteMetaRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns WriteMetaRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$WriteMetaRequest;

  /**
   * Decodes a WriteMetaRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns WriteMetaRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$WriteMetaRequest;

  /**
   * Verifies a WriteMetaRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a WriteMetaRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns WriteMetaRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$WriteMetaRequest;

  /**
   * Creates a plain object from a WriteMetaRequest message. Also converts values to other types if specified.
   * @param message WriteMetaRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$WriteMetaRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this WriteMetaRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a WriteMetaResponse.
 */
declare type replit$goval$api$IWriteMetaResponse = {|
  /**
   * WriteMetaResponse generation
   */
  generation?: number | null,

  /**
   * WriteMetaResponse metageneration
   */
  metageneration?: number | null,
|};

/**
 * Represents a WriteMetaResponse.
 */
declare class replit$goval$api$WriteMetaResponse {
  /**
   * Constructs a new WriteMetaResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IWriteMetaResponse): this;

  /**
   * WriteMetaResponse generation.
   */
  generation: number;

  /**
   * WriteMetaResponse metageneration.
   */
  metageneration: number;

  /**
   * Creates a new WriteMetaResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns WriteMetaResponse instance
   */
  static create(
    properties?: replit$goval$api$IWriteMetaResponse
  ): replit$goval$api$WriteMetaResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message WriteMetaResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$WriteMetaResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message WriteMetaResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$WriteMetaResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a WriteMetaResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns WriteMetaResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$WriteMetaResponse;

  /**
   * Decodes a WriteMetaResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns WriteMetaResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$WriteMetaResponse;

  /**
   * Verifies a WriteMetaResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a WriteMetaResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns WriteMetaResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$WriteMetaResponse;

  /**
   * Creates a plain object from a WriteMetaResponse message. Also converts values to other types if specified.
   * @param message WriteMetaResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$WriteMetaResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this WriteMetaResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an AppendMetaRequest.
 */
declare type replit$goval$api$IAppendMetaRequest = {|
  /**
   * AppendMetaRequest key
   */
  key?: string | null,

  /**
   * AppendMetaRequest data
   */
  data?: Uint8Array | null,

  /**
   * AppendMetaRequest preconditions
   */
  preconditions?:
    | replit$goval$api$Preconditions
    | replit$goval$api$IPreconditions
    | null,
|};

/**
 * Represents an AppendMetaRequest.
 */
declare class replit$goval$api$AppendMetaRequest {
  /**
   * Constructs a new AppendMetaRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IAppendMetaRequest): this;

  /**
   * AppendMetaRequest key.
   */
  key: string;

  /**
   * AppendMetaRequest data.
   */
  data: Uint8Array;

  /**
   * AppendMetaRequest preconditions.
   */
  preconditions?: replit$goval$api$Preconditions | null;

  /**
   * Creates a new AppendMetaRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns AppendMetaRequest instance
   */
  static create(
    properties?: replit$goval$api$IAppendMetaRequest
  ): replit$goval$api$AppendMetaRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AppendMetaRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$AppendMetaRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AppendMetaRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$AppendMetaRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an AppendMetaRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns AppendMetaRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$AppendMetaRequest;

  /**
   * Decodes an AppendMetaRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns AppendMetaRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$AppendMetaRequest;

  /**
   * Verifies an AppendMetaRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an AppendMetaRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns AppendMetaRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$AppendMetaRequest;

  /**
   * Creates a plain object from an AppendMetaRequest message. Also converts values to other types if specified.
   * @param message AppendMetaRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$AppendMetaRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this AppendMetaRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an AppendMetaResponse.
 */
declare type replit$goval$api$IAppendMetaResponse = {|
  /**
   * AppendMetaResponse generation
   */
  generation?: number | null,

  /**
   * AppendMetaResponse metageneration
   */
  metageneration?: number | null,
|};

/**
 * Represents an AppendMetaResponse.
 */
declare class replit$goval$api$AppendMetaResponse {
  /**
   * Constructs a new AppendMetaResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IAppendMetaResponse): this;

  /**
   * AppendMetaResponse generation.
   */
  generation: number;

  /**
   * AppendMetaResponse metageneration.
   */
  metageneration: number;

  /**
   * Creates a new AppendMetaResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns AppendMetaResponse instance
   */
  static create(
    properties?: replit$goval$api$IAppendMetaResponse
  ): replit$goval$api$AppendMetaResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AppendMetaResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$AppendMetaResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AppendMetaResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$AppendMetaResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an AppendMetaResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns AppendMetaResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$AppendMetaResponse;

  /**
   * Decodes an AppendMetaResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns AppendMetaResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$AppendMetaResponse;

  /**
   * Verifies an AppendMetaResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an AppendMetaResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns AppendMetaResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$AppendMetaResponse;

  /**
   * Creates a plain object from an AppendMetaResponse message. Also converts values to other types if specified.
   * @param message AppendMetaResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$AppendMetaResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this AppendMetaResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a BootStatus.
 */
declare type replit$goval$api$IBootStatus = {|
  /**
   * BootStatus stage
   */
  stage?: $Values<typeof replit$goval$api$BootStatus$Stage> | null,

  /**
   * BootStatus progress
   */
  progress?: number | null,

  /**
   * BootStatus total
   */
  total?: number | null,
|};

/**
 * Represents a BootStatus.
 */
declare class replit$goval$api$BootStatus {
  /**
   * Constructs a new BootStatus.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IBootStatus): this;

  /**
   * BootStatus stage.
   */
  stage: $Values<typeof replit$goval$api$BootStatus$Stage>;

  /**
   * BootStatus progress.
   */
  progress: number;

  /**
   * BootStatus total.
   */
  total: number;

  /**
   * Creates a new BootStatus instance using the specified properties.
   * @param [properties] Properties to set
   * @returns BootStatus instance
   */
  static create(
    properties?: replit$goval$api$IBootStatus
  ): replit$goval$api$BootStatus;

  /**
   * [object Object],[object Object],[object Object]
   * @param message BootStatus message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$BootStatus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message BootStatus message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$BootStatus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a BootStatus message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns BootStatus
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$BootStatus;

  /**
   * Decodes a BootStatus message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns BootStatus
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$BootStatus;

  /**
   * Verifies a BootStatus message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a BootStatus message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns BootStatus
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$BootStatus;

  /**
   * Creates a plain object from a BootStatus message. Also converts values to other types if specified.
   * @param message BootStatus
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$BootStatus,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this BootStatus to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Stage: typeof replit$goval$api$BootStatus$Stage;
}

/**
 * Stage enum.
 */

declare var replit$goval$api$BootStatus$Stage: {|
  +HANDSHAKE: 0, // 0
  +ACQUIRING: 3, // 3
  +COMPLETE: 4, // 4
  +PROXY: 5, // 5
  +PULL_FILES: 6, // 6
  +LOAD_BLOCK: 7, // 7
  +RETRY: 8, // 8
|};

/**
 * Properties of a Pid1Config.
 */
declare type replit$goval$api$IPid1Config = {|
  /**
   * Pid1Config cwd
   */
  cwd?: string | null,

  /**
   * Pid1Config language
   */
  language?: string | null,

  /**
   * Pid1Config env
   */
  env?: {|
    [k: string]: string,
  |} | null,

  /**
   * Pid1Config noStore
   */
  noStore?: boolean | null,

  /**
   * Pid1Config noninteractiveFSChange
   */
  noninteractiveFSChange?: boolean | null,
|};

/**
 * Represents a Pid1Config.
 */
declare class replit$goval$api$Pid1Config {
  /**
   * Constructs a new Pid1Config.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPid1Config): this;

  /**
   * Pid1Config cwd.
   */
  cwd: string;

  /**
   * Pid1Config language.
   */
  language: string;

  /**
   * Pid1Config env.
   */
  env: {|
    [k: string]: string,
  |};

  /**
   * Pid1Config noStore.
   */
  noStore: boolean;

  /**
   * Pid1Config noninteractiveFSChange.
   */
  noninteractiveFSChange: boolean;

  /**
   * Creates a new Pid1Config instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Pid1Config instance
   */
  static create(
    properties?: replit$goval$api$IPid1Config
  ): replit$goval$api$Pid1Config;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Pid1Config message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Pid1Config,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Pid1Config message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Pid1Config,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Pid1Config message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Pid1Config
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Pid1Config;

  /**
   * Decodes a Pid1Config message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Pid1Config
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Pid1Config;

  /**
   * Verifies a Pid1Config message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Pid1Config message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Pid1Config
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Pid1Config;

  /**
   * Creates a plain object from a Pid1Config message. Also converts values to other types if specified.
   * @param message Pid1Config
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Pid1Config,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Pid1Config to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FSLock.
 */
declare type replit$goval$api$IFSLock = {|
  /**
   * FSLock name
   */
  name?: string | null,
|};

/**
 * Represents a FSLock.
 */
declare class replit$goval$api$FSLock {
  /**
   * Constructs a new FSLock.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IFSLock): this;

  /**
   * FSLock name.
   */
  name: string;

  /**
   * Creates a new FSLock instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FSLock instance
   */
  static create(properties?: replit$goval$api$IFSLock): replit$goval$api$FSLock;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FSLock message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$FSLock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FSLock message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$FSLock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FSLock message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FSLock
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$FSLock;

  /**
   * Decodes a FSLock message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FSLock
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$FSLock;

  /**
   * Verifies a FSLock message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FSLock message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FSLock
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$FSLock;

  /**
   * Creates a plain object from a FSLock message. Also converts values to other types if specified.
   * @param message FSLock
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$FSLock,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FSLock to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FSSnapshot.
 */
declare type replit$goval$api$IFSSnapshot = {||};

/**
 * Represents a FSSnapshot.
 */
declare class replit$goval$api$FSSnapshot {
  /**
   * Constructs a new FSSnapshot.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IFSSnapshot): this;

  /**
   * Creates a new FSSnapshot instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FSSnapshot instance
   */
  static create(
    properties?: replit$goval$api$IFSSnapshot
  ): replit$goval$api$FSSnapshot;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FSSnapshot message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$FSSnapshot,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FSSnapshot message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$FSSnapshot,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FSSnapshot message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FSSnapshot
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$FSSnapshot;

  /**
   * Decodes a FSSnapshot message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FSSnapshot
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$FSSnapshot;

  /**
   * Verifies a FSSnapshot message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FSSnapshot message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FSSnapshot
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$FSSnapshot;

  /**
   * Creates a plain object from a FSSnapshot message. Also converts values to other types if specified.
   * @param message FSSnapshot
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$FSSnapshot,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FSSnapshot to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FSSnapshotEvent.
 */
declare type replit$goval$api$IFSSnapshotEvent = {|
  /**
   * FSSnapshotEvent sources
   */
  sources?: string[] | null,
|};

/**
 * Represents a FSSnapshotEvent.
 */
declare class replit$goval$api$FSSnapshotEvent {
  /**
   * Constructs a new FSSnapshotEvent.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IFSSnapshotEvent): this;

  /**
   * FSSnapshotEvent sources.
   */
  sources: string[];

  /**
   * Creates a new FSSnapshotEvent instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FSSnapshotEvent instance
   */
  static create(
    properties?: replit$goval$api$IFSSnapshotEvent
  ): replit$goval$api$FSSnapshotEvent;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FSSnapshotEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$FSSnapshotEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FSSnapshotEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$FSSnapshotEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FSSnapshotEvent message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FSSnapshotEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$FSSnapshotEvent;

  /**
   * Decodes a FSSnapshotEvent message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FSSnapshotEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$FSSnapshotEvent;

  /**
   * Verifies a FSSnapshotEvent message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FSSnapshotEvent message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FSSnapshotEvent
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$FSSnapshotEvent;

  /**
   * Creates a plain object from a FSSnapshotEvent message. Also converts values to other types if specified.
   * @param message FSSnapshotEvent
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$FSSnapshotEvent,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FSSnapshotEvent to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a SnapshotEvent.
 */
declare type replit$goval$api$ISnapshotEvent = {|
  /**
   * SnapshotEvent sources
   */
  sources?: string[] | null,
|};

/**
 * Represents a SnapshotEvent.
 */
declare class replit$goval$api$SnapshotEvent {
  /**
   * Constructs a new SnapshotEvent.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ISnapshotEvent): this;

  /**
   * SnapshotEvent sources.
   */
  sources: string[];

  /**
   * Creates a new SnapshotEvent instance using the specified properties.
   * @param [properties] Properties to set
   * @returns SnapshotEvent instance
   */
  static create(
    properties?: replit$goval$api$ISnapshotEvent
  ): replit$goval$api$SnapshotEvent;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SnapshotEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$SnapshotEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SnapshotEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$SnapshotEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a SnapshotEvent message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns SnapshotEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$SnapshotEvent;

  /**
   * Decodes a SnapshotEvent message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns SnapshotEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$SnapshotEvent;

  /**
   * Verifies a SnapshotEvent message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a SnapshotEvent message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns SnapshotEvent
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$SnapshotEvent;

  /**
   * Creates a plain object from a SnapshotEvent message. Also converts values to other types if specified.
   * @param message SnapshotEvent
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$SnapshotEvent,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this SnapshotEvent to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a SubscribeFile.
 */
declare type replit$goval$api$ISubscribeFile = {|
  /**
   * SubscribeFile files
   */
  files?: (replit$goval$api$File | replit$goval$api$IFile)[] | null,
|};

/**
 * Represents a SubscribeFile.
 */
declare class replit$goval$api$SubscribeFile {
  /**
   * Constructs a new SubscribeFile.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ISubscribeFile): this;

  /**
   * SubscribeFile files.
   */
  files: replit$goval$api$File[];

  /**
   * Creates a new SubscribeFile instance using the specified properties.
   * @param [properties] Properties to set
   * @returns SubscribeFile instance
   */
  static create(
    properties?: replit$goval$api$ISubscribeFile
  ): replit$goval$api$SubscribeFile;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SubscribeFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$SubscribeFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SubscribeFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$SubscribeFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a SubscribeFile message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns SubscribeFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$SubscribeFile;

  /**
   * Decodes a SubscribeFile message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns SubscribeFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$SubscribeFile;

  /**
   * Verifies a SubscribeFile message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a SubscribeFile message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns SubscribeFile
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$SubscribeFile;

  /**
   * Creates a plain object from a SubscribeFile message. Also converts values to other types if specified.
   * @param message SubscribeFile
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$SubscribeFile,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this SubscribeFile to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FileEvent.
 */
declare type replit$goval$api$IFileEvent = {|
  /**
   * FileEvent file
   */
  file?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * FileEvent dest
   */
  dest?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * FileEvent op
   */
  op?: $Values<typeof replit$goval$api$FileEvent$Op> | null,
|};

/**
 * Represents a FileEvent.
 */
declare class replit$goval$api$FileEvent {
  /**
   * Constructs a new FileEvent.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IFileEvent): this;

  /**
   * FileEvent file.
   */
  file?: replit$goval$api$File | null;

  /**
   * FileEvent dest.
   */
  dest?: replit$goval$api$File | null;

  /**
   * FileEvent op.
   */
  op: $Values<typeof replit$goval$api$FileEvent$Op>;

  /**
   * Creates a new FileEvent instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FileEvent instance
   */
  static create(
    properties?: replit$goval$api$IFileEvent
  ): replit$goval$api$FileEvent;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$FileEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$FileEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FileEvent message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FileEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$FileEvent;

  /**
   * Decodes a FileEvent message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FileEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$FileEvent;

  /**
   * Verifies a FileEvent message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FileEvent message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FileEvent
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$FileEvent;

  /**
   * Creates a plain object from a FileEvent message. Also converts values to other types if specified.
   * @param message FileEvent
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$FileEvent,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FileEvent to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Op: typeof replit$goval$api$FileEvent$Op;
}

/**
 * Op enum.
 */

declare var replit$goval$api$FileEvent$Op: {|
  +Create: 0, // 0
  +Move: 1, // 1
  +Remove: 2, // 2
  +Modify: 3, // 3
|};

/**
 * Properties of a Flush.
 */
declare type replit$goval$api$IFlush = {|
  /**
   * Flush consistency
   */
  consistency?: $Values<typeof replit$goval$api$Flush$Consistency> | null,
|};

/**
 * Represents a Flush.
 */
declare class replit$goval$api$Flush {
  /**
   * Constructs a new Flush.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IFlush): this;

  /**
   * Flush consistency.
   */
  consistency: $Values<typeof replit$goval$api$Flush$Consistency>;

  /**
   * Creates a new Flush instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Flush instance
   */
  static create(properties?: replit$goval$api$IFlush): replit$goval$api$Flush;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Flush message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Flush,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Flush message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Flush,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Flush message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Flush
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Flush;

  /**
   * Decodes a Flush message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Flush
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Flush;

  /**
   * Verifies a Flush message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Flush message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Flush
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Flush;

  /**
   * Creates a plain object from a Flush message. Also converts values to other types if specified.
   * @param message Flush
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Flush,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Flush to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Consistency: typeof replit$goval$api$Flush$Consistency;
}

/**
 * Consistency enum.
 */

declare var replit$goval$api$Flush$Consistency: {|
  +PermanentStorage: 0, // 0
  +Disk: 1, // 1
|};

/**
 * Properties of a OTLinkFile.
 */
declare type replit$goval$api$IOTLinkFile = {|
  /**
   * OTLinkFile file
   */
  file?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * OTLinkFile highConsistency
   */
  highConsistency?: boolean | null,

  /**
   * OTLinkFile OBSOLETEUseModTime
   */
  OBSOLETEUseModTime?: boolean | null,
|};

/**
 * Represents a OTLinkFile.
 */
declare class replit$goval$api$OTLinkFile {
  /**
   * Constructs a new OTLinkFile.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IOTLinkFile): this;

  /**
   * OTLinkFile file.
   */
  file?: replit$goval$api$File | null;

  /**
   * OTLinkFile highConsistency.
   */
  highConsistency: boolean;

  /**
   * OTLinkFile OBSOLETEUseModTime.
   */
  OBSOLETEUseModTime: boolean;

  /**
   * Creates a new OTLinkFile instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTLinkFile instance
   */
  static create(
    properties?: replit$goval$api$IOTLinkFile
  ): replit$goval$api$OTLinkFile;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTLinkFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$OTLinkFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTLinkFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$OTLinkFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTLinkFile message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTLinkFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$OTLinkFile;

  /**
   * Decodes a OTLinkFile message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTLinkFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$OTLinkFile;

  /**
   * Verifies a OTLinkFile message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTLinkFile message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTLinkFile
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$OTLinkFile;

  /**
   * Creates a plain object from a OTLinkFile message. Also converts values to other types if specified.
   * @param message OTLinkFile
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$OTLinkFile,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTLinkFile to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTLinkFileResponse.
 */
declare type replit$goval$api$IOTLinkFileResponse = {|
  /**
   * OTLinkFileResponse version
   */
  version?: number | null,

  /**
   * OTLinkFileResponse linkedFile
   */
  linkedFile?: replit$goval$api$File | replit$goval$api$IFile | null,
|};

/**
 * Represents a OTLinkFileResponse.
 */
declare class replit$goval$api$OTLinkFileResponse {
  /**
   * Constructs a new OTLinkFileResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IOTLinkFileResponse): this;

  /**
   * OTLinkFileResponse version.
   */
  version: number;

  /**
   * OTLinkFileResponse linkedFile.
   */
  linkedFile?: replit$goval$api$File | null;

  /**
   * Creates a new OTLinkFileResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTLinkFileResponse instance
   */
  static create(
    properties?: replit$goval$api$IOTLinkFileResponse
  ): replit$goval$api$OTLinkFileResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTLinkFileResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$OTLinkFileResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTLinkFileResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$OTLinkFileResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTLinkFileResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTLinkFileResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$OTLinkFileResponse;

  /**
   * Decodes a OTLinkFileResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTLinkFileResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$OTLinkFileResponse;

  /**
   * Verifies a OTLinkFileResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTLinkFileResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTLinkFileResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$OTLinkFileResponse;

  /**
   * Creates a plain object from a OTLinkFileResponse message. Also converts values to other types if specified.
   * @param message OTLinkFileResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$OTLinkFileResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTLinkFileResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an Auth.
 */
declare type replit$goval$api$IAuth = {|
  /**
   * Auth token
   */
  token?: string | null,

  /**
   * Auth containerID
   */
  containerID?: string | null,
|};

/**
 * Represents an Auth.
 */
declare class replit$goval$api$Auth {
  /**
   * Constructs a new Auth.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IAuth): this;

  /**
   * Auth token.
   */
  token: string;

  /**
   * Auth containerID.
   */
  containerID: string;

  /**
   * Creates a new Auth instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Auth instance
   */
  static create(properties?: replit$goval$api$IAuth): replit$goval$api$Auth;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Auth message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Auth,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Auth message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Auth,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an Auth message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Auth
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Auth;

  /**
   * Decodes an Auth message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Auth
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Auth;

  /**
   * Verifies an Auth message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an Auth message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Auth
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Auth;

  /**
   * Creates a plain object from an Auth message. Also converts values to other types if specified.
   * @param message Auth
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Auth,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Auth to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a VCREntry.
 */
declare type replit$goval$api$IVCREntry = {|
  /**
   * VCREntry timestamp
   */
  timestamp?: number | null,

  /**
   * VCREntry direction
   */
  direction?: $Values<typeof replit$goval$api$VCREntry$Direction> | null,

  /**
   * VCREntry command
   */
  command?: replit$goval$api$Command | replit$goval$api$ICommand | null,

  /**
   * VCREntry uid
   */
  uid?: string | null,

  /**
   * VCREntry replid
   */
  replid?: string | null,
|};

/**
 * Represents a VCREntry.
 */
declare class replit$goval$api$VCREntry {
  /**
   * Constructs a new VCREntry.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IVCREntry): this;

  /**
   * VCREntry timestamp.
   */
  timestamp: number;

  /**
   * VCREntry direction.
   */
  direction: $Values<typeof replit$goval$api$VCREntry$Direction>;

  /**
   * VCREntry command.
   */
  command?: replit$goval$api$Command | null;

  /**
   * VCREntry uid.
   */
  uid: string;

  /**
   * VCREntry replid.
   */
  replid: string;

  /**
   * Creates a new VCREntry instance using the specified properties.
   * @param [properties] Properties to set
   * @returns VCREntry instance
   */
  static create(
    properties?: replit$goval$api$IVCREntry
  ): replit$goval$api$VCREntry;

  /**
   * [object Object],[object Object],[object Object]
   * @param message VCREntry message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$VCREntry,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message VCREntry message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$VCREntry,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a VCREntry message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns VCREntry
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$VCREntry;

  /**
   * Decodes a VCREntry message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns VCREntry
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$VCREntry;

  /**
   * Verifies a VCREntry message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a VCREntry message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns VCREntry
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$VCREntry;

  /**
   * Creates a plain object from a VCREntry message. Also converts values to other types if specified.
   * @param message VCREntry
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$VCREntry,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this VCREntry to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Direction: typeof replit$goval$api$VCREntry$Direction;
}

/**
 * Direction enum.
 */

declare var replit$goval$api$VCREntry$Direction: {|
  +IN: 0, // 0
  +OUT: 1, // 1
|};

/**
 * Properties of a StartVCR.
 */
declare type replit$goval$api$IStartVCR = {||};

/**
 * Represents a StartVCR.
 */
declare class replit$goval$api$StartVCR {
  /**
   * Constructs a new StartVCR.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IStartVCR): this;

  /**
   * Creates a new StartVCR instance using the specified properties.
   * @param [properties] Properties to set
   * @returns StartVCR instance
   */
  static create(
    properties?: replit$goval$api$IStartVCR
  ): replit$goval$api$StartVCR;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StartVCR message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$StartVCR,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StartVCR message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$StartVCR,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a StartVCR message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns StartVCR
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$StartVCR;

  /**
   * Decodes a StartVCR message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns StartVCR
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$StartVCR;

  /**
   * Verifies a StartVCR message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a StartVCR message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns StartVCR
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$StartVCR;

  /**
   * Creates a plain object from a StartVCR message. Also converts values to other types if specified.
   * @param message StartVCR
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$StartVCR,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this StartVCR to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReadVCR.
 */
declare type replit$goval$api$IReadVCR = {||};

/**
 * Represents a ReadVCR.
 */
declare class replit$goval$api$ReadVCR {
  /**
   * Constructs a new ReadVCR.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IReadVCR): this;

  /**
   * Creates a new ReadVCR instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReadVCR instance
   */
  static create(
    properties?: replit$goval$api$IReadVCR
  ): replit$goval$api$ReadVCR;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReadVCR message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ReadVCR,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReadVCR message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ReadVCR,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReadVCR message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReadVCR
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ReadVCR;

  /**
   * Decodes a ReadVCR message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReadVCR
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ReadVCR;

  /**
   * Verifies a ReadVCR message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReadVCR message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReadVCR
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ReadVCR;

  /**
   * Creates a plain object from a ReadVCR message. Also converts values to other types if specified.
   * @param message ReadVCR
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ReadVCR,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReadVCR to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a VCRLog.
 */
declare type replit$goval$api$IVCRLog = {|
  /**
   * VCRLog log
   */
  log?: (replit$goval$api$VCREntry | replit$goval$api$IVCREntry)[] | null,

  /**
   * VCRLog logfile
   */
  logfile?: replit$goval$api$File | replit$goval$api$IFile | null,
|};

/**
 * Represents a VCRLog.
 */
declare class replit$goval$api$VCRLog {
  /**
   * Constructs a new VCRLog.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IVCRLog): this;

  /**
   * VCRLog log.
   */
  log: replit$goval$api$VCREntry[];

  /**
   * VCRLog logfile.
   */
  logfile?: replit$goval$api$File | null;

  /**
   * Creates a new VCRLog instance using the specified properties.
   * @param [properties] Properties to set
   * @returns VCRLog instance
   */
  static create(properties?: replit$goval$api$IVCRLog): replit$goval$api$VCRLog;

  /**
   * [object Object],[object Object],[object Object]
   * @param message VCRLog message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$VCRLog,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message VCRLog message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$VCRLog,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a VCRLog message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns VCRLog
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$VCRLog;

  /**
   * Decodes a VCRLog message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns VCRLog
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$VCRLog;

  /**
   * Verifies a VCRLog message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a VCRLog message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns VCRLog
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$VCRLog;

  /**
   * Creates a plain object from a VCRLog message. Also converts values to other types if specified.
   * @param message VCRLog
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$VCRLog,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this VCRLog to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an ExecInfo.
 */
declare type replit$goval$api$IExecInfo = {|
  /**
   * ExecInfo command
   */
  command?: string[] | null,

  /**
   * ExecInfo reason
   */
  reason?: string | null,
|};

/**
 * Represents an ExecInfo.
 */
declare class replit$goval$api$ExecInfo {
  /**
   * Constructs a new ExecInfo.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IExecInfo): this;

  /**
   * ExecInfo command.
   */
  command: string[];

  /**
   * ExecInfo reason.
   */
  reason: string;

  /**
   * Creates a new ExecInfo instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ExecInfo instance
   */
  static create(
    properties?: replit$goval$api$IExecInfo
  ): replit$goval$api$ExecInfo;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ExecInfo message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ExecInfo,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ExecInfo message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ExecInfo,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an ExecInfo message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ExecInfo
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ExecInfo;

  /**
   * Decodes an ExecInfo message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ExecInfo
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ExecInfo;

  /**
   * Verifies an ExecInfo message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an ExecInfo message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ExecInfo
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ExecInfo;

  /**
   * Creates a plain object from an ExecInfo message. Also converts values to other types if specified.
   * @param message ExecInfo
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ExecInfo,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ExecInfo to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Debug.
 */
declare type replit$goval$api$IDebug = {|
  /**
   * Debug text
   */
  text?: string | null,
|};

/**
 * Represents a Debug.
 */
declare class replit$goval$api$Debug {
  /**
   * Constructs a new Debug.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDebug): this;

  /**
   * Debug text.
   */
  text: string;

  /**
   * Creates a new Debug instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Debug instance
   */
  static create(properties?: replit$goval$api$IDebug): replit$goval$api$Debug;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Debug message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Debug,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Debug message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Debug,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Debug message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Debug
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Debug;

  /**
   * Decodes a Debug message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Debug
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Debug;

  /**
   * Verifies a Debug message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Debug message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Debug
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Debug;

  /**
   * Creates a plain object from a Debug message. Also converts values to other types if specified.
   * @param message Debug
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Debug,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Debug to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * FileAuthMethod enum.
 */

declare var replit$goval$api$FileAuthMethod: {|
  +GET: 0, // 0
  +HEAD: 1, // 1
  +PUT: 2, // 2
  +DELETE: 3, // 3
|};

/**
 * Properties of a FileAuthReq.
 */
declare type replit$goval$api$IFileAuthReq = {|
  /**
   * FileAuthReq file
   */
  file?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * FileAuthReq method
   */
  method?: $Values<typeof replit$goval$api$FileAuthMethod> | null,
|};

/**
 * Represents a FileAuthReq.
 */
declare class replit$goval$api$FileAuthReq {
  /**
   * Constructs a new FileAuthReq.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IFileAuthReq): this;

  /**
   * FileAuthReq file.
   */
  file?: replit$goval$api$File | null;

  /**
   * FileAuthReq method.
   */
  method: $Values<typeof replit$goval$api$FileAuthMethod>;

  /**
   * Creates a new FileAuthReq instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FileAuthReq instance
   */
  static create(
    properties?: replit$goval$api$IFileAuthReq
  ): replit$goval$api$FileAuthReq;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileAuthReq message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$FileAuthReq,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileAuthReq message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$FileAuthReq,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FileAuthReq message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FileAuthReq
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$FileAuthReq;

  /**
   * Decodes a FileAuthReq message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FileAuthReq
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$FileAuthReq;

  /**
   * Verifies a FileAuthReq message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FileAuthReq message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FileAuthReq
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$FileAuthReq;

  /**
   * Creates a plain object from a FileAuthReq message. Also converts values to other types if specified.
   * @param message FileAuthReq
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$FileAuthReq,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FileAuthReq to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a MultiFileAuthRes.
 */
declare type replit$goval$api$IMultiFileAuthRes = {|
  /**
   * MultiFileAuthRes put
   */
  put?: replit$goval$api$FileAuthRes | replit$goval$api$IFileAuthRes | null,

  /**
   * MultiFileAuthRes del
   */
  del?: replit$goval$api$FileAuthRes | replit$goval$api$IFileAuthRes | null,

  /**
   * MultiFileAuthRes get
   */
  get?: replit$goval$api$FileAuthRes | replit$goval$api$IFileAuthRes | null,
|};

/**
 * Represents a MultiFileAuthRes.
 */
declare class replit$goval$api$MultiFileAuthRes {
  /**
   * Constructs a new MultiFileAuthRes.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IMultiFileAuthRes): this;

  /**
   * MultiFileAuthRes put.
   */
  put?: replit$goval$api$FileAuthRes | null;

  /**
   * MultiFileAuthRes del.
   */
  del?: replit$goval$api$FileAuthRes | null;

  /**
   * MultiFileAuthRes get.
   */
  get?: replit$goval$api$FileAuthRes | null;

  /**
   * Creates a new MultiFileAuthRes instance using the specified properties.
   * @param [properties] Properties to set
   * @returns MultiFileAuthRes instance
   */
  static create(
    properties?: replit$goval$api$IMultiFileAuthRes
  ): replit$goval$api$MultiFileAuthRes;

  /**
   * [object Object],[object Object],[object Object]
   * @param message MultiFileAuthRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$MultiFileAuthRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message MultiFileAuthRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$MultiFileAuthRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a MultiFileAuthRes message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns MultiFileAuthRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$MultiFileAuthRes;

  /**
   * Decodes a MultiFileAuthRes message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns MultiFileAuthRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$MultiFileAuthRes;

  /**
   * Verifies a MultiFileAuthRes message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a MultiFileAuthRes message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns MultiFileAuthRes
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$MultiFileAuthRes;

  /**
   * Creates a plain object from a MultiFileAuthRes message. Also converts values to other types if specified.
   * @param message MultiFileAuthRes
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$MultiFileAuthRes,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this MultiFileAuthRes to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FileAuthRes.
 */
declare type replit$goval$api$IFileAuthRes = {|
  /**
   * FileAuthRes file
   */
  file?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * FileAuthRes url
   */
  url?: string | null,

  /**
   * FileAuthRes method
   */
  method?: $Values<typeof replit$goval$api$FileAuthMethod> | null,

  /**
   * FileAuthRes expire
   */
  expire?: number | null,

  /**
   * FileAuthRes error
   */
  error?: string | null,

  /**
   * FileAuthRes replError
   */
  replError?: boolean | null,
|};

/**
 * Represents a FileAuthRes.
 */
declare class replit$goval$api$FileAuthRes {
  /**
   * Constructs a new FileAuthRes.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IFileAuthRes): this;

  /**
   * FileAuthRes file.
   */
  file?: replit$goval$api$File | null;

  /**
   * FileAuthRes url.
   */
  url: string;

  /**
   * FileAuthRes method.
   */
  method: $Values<typeof replit$goval$api$FileAuthMethod>;

  /**
   * FileAuthRes expire.
   */
  expire: number;

  /**
   * FileAuthRes error.
   */
  error: string;

  /**
   * FileAuthRes replError.
   */
  replError: boolean;

  /**
   * Creates a new FileAuthRes instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FileAuthRes instance
   */
  static create(
    properties?: replit$goval$api$IFileAuthRes
  ): replit$goval$api$FileAuthRes;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileAuthRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$FileAuthRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileAuthRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$FileAuthRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FileAuthRes message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FileAuthRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$FileAuthRes;

  /**
   * Decodes a FileAuthRes message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FileAuthRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$FileAuthRes;

  /**
   * Verifies a FileAuthRes message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FileAuthRes message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FileAuthRes
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$FileAuthRes;

  /**
   * Creates a plain object from a FileAuthRes message. Also converts values to other types if specified.
   * @param message FileAuthRes
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$FileAuthRes,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FileAuthRes to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ListObjects.
 */
declare type replit$goval$api$IListObjects = {|
  /**
   * ListObjects prefix
   */
  prefix?: string | null,
|};

/**
 * Represents a ListObjects.
 */
declare class replit$goval$api$ListObjects {
  /**
   * Constructs a new ListObjects.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IListObjects): this;

  /**
   * ListObjects prefix.
   */
  prefix: string;

  /**
   * Creates a new ListObjects instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ListObjects instance
   */
  static create(
    properties?: replit$goval$api$IListObjects
  ): replit$goval$api$ListObjects;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ListObjects message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ListObjects,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ListObjects message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ListObjects,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ListObjects message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ListObjects
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ListObjects;

  /**
   * Decodes a ListObjects message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ListObjects
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ListObjects;

  /**
   * Verifies a ListObjects message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ListObjects message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ListObjects
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ListObjects;

  /**
   * Creates a plain object from a ListObjects message. Also converts values to other types if specified.
   * @param message ListObjects
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ListObjects,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ListObjects to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ListObjectsResp.
 */
declare type replit$goval$api$IListObjectsResp = {|
  /**
   * ListObjectsResp objects
   */
  objects?: string[] | null,
|};

/**
 * Represents a ListObjectsResp.
 */
declare class replit$goval$api$ListObjectsResp {
  /**
   * Constructs a new ListObjectsResp.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IListObjectsResp): this;

  /**
   * ListObjectsResp objects.
   */
  objects: string[];

  /**
   * Creates a new ListObjectsResp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ListObjectsResp instance
   */
  static create(
    properties?: replit$goval$api$IListObjectsResp
  ): replit$goval$api$ListObjectsResp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ListObjectsResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ListObjectsResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ListObjectsResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ListObjectsResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ListObjectsResp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ListObjectsResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ListObjectsResp;

  /**
   * Decodes a ListObjectsResp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ListObjectsResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ListObjectsResp;

  /**
   * Verifies a ListObjectsResp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ListObjectsResp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ListObjectsResp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ListObjectsResp;

  /**
   * Creates a plain object from a ListObjectsResp message. Also converts values to other types if specified.
   * @param message ListObjectsResp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ListObjectsResp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ListObjectsResp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Disconnect.
 */
declare type replit$goval$api$IDisconnect = {|
  /**
   * Disconnect error
   */
  error?: string | null,
|};

/**
 * Represents a Disconnect.
 */
declare class replit$goval$api$Disconnect {
  /**
   * Constructs a new Disconnect.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDisconnect): this;

  /**
   * Disconnect error.
   */
  error: string;

  /**
   * Creates a new Disconnect instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Disconnect instance
   */
  static create(
    properties?: replit$goval$api$IDisconnect
  ): replit$goval$api$Disconnect;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Disconnect message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Disconnect,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Disconnect message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Disconnect,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Disconnect message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Disconnect
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Disconnect;

  /**
   * Decodes a Disconnect message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Disconnect
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Disconnect;

  /**
   * Verifies a Disconnect message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Disconnect message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Disconnect
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Disconnect;

  /**
   * Creates a plain object from a Disconnect message. Also converts values to other types if specified.
   * @param message Disconnect
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Disconnect,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Disconnect to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Send.
 */
declare type replit$goval$api$ISend = {|
  /**
   * Send buff
   */
  buff?: Uint8Array | null,
|};

/**
 * Represents a Send.
 */
declare class replit$goval$api$Send {
  /**
   * Constructs a new Send.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ISend): this;

  /**
   * Send buff.
   */
  buff: Uint8Array;

  /**
   * Creates a new Send instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Send instance
   */
  static create(properties?: replit$goval$api$ISend): replit$goval$api$Send;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Send message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Send,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Send message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Send,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Send message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Send
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Send;

  /**
   * Decodes a Send message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Send
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Send;

  /**
   * Verifies a Send message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Send message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Send
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Send;

  /**
   * Creates a plain object from a Send message. Also converts values to other types if specified.
   * @param message Send
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Send,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Send to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Recv.
 */
declare type replit$goval$api$IRecv = {|
  /**
   * Recv buff
   */
  buff?: Uint8Array | null,
|};

/**
 * Represents a Recv.
 */
declare class replit$goval$api$Recv {
  /**
   * Constructs a new Recv.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IRecv): this;

  /**
   * Recv buff.
   */
  buff: Uint8Array;

  /**
   * Creates a new Recv instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Recv instance
   */
  static create(properties?: replit$goval$api$IRecv): replit$goval$api$Recv;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Recv message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Recv,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Recv message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Recv,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Recv message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Recv
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Recv;

  /**
   * Decodes a Recv message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Recv
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Recv;

  /**
   * Verifies a Recv message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Recv message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Recv
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Recv;

  /**
   * Creates a plain object from a Recv message. Also converts values to other types if specified.
   * @param message Recv
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Recv,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Recv to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Connect.
 */
declare type replit$goval$api$IConnect = {|
  /**
   * Connect proto
   */
  proto?: string | null,

  /**
   * Connect addr
   */
  addr?: string | null,
|};

/**
 * Represents a Connect.
 */
declare class replit$goval$api$Connect {
  /**
   * Constructs a new Connect.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IConnect): this;

  /**
   * Connect proto.
   */
  proto: string;

  /**
   * Connect addr.
   */
  addr: string;

  /**
   * Creates a new Connect instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Connect instance
   */
  static create(
    properties?: replit$goval$api$IConnect
  ): replit$goval$api$Connect;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Connect message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Connect,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Connect message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Connect,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Connect message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Connect
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Connect;

  /**
   * Decodes a Connect message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Connect
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Connect;

  /**
   * Verifies a Connect message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Connect message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Connect
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Connect;

  /**
   * Creates a plain object from a Connect message. Also converts values to other types if specified.
   * @param message Connect
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Connect,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Connect to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Hint.
 */
declare type replit$goval$api$IHint = {|
  /**
   * Hint text
   */
  text?: string | null,
|};

/**
 * Represents a Hint.
 */
declare class replit$goval$api$Hint {
  /**
   * Constructs a new Hint.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IHint): this;

  /**
   * Hint text.
   */
  text: string;

  /**
   * Creates a new Hint instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Hint instance
   */
  static create(properties?: replit$goval$api$IHint): replit$goval$api$Hint;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Hint message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Hint,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Hint message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Hint,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Hint message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Hint
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Hint;

  /**
   * Decodes a Hint message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Hint
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Hint;

  /**
   * Verifies a Hint message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Hint message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Hint
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Hint;

  /**
   * Creates a plain object from a Hint message. Also converts values to other types if specified.
   * @param message Hint
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Hint,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Hint to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Ping.
 */
declare type replit$goval$api$IPing = {||};

/**
 * Represents a Ping.
 */
declare class replit$goval$api$Ping {
  /**
   * Constructs a new Ping.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPing): this;

  /**
   * Creates a new Ping instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Ping instance
   */
  static create(properties?: replit$goval$api$IPing): replit$goval$api$Ping;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Ping message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Ping,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Ping message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Ping,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Ping message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Ping
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Ping;

  /**
   * Decodes a Ping message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Ping
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Ping;

  /**
   * Verifies a Ping message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Ping message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Ping
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Ping;

  /**
   * Creates a plain object from a Ping message. Also converts values to other types if specified.
   * @param message Ping
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Ping,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Ping to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Pong.
 */
declare type replit$goval$api$IPong = {||};

/**
 * Represents a Pong.
 */
declare class replit$goval$api$Pong {
  /**
   * Constructs a new Pong.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPong): this;

  /**
   * Creates a new Pong instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Pong instance
   */
  static create(properties?: replit$goval$api$IPong): replit$goval$api$Pong;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Pong message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Pong,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Pong message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Pong,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Pong message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Pong
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Pong;

  /**
   * Decodes a Pong message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Pong
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Pong;

  /**
   * Verifies a Pong message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Pong message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Pong
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Pong;

  /**
   * Creates a plain object from a Pong message. Also converts values to other types if specified.
   * @param message Pong
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Pong,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Pong to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Hello.
 */
declare type replit$goval$api$IHello = {|
  /**
   * Hello userid
   */
  userid?: number | null,

  /**
   * Hello username
   */
  username?: string | null,

  /**
   * Hello token
   */
  token?: string | null,
|};

/**
 * Represents a Hello.
 */
declare class replit$goval$api$Hello {
  /**
   * Constructs a new Hello.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IHello): this;

  /**
   * Hello userid.
   */
  userid: number;

  /**
   * Hello username.
   */
  username: string;

  /**
   * Hello token.
   */
  token: string;

  /**
   * Creates a new Hello instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Hello instance
   */
  static create(properties?: replit$goval$api$IHello): replit$goval$api$Hello;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Hello message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Hello,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Hello message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Hello,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Hello message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Hello
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Hello;

  /**
   * Decodes a Hello message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Hello
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Hello;

  /**
   * Verifies a Hello message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Hello message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Hello
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Hello;

  /**
   * Creates a plain object from a Hello message. Also converts values to other types if specified.
   * @param message Hello
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Hello,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Hello to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Goodbye.
 */
declare type replit$goval$api$IGoodbye = {||};

/**
 * Represents a Goodbye.
 */
declare class replit$goval$api$Goodbye {
  /**
   * Constructs a new Goodbye.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IGoodbye): this;

  /**
   * Creates a new Goodbye instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Goodbye instance
   */
  static create(
    properties?: replit$goval$api$IGoodbye
  ): replit$goval$api$Goodbye;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Goodbye message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Goodbye,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Goodbye message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Goodbye,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Goodbye message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Goodbye
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Goodbye;

  /**
   * Decodes a Goodbye message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Goodbye
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Goodbye;

  /**
   * Verifies a Goodbye message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Goodbye message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Goodbye
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Goodbye;

  /**
   * Creates a plain object from a Goodbye message. Also converts values to other types if specified.
   * @param message Goodbye
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Goodbye,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Goodbye to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * State enum.
 */

declare var replit$goval$api$State: {|
  +Stopped: 0, // 0
  +Running: 1, // 1
|};

/**
 * Properties of a CheckChanges.
 */
declare type replit$goval$api$ICheckChanges = {||};

/**
 * Represents a CheckChanges.
 */
declare class replit$goval$api$CheckChanges {
  /**
   * Constructs a new CheckChanges.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ICheckChanges): this;

  /**
   * Creates a new CheckChanges instance using the specified properties.
   * @param [properties] Properties to set
   * @returns CheckChanges instance
   */
  static create(
    properties?: replit$goval$api$ICheckChanges
  ): replit$goval$api$CheckChanges;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CheckChanges message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$CheckChanges,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CheckChanges message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$CheckChanges,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a CheckChanges message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns CheckChanges
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$CheckChanges;

  /**
   * Decodes a CheckChanges message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns CheckChanges
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$CheckChanges;

  /**
   * Verifies a CheckChanges message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a CheckChanges message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns CheckChanges
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$CheckChanges;

  /**
   * Creates a plain object from a CheckChanges message. Also converts values to other types if specified.
   * @param message CheckChanges
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$CheckChanges,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this CheckChanges to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an EnsurePackages.
 */
declare type replit$goval$api$IEnsurePackages = {|
  /**
   * EnsurePackages install
   */
  install?: boolean | null,

  /**
   * EnsurePackages file
   */
  file?: replit$goval$api$File | replit$goval$api$IFile | null,
|};

/**
 * Represents an EnsurePackages.
 */
declare class replit$goval$api$EnsurePackages {
  /**
   * Constructs a new EnsurePackages.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IEnsurePackages): this;

  /**
   * EnsurePackages install.
   */
  install: boolean;

  /**
   * EnsurePackages file.
   */
  file?: replit$goval$api$File | null;

  /**
   * Creates a new EnsurePackages instance using the specified properties.
   * @param [properties] Properties to set
   * @returns EnsurePackages instance
   */
  static create(
    properties?: replit$goval$api$IEnsurePackages
  ): replit$goval$api$EnsurePackages;

  /**
   * [object Object],[object Object],[object Object]
   * @param message EnsurePackages message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$EnsurePackages,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message EnsurePackages message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$EnsurePackages,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an EnsurePackages message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns EnsurePackages
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$EnsurePackages;

  /**
   * Decodes an EnsurePackages message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns EnsurePackages
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$EnsurePackages;

  /**
   * Verifies an EnsurePackages message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an EnsurePackages message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns EnsurePackages
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$EnsurePackages;

  /**
   * Creates a plain object from an EnsurePackages message. Also converts values to other types if specified.
   * @param message EnsurePackages
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$EnsurePackages,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this EnsurePackages to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Start.
 */
declare type replit$goval$api$IStart = {||};

/**
 * Represents a Start.
 */
declare class replit$goval$api$Start {
  /**
   * Constructs a new Start.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IStart): this;

  /**
   * Creates a new Start instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Start instance
   */
  static create(properties?: replit$goval$api$IStart): replit$goval$api$Start;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Start message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Start,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Start message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Start,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Start message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Start
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Start;

  /**
   * Decodes a Start message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Start
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Start;

  /**
   * Verifies a Start message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Start message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Start
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Start;

  /**
   * Creates a plain object from a Start message. Also converts values to other types if specified.
   * @param message Start
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Start,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Start to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugStatus.
 */
declare type replit$goval$api$IDebugStatus = {|
  /**
   * DebugStatus done
   */
  done?: boolean | null,

  /**
   * DebugStatus stack
   */
  stack?: (replit$goval$api$StackFrame | replit$goval$api$IStackFrame)[] | null,
|};

/**
 * Represents a DebugStatus.
 */
declare class replit$goval$api$DebugStatus {
  /**
   * Constructs a new DebugStatus.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDebugStatus): this;

  /**
   * DebugStatus done.
   */
  done: boolean;

  /**
   * DebugStatus stack.
   */
  stack: replit$goval$api$StackFrame[];

  /**
   * Creates a new DebugStatus instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugStatus instance
   */
  static create(
    properties?: replit$goval$api$IDebugStatus
  ): replit$goval$api$DebugStatus;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugStatus message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DebugStatus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugStatus message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DebugStatus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugStatus message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugStatus
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DebugStatus;

  /**
   * Decodes a DebugStatus message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugStatus
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DebugStatus;

  /**
   * Verifies a DebugStatus message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugStatus message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugStatus
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DebugStatus;

  /**
   * Creates a plain object from a DebugStatus message. Also converts values to other types if specified.
   * @param message DebugStatus
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DebugStatus,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugStatus to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a StackFrame.
 */
declare type replit$goval$api$IStackFrame = {|
  /**
   * StackFrame function
   */
  function?: string | null,

  /**
   * StackFrame line
   */
  line?: number | null,
|};

/**
 * Represents a StackFrame.
 */
declare class replit$goval$api$StackFrame {
  /**
   * Constructs a new StackFrame.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IStackFrame): this;

  /**
   * StackFrame function.
   */
  function: string;

  /**
   * StackFrame line.
   */
  line: number;

  /**
   * Creates a new StackFrame instance using the specified properties.
   * @param [properties] Properties to set
   * @returns StackFrame instance
   */
  static create(
    properties?: replit$goval$api$IStackFrame
  ): replit$goval$api$StackFrame;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StackFrame message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$StackFrame,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StackFrame message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$StackFrame,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a StackFrame message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns StackFrame
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$StackFrame;

  /**
   * Decodes a StackFrame message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns StackFrame
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$StackFrame;

  /**
   * Verifies a StackFrame message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a StackFrame message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns StackFrame
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$StackFrame;

  /**
   * Creates a plain object from a StackFrame message. Also converts values to other types if specified.
   * @param message StackFrame
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$StackFrame,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this StackFrame to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ContainedTest.
 */
declare type replit$goval$api$IContainedTest = {|
  /**
   * ContainedTest suite
   */
  suite?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * ContainedTest project
   */
  project?: (replit$goval$api$File | replit$goval$api$IFile)[] | null,
|};

/**
 * Represents a ContainedTest.
 */
declare class replit$goval$api$ContainedTest {
  /**
   * Constructs a new ContainedTest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IContainedTest): this;

  /**
   * ContainedTest suite.
   */
  suite?: replit$goval$api$File | null;

  /**
   * ContainedTest project.
   */
  project: replit$goval$api$File[];

  /**
   * Creates a new ContainedTest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ContainedTest instance
   */
  static create(
    properties?: replit$goval$api$IContainedTest
  ): replit$goval$api$ContainedTest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ContainedTest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ContainedTest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ContainedTest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ContainedTest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ContainedTest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ContainedTest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ContainedTest;

  /**
   * Decodes a ContainedTest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ContainedTest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ContainedTest;

  /**
   * Verifies a ContainedTest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ContainedTest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ContainedTest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ContainedTest;

  /**
   * Creates a plain object from a ContainedTest message. Also converts values to other types if specified.
   * @param message ContainedTest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ContainedTest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ContainedTest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a TestResult.
 */
declare type replit$goval$api$ITestResult = {|
  /**
   * TestResult passed
   */
  passed?: boolean | null,

  /**
   * TestResult stderr
   */
  stderr?: string | null,

  /**
   * TestResult fails
   */
  fails?:
    | (replit$goval$api$TestFailure | replit$goval$api$ITestFailure)[]
    | null,
|};

/**
 * Represents a TestResult.
 */
declare class replit$goval$api$TestResult {
  /**
   * Constructs a new TestResult.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ITestResult): this;

  /**
   * TestResult passed.
   */
  passed: boolean;

  /**
   * TestResult stderr.
   */
  stderr: string;

  /**
   * TestResult fails.
   */
  fails: replit$goval$api$TestFailure[];

  /**
   * Creates a new TestResult instance using the specified properties.
   * @param [properties] Properties to set
   * @returns TestResult instance
   */
  static create(
    properties?: replit$goval$api$ITestResult
  ): replit$goval$api$TestResult;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TestResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$TestResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TestResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$TestResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a TestResult message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns TestResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$TestResult;

  /**
   * Decodes a TestResult message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns TestResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$TestResult;

  /**
   * Verifies a TestResult message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a TestResult message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns TestResult
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$TestResult;

  /**
   * Creates a plain object from a TestResult message. Also converts values to other types if specified.
   * @param message TestResult
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$TestResult,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this TestResult to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a TestFailure.
 */
declare type replit$goval$api$ITestFailure = {|
  /**
   * TestFailure name
   */
  name?: string | null,

  /**
   * TestFailure trace
   */
  trace?: string | null,
|};

/**
 * Represents a TestFailure.
 */
declare class replit$goval$api$TestFailure {
  /**
   * Constructs a new TestFailure.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ITestFailure): this;

  /**
   * TestFailure name.
   */
  name: string;

  /**
   * TestFailure trace.
   */
  trace: string;

  /**
   * Creates a new TestFailure instance using the specified properties.
   * @param [properties] Properties to set
   * @returns TestFailure instance
   */
  static create(
    properties?: replit$goval$api$ITestFailure
  ): replit$goval$api$TestFailure;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TestFailure message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$TestFailure,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TestFailure message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$TestFailure,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a TestFailure message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns TestFailure
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$TestFailure;

  /**
   * Decodes a TestFailure message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns TestFailure
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$TestFailure;

  /**
   * Verifies a TestFailure message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a TestFailure message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns TestFailure
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$TestFailure;

  /**
   * Creates a plain object from a TestFailure message. Also converts values to other types if specified.
   * @param message TestFailure
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$TestFailure,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this TestFailure to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ResizeTerm.
 */
declare type replit$goval$api$IResizeTerm = {|
  /**
   * ResizeTerm rows
   */
  rows?: number | null,

  /**
   * ResizeTerm cols
   */
  cols?: number | null,
|};

/**
 * Represents a ResizeTerm.
 */
declare class replit$goval$api$ResizeTerm {
  /**
   * Constructs a new ResizeTerm.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IResizeTerm): this;

  /**
   * ResizeTerm rows.
   */
  rows: number;

  /**
   * ResizeTerm cols.
   */
  cols: number;

  /**
   * Creates a new ResizeTerm instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ResizeTerm instance
   */
  static create(
    properties?: replit$goval$api$IResizeTerm
  ): replit$goval$api$ResizeTerm;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ResizeTerm message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ResizeTerm,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ResizeTerm message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ResizeTerm,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ResizeTerm message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ResizeTerm
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ResizeTerm;

  /**
   * Decodes a ResizeTerm message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ResizeTerm
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ResizeTerm;

  /**
   * Verifies a ResizeTerm message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ResizeTerm message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ResizeTerm
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ResizeTerm;

  /**
   * Creates a plain object from a ResizeTerm message. Also converts values to other types if specified.
   * @param message ResizeTerm
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ResizeTerm,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ResizeTerm to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a SaneTerm.
 */
declare type replit$goval$api$ISaneTerm = {||};

/**
 * Represents a SaneTerm.
 */
declare class replit$goval$api$SaneTerm {
  /**
   * Constructs a new SaneTerm.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ISaneTerm): this;

  /**
   * Creates a new SaneTerm instance using the specified properties.
   * @param [properties] Properties to set
   * @returns SaneTerm instance
   */
  static create(
    properties?: replit$goval$api$ISaneTerm
  ): replit$goval$api$SaneTerm;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SaneTerm message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$SaneTerm,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SaneTerm message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$SaneTerm,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a SaneTerm message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns SaneTerm
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$SaneTerm;

  /**
   * Decodes a SaneTerm message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns SaneTerm
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$SaneTerm;

  /**
   * Verifies a SaneTerm message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a SaneTerm message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns SaneTerm
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$SaneTerm;

  /**
   * Creates a plain object from a SaneTerm message. Also converts values to other types if specified.
   * @param message SaneTerm
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$SaneTerm,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this SaneTerm to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a LintResults.
 */
declare type replit$goval$api$ILintResults = {|
  /**
   * LintResults results
   */
  results?:
    | (replit$goval$api$LintResult | replit$goval$api$ILintResult)[]
    | null,
|};

/**
 * Represents a LintResults.
 */
declare class replit$goval$api$LintResults {
  /**
   * Constructs a new LintResults.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ILintResults): this;

  /**
   * LintResults results.
   */
  results: replit$goval$api$LintResult[];

  /**
   * Creates a new LintResults instance using the specified properties.
   * @param [properties] Properties to set
   * @returns LintResults instance
   */
  static create(
    properties?: replit$goval$api$ILintResults
  ): replit$goval$api$LintResults;

  /**
   * [object Object],[object Object],[object Object]
   * @param message LintResults message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$LintResults,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message LintResults message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$LintResults,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a LintResults message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns LintResults
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$LintResults;

  /**
   * Decodes a LintResults message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns LintResults
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$LintResults;

  /**
   * Verifies a LintResults message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a LintResults message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns LintResults
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$LintResults;

  /**
   * Creates a plain object from a LintResults message. Also converts values to other types if specified.
   * @param message LintResults
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$LintResults,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this LintResults to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a LintResult.
 */
declare type replit$goval$api$ILintResult = {|
  /**
   * LintResult text
   */
  text?: string | null,

  /**
   * LintResult row
   */
  row?: number | null,

  /**
   * LintResult column
   */
  column?: number | null,

  /**
   * LintResult type
   */
  type?: string | null,
|};

/**
 * Represents a LintResult.
 */
declare class replit$goval$api$LintResult {
  /**
   * Constructs a new LintResult.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ILintResult): this;

  /**
   * LintResult text.
   */
  text: string;

  /**
   * LintResult row.
   */
  row: number;

  /**
   * LintResult column.
   */
  column: number;

  /**
   * LintResult type.
   */
  type: string;

  /**
   * Creates a new LintResult instance using the specified properties.
   * @param [properties] Properties to set
   * @returns LintResult instance
   */
  static create(
    properties?: replit$goval$api$ILintResult
  ): replit$goval$api$LintResult;

  /**
   * [object Object],[object Object],[object Object]
   * @param message LintResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$LintResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message LintResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$LintResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a LintResult message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns LintResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$LintResult;

  /**
   * Decodes a LintResult message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns LintResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$LintResult;

  /**
   * Verifies a LintResult message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a LintResult message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns LintResult
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$LintResult;

  /**
   * Creates a plain object from a LintResult message. Also converts values to other types if specified.
   * @param message LintResult
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$LintResult,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this LintResult to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OK.
 */
declare type replit$goval$api$IOK = {||};

/**
 * Represents a OK.
 */
declare class replit$goval$api$OK {
  /**
   * Constructs a new OK.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IOK): this;

  /**
   * Creates a new OK instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OK instance
   */
  static create(properties?: replit$goval$api$IOK): replit$goval$api$OK;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OK message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$OK,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OK message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$OK,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OK message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OK
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$OK;

  /**
   * Decodes a OK message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OK
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$OK;

  /**
   * Verifies a OK message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OK message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OK
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$OK;

  /**
   * Creates a plain object from a OK message. Also converts values to other types if specified.
   * @param message OK
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$OK,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OK to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Move.
 */
declare type replit$goval$api$IMove = {|
  /**
   * Move oldPath
   */
  oldPath?: string | null,

  /**
   * Move newPath
   */
  newPath?: string | null,
|};

/**
 * Represents a Move.
 */
declare class replit$goval$api$Move {
  /**
   * Constructs a new Move.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IMove): this;

  /**
   * Move oldPath.
   */
  oldPath: string;

  /**
   * Move newPath.
   */
  newPath: string;

  /**
   * Creates a new Move instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Move instance
   */
  static create(properties?: replit$goval$api$IMove): replit$goval$api$Move;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Move message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Move,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Move message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Move,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Move message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Move
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Move;

  /**
   * Decodes a Move message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Move
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Move;

  /**
   * Verifies a Move message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Move message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Move
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Move;

  /**
   * Creates a plain object from a Move message. Also converts values to other types if specified.
   * @param message Move
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Move,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Move to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Files.
 */
declare type replit$goval$api$IFiles = {|
  /**
   * Files files
   */
  files?: (replit$goval$api$File | replit$goval$api$IFile)[] | null,
|};

/**
 * Represents a Files.
 */
declare class replit$goval$api$Files {
  /**
   * Constructs a new Files.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IFiles): this;

  /**
   * Files files.
   */
  files: replit$goval$api$File[];

  /**
   * Creates a new Files instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Files instance
   */
  static create(properties?: replit$goval$api$IFiles): replit$goval$api$Files;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Files message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Files,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Files message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Files,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Files message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Files
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Files;

  /**
   * Decodes a Files message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Files
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Files;

  /**
   * Verifies a Files message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Files message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Files
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Files;

  /**
   * Creates a plain object from a Files message. Also converts values to other types if specified.
   * @param message Files
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Files,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Files to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a StatResult.
 */
declare type replit$goval$api$IStatResult = {|
  /**
   * StatResult exists
   */
  exists?: boolean | null,

  /**
   * StatResult type
   */
  type?: $Values<typeof replit$goval$api$File$Type> | null,

  /**
   * StatResult size
   */
  size?: number | null,

  /**
   * StatResult fileMode
   */
  fileMode?: string | null,

  /**
   * StatResult modTime
   */
  modTime?: number | null,
|};

/**
 * Represents a StatResult.
 */
declare class replit$goval$api$StatResult {
  /**
   * Constructs a new StatResult.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IStatResult): this;

  /**
   * StatResult exists.
   */
  exists: boolean;

  /**
   * StatResult type.
   */
  type: $Values<typeof replit$goval$api$File$Type>;

  /**
   * StatResult size.
   */
  size: number;

  /**
   * StatResult fileMode.
   */
  fileMode: string;

  /**
   * StatResult modTime.
   */
  modTime: number;

  /**
   * Creates a new StatResult instance using the specified properties.
   * @param [properties] Properties to set
   * @returns StatResult instance
   */
  static create(
    properties?: replit$goval$api$IStatResult
  ): replit$goval$api$StatResult;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StatResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$StatResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StatResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$StatResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a StatResult message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns StatResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$StatResult;

  /**
   * Decodes a StatResult message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns StatResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$StatResult;

  /**
   * Verifies a StatResult message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a StatResult message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns StatResult
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$StatResult;

  /**
   * Creates a plain object from a StatResult message. Also converts values to other types if specified.
   * @param message StatResult
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$StatResult,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this StatResult to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a File.
 */
declare type replit$goval$api$IFile = {|
  /**
   * File path
   */
  path?: string | null,

  /**
   * File type
   */
  type?: $Values<typeof replit$goval$api$File$Type> | null,

  /**
   * File content
   */
  content?: Uint8Array | null,
|};

/**
 * Represents a File.
 */
declare class replit$goval$api$File {
  /**
   * Constructs a new File.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IFile): this;

  /**
   * File path.
   */
  path: string;

  /**
   * File type.
   */
  type: $Values<typeof replit$goval$api$File$Type>;

  /**
   * File content.
   */
  content: Uint8Array;

  /**
   * Creates a new File instance using the specified properties.
   * @param [properties] Properties to set
   * @returns File instance
   */
  static create(properties?: replit$goval$api$IFile): replit$goval$api$File;

  /**
   * [object Object],[object Object],[object Object]
   * @param message File message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$File,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message File message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$File,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a File message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns File
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$File;

  /**
   * Decodes a File message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns File
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$File;

  /**
   * Verifies a File message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a File message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns File
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$File;

  /**
   * Creates a plain object from a File message. Also converts values to other types if specified.
   * @param message File
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$File,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this File to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Type: typeof replit$goval$api$File$Type;
}

/**
 * Type enum.
 */

declare var replit$goval$api$File$Type: {|
  +REGULAR: 0, // 0
  +DIRECTORY: 1, // 1
|};

/**
 * Properties of a Transfer.
 */
declare type replit$goval$api$ITransfer = {|
  /**
   * Transfer id
   */
  id?: string | null,
|};

/**
 * Represents a Transfer.
 */
declare class replit$goval$api$Transfer {
  /**
   * Constructs a new Transfer.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ITransfer): this;

  /**
   * Transfer id.
   */
  id: string;

  /**
   * Creates a new Transfer instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Transfer instance
   */
  static create(
    properties?: replit$goval$api$ITransfer
  ): replit$goval$api$Transfer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Transfer message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Transfer,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Transfer message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Transfer,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Transfer message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Transfer
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Transfer;

  /**
   * Decodes a Transfer message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Transfer
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Transfer;

  /**
   * Verifies a Transfer message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Transfer
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Transfer;

  /**
   * Creates a plain object from a Transfer message. Also converts values to other types if specified.
   * @param message Transfer
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Transfer,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Transfer to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a TransferStart.
 */
declare type replit$goval$api$ITransferStart = {|
  /**
   * TransferStart path
   */
  path?: string | null,

  /**
   * TransferStart size
   */
  size?: number | null,
|};

/**
 * Represents a TransferStart.
 */
declare class replit$goval$api$TransferStart {
  /**
   * Constructs a new TransferStart.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ITransferStart): this;

  /**
   * TransferStart path.
   */
  path: string;

  /**
   * TransferStart size.
   */
  size: number;

  /**
   * Creates a new TransferStart instance using the specified properties.
   * @param [properties] Properties to set
   * @returns TransferStart instance
   */
  static create(
    properties?: replit$goval$api$ITransferStart
  ): replit$goval$api$TransferStart;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TransferStart message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$TransferStart,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TransferStart message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$TransferStart,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a TransferStart message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns TransferStart
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$TransferStart;

  /**
   * Decodes a TransferStart message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns TransferStart
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$TransferStart;

  /**
   * Verifies a TransferStart message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a TransferStart message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns TransferStart
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$TransferStart;

  /**
   * Creates a plain object from a TransferStart message. Also converts values to other types if specified.
   * @param message TransferStart
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$TransferStart,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this TransferStart to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a TransferChunk.
 */
declare type replit$goval$api$ITransferChunk = {|
  /**
   * TransferChunk id
   */
  id?: string | null,

  /**
   * TransferChunk content
   */
  content?: Uint8Array | null,
|};

/**
 * Represents a TransferChunk.
 */
declare class replit$goval$api$TransferChunk {
  /**
   * Constructs a new TransferChunk.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ITransferChunk): this;

  /**
   * TransferChunk id.
   */
  id: string;

  /**
   * TransferChunk content.
   */
  content: Uint8Array;

  /**
   * Creates a new TransferChunk instance using the specified properties.
   * @param [properties] Properties to set
   * @returns TransferChunk instance
   */
  static create(
    properties?: replit$goval$api$ITransferChunk
  ): replit$goval$api$TransferChunk;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TransferChunk message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$TransferChunk,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TransferChunk message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$TransferChunk,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a TransferChunk message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns TransferChunk
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$TransferChunk;

  /**
   * Decodes a TransferChunk message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns TransferChunk
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$TransferChunk;

  /**
   * Verifies a TransferChunk message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a TransferChunk message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns TransferChunk
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$TransferChunk;

  /**
   * Creates a plain object from a TransferChunk message. Also converts values to other types if specified.
   * @param message TransferChunk
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$TransferChunk,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this TransferChunk to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a TransferComplete.
 */
declare type replit$goval$api$ITransferComplete = {|
  /**
   * TransferComplete id
   */
  id?: string | null,

  /**
   * TransferComplete crc32
   */
  crc32?: number | null,
|};

/**
 * Represents a TransferComplete.
 */
declare class replit$goval$api$TransferComplete {
  /**
   * Constructs a new TransferComplete.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ITransferComplete): this;

  /**
   * TransferComplete id.
   */
  id: string;

  /**
   * TransferComplete crc32.
   */
  crc32: number;

  /**
   * Creates a new TransferComplete instance using the specified properties.
   * @param [properties] Properties to set
   * @returns TransferComplete instance
   */
  static create(
    properties?: replit$goval$api$ITransferComplete
  ): replit$goval$api$TransferComplete;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TransferComplete message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$TransferComplete,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TransferComplete message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$TransferComplete,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a TransferComplete message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns TransferComplete
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$TransferComplete;

  /**
   * Decodes a TransferComplete message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns TransferComplete
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$TransferComplete;

  /**
   * Verifies a TransferComplete message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a TransferComplete message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns TransferComplete
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$TransferComplete;

  /**
   * Creates a plain object from a TransferComplete message. Also converts values to other types if specified.
   * @param message TransferComplete
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$TransferComplete,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this TransferComplete to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Clear.
 */
declare type replit$goval$api$IClear = {||};

/**
 * Represents a Clear.
 */
declare class replit$goval$api$Clear {
  /**
   * Constructs a new Clear.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IClear): this;

  /**
   * Creates a new Clear instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Clear instance
   */
  static create(properties?: replit$goval$api$IClear): replit$goval$api$Clear;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Clear message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Clear,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Clear message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Clear,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Clear message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Clear
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Clear;

  /**
   * Decodes a Clear message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Clear
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Clear;

  /**
   * Verifies a Clear message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Clear message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Clear
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Clear;

  /**
   * Creates a plain object from a Clear message. Also converts values to other types if specified.
   * @param message Clear
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Clear,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Clear to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Toast.
 */
declare type replit$goval$api$IToast = {|
  /**
   * Toast text
   */
  text?: string | null,
|};

/**
 * Represents a Toast.
 */
declare class replit$goval$api$Toast {
  /**
   * Constructs a new Toast.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IToast): this;

  /**
   * Toast text.
   */
  text: string;

  /**
   * Creates a new Toast instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Toast instance
   */
  static create(properties?: replit$goval$api$IToast): replit$goval$api$Toast;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Toast message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Toast,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Toast message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Toast,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Toast message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Toast
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Toast;

  /**
   * Decodes a Toast message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Toast
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Toast;

  /**
   * Verifies a Toast message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Toast message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Toast
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Toast;

  /**
   * Creates a plain object from a Toast message. Also converts values to other types if specified.
   * @param message Toast
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Toast,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Toast to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ProtocolError.
 */
declare type replit$goval$api$IProtocolError = {|
  /**
   * ProtocolError text
   */
  text?: string | null,
|};

/**
 * Represents a ProtocolError.
 */
declare class replit$goval$api$ProtocolError {
  /**
   * Constructs a new ProtocolError.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IProtocolError): this;

  /**
   * ProtocolError text.
   */
  text: string;

  /**
   * Creates a new ProtocolError instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ProtocolError instance
   */
  static create(
    properties?: replit$goval$api$IProtocolError
  ): replit$goval$api$ProtocolError;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ProtocolError message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ProtocolError,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ProtocolError message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ProtocolError,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ProtocolError message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ProtocolError
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ProtocolError;

  /**
   * Decodes a ProtocolError message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ProtocolError
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ProtocolError;

  /**
   * Verifies a ProtocolError message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ProtocolError message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ProtocolError
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ProtocolError;

  /**
   * Creates a plain object from a ProtocolError message. Also converts values to other types if specified.
   * @param message ProtocolError
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ProtocolError,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ProtocolError to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Redirect.
 */
declare type replit$goval$api$IRedirect = {|
  /**
   * Redirect url
   */
  url?: string | null,
|};

/**
 * Represents a Redirect.
 */
declare class replit$goval$api$Redirect {
  /**
   * Constructs a new Redirect.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IRedirect): this;

  /**
   * Redirect url.
   */
  url: string;

  /**
   * Creates a new Redirect instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Redirect instance
   */
  static create(
    properties?: replit$goval$api$IRedirect
  ): replit$goval$api$Redirect;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Redirect message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Redirect,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Redirect message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Redirect,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Redirect message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Redirect
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Redirect;

  /**
   * Decodes a Redirect message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Redirect
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Redirect;

  /**
   * Verifies a Redirect message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Redirect message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Redirect
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Redirect;

  /**
   * Creates a plain object from a Redirect message. Also converts values to other types if specified.
   * @param message Redirect
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Redirect,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Redirect to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an AlwaysOn.
 */
declare type replit$goval$api$IAlwaysOn = {|
  /**
   * AlwaysOn enable
   */
  enable?: boolean | null,
|};

/**
 * Represents an AlwaysOn.
 */
declare class replit$goval$api$AlwaysOn {
  /**
   * Constructs a new AlwaysOn.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IAlwaysOn): this;

  /**
   * AlwaysOn enable.
   */
  enable: boolean;

  /**
   * Creates a new AlwaysOn instance using the specified properties.
   * @param [properties] Properties to set
   * @returns AlwaysOn instance
   */
  static create(
    properties?: replit$goval$api$IAlwaysOn
  ): replit$goval$api$AlwaysOn;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AlwaysOn message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$AlwaysOn,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AlwaysOn message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$AlwaysOn,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an AlwaysOn message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns AlwaysOn
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$AlwaysOn;

  /**
   * Decodes an AlwaysOn message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns AlwaysOn
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$AlwaysOn;

  /**
   * Verifies an AlwaysOn message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an AlwaysOn message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns AlwaysOn
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$AlwaysOn;

  /**
   * Creates a plain object from an AlwaysOn message. Also converts values to other types if specified.
   * @param message AlwaysOn
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$AlwaysOn,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this AlwaysOn to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a RunMain.
 */
declare type replit$goval$api$IRunMain = {|
  /**
   * RunMain runMode
   */
  runMode?: $Values<typeof replit$goval$api$RunMain$RunMode> | null,

  /**
   * RunMain idempotent
   */
  idempotent?: boolean | null,
|};

/**
 * Represents a RunMain.
 */
declare class replit$goval$api$RunMain {
  /**
   * Constructs a new RunMain.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IRunMain): this;

  /**
   * RunMain runMode.
   */
  runMode: $Values<typeof replit$goval$api$RunMain$RunMode>;

  /**
   * RunMain idempotent.
   */
  idempotent: boolean;

  /**
   * Creates a new RunMain instance using the specified properties.
   * @param [properties] Properties to set
   * @returns RunMain instance
   */
  static create(
    properties?: replit$goval$api$IRunMain
  ): replit$goval$api$RunMain;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RunMain message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$RunMain,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RunMain message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$RunMain,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a RunMain message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns RunMain
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$RunMain;

  /**
   * Decodes a RunMain message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns RunMain
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$RunMain;

  /**
   * Verifies a RunMain message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a RunMain message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns RunMain
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$RunMain;

  /**
   * Creates a plain object from a RunMain message. Also converts values to other types if specified.
   * @param message RunMain
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$RunMain,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this RunMain to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static RunMode: typeof replit$goval$api$RunMain$RunMode;
}

/**
 * RunMode enum.
 */

declare var replit$goval$api$RunMain$RunMode: {|
  +RUN: 0, // 0
  +RECORD: 1, // 1
|};

/**
 * Properties of an OpenChannel.
 */
declare type replit$goval$api$IOpenChannel = {|
  /**
   * OpenChannel service
   */
  service?: string | null,

  /**
   * OpenChannel name
   */
  name?: string | null,

  /**
   * OpenChannel action
   */
  action?: $Values<typeof replit$goval$api$OpenChannel$Action> | null,

  /**
   * OpenChannel id
   */
  id?: number | null,
|};

/**
 * Represents an OpenChannel.
 */
declare class replit$goval$api$OpenChannel {
  /**
   * Constructs a new OpenChannel.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IOpenChannel): this;

  /**
   * OpenChannel service.
   */
  service: string;

  /**
   * OpenChannel name.
   */
  name: string;

  /**
   * OpenChannel action.
   */
  action: $Values<typeof replit$goval$api$OpenChannel$Action>;

  /**
   * OpenChannel id.
   */
  id: number;

  /**
   * Creates a new OpenChannel instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OpenChannel instance
   */
  static create(
    properties?: replit$goval$api$IOpenChannel
  ): replit$goval$api$OpenChannel;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OpenChannel message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$OpenChannel,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OpenChannel message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$OpenChannel,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an OpenChannel message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OpenChannel
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$OpenChannel;

  /**
   * Decodes an OpenChannel message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OpenChannel
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$OpenChannel;

  /**
   * Verifies an OpenChannel message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an OpenChannel message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OpenChannel
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$OpenChannel;

  /**
   * Creates a plain object from an OpenChannel message. Also converts values to other types if specified.
   * @param message OpenChannel
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$OpenChannel,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OpenChannel to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Action: typeof replit$goval$api$OpenChannel$Action;
}

/**
 * Action enum.
 */

declare var replit$goval$api$OpenChannel$Action: {|
  +CREATE: 0, // 0
  +ATTACH: 1, // 1
  +ATTACH_OR_CREATE: 2, // 2
|};

/**
 * Properties of an OpenChannelRes.
 */
declare type replit$goval$api$IOpenChannelRes = {|
  /**
   * OpenChannelRes id
   */
  id?: number | null,

  /**
   * OpenChannelRes state
   */
  state?: $Values<typeof replit$goval$api$OpenChannelRes$State> | null,

  /**
   * OpenChannelRes error
   */
  error?: string | null,
|};

/**
 * Represents an OpenChannelRes.
 */
declare class replit$goval$api$OpenChannelRes {
  /**
   * Constructs a new OpenChannelRes.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IOpenChannelRes): this;

  /**
   * OpenChannelRes id.
   */
  id: number;

  /**
   * OpenChannelRes state.
   */
  state: $Values<typeof replit$goval$api$OpenChannelRes$State>;

  /**
   * OpenChannelRes error.
   */
  error: string;

  /**
   * Creates a new OpenChannelRes instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OpenChannelRes instance
   */
  static create(
    properties?: replit$goval$api$IOpenChannelRes
  ): replit$goval$api$OpenChannelRes;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OpenChannelRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$OpenChannelRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OpenChannelRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$OpenChannelRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an OpenChannelRes message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OpenChannelRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$OpenChannelRes;

  /**
   * Decodes an OpenChannelRes message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OpenChannelRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$OpenChannelRes;

  /**
   * Verifies an OpenChannelRes message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an OpenChannelRes message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OpenChannelRes
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$OpenChannelRes;

  /**
   * Creates a plain object from an OpenChannelRes message. Also converts values to other types if specified.
   * @param message OpenChannelRes
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$OpenChannelRes,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OpenChannelRes to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static State: typeof replit$goval$api$OpenChannelRes$State;
}

/**
 * State enum.
 */

declare var replit$goval$api$OpenChannelRes$State: {|
  +CREATED: 0, // 0
  +ATTACHED: 1, // 1
  +ERROR: 2, // 2
|};

/**
 * Properties of a CloseChannel.
 */
declare type replit$goval$api$ICloseChannel = {|
  /**
   * CloseChannel id
   */
  id?: number | null,

  /**
   * CloseChannel action
   */
  action?: $Values<typeof replit$goval$api$CloseChannel$Action> | null,
|};

/**
 * Represents a CloseChannel.
 */
declare class replit$goval$api$CloseChannel {
  /**
   * Constructs a new CloseChannel.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ICloseChannel): this;

  /**
   * CloseChannel id.
   */
  id: number;

  /**
   * CloseChannel action.
   */
  action: $Values<typeof replit$goval$api$CloseChannel$Action>;

  /**
   * Creates a new CloseChannel instance using the specified properties.
   * @param [properties] Properties to set
   * @returns CloseChannel instance
   */
  static create(
    properties?: replit$goval$api$ICloseChannel
  ): replit$goval$api$CloseChannel;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CloseChannel message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$CloseChannel,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CloseChannel message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$CloseChannel,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a CloseChannel message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns CloseChannel
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$CloseChannel;

  /**
   * Decodes a CloseChannel message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns CloseChannel
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$CloseChannel;

  /**
   * Verifies a CloseChannel message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a CloseChannel message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns CloseChannel
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$CloseChannel;

  /**
   * Creates a plain object from a CloseChannel message. Also converts values to other types if specified.
   * @param message CloseChannel
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$CloseChannel,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this CloseChannel to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Action: typeof replit$goval$api$CloseChannel$Action;
}

/**
 * Action enum.
 */

declare var replit$goval$api$CloseChannel$Action: {|
  +DISCONNECT: 0, // 0
  +TRY_CLOSE: 1, // 1
  +CLOSE: 2, // 2
|};

/**
 * Properties of a CloseChannelRes.
 */
declare type replit$goval$api$ICloseChannelRes = {|
  /**
   * CloseChannelRes id
   */
  id?: number | null,

  /**
   * CloseChannelRes status
   */
  status?: $Values<typeof replit$goval$api$CloseChannelRes$Status> | null,
|};

/**
 * Represents a CloseChannelRes.
 */
declare class replit$goval$api$CloseChannelRes {
  /**
   * Constructs a new CloseChannelRes.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ICloseChannelRes): this;

  /**
   * CloseChannelRes id.
   */
  id: number;

  /**
   * CloseChannelRes status.
   */
  status: $Values<typeof replit$goval$api$CloseChannelRes$Status>;

  /**
   * Creates a new CloseChannelRes instance using the specified properties.
   * @param [properties] Properties to set
   * @returns CloseChannelRes instance
   */
  static create(
    properties?: replit$goval$api$ICloseChannelRes
  ): replit$goval$api$CloseChannelRes;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CloseChannelRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$CloseChannelRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CloseChannelRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$CloseChannelRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a CloseChannelRes message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns CloseChannelRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$CloseChannelRes;

  /**
   * Decodes a CloseChannelRes message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns CloseChannelRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$CloseChannelRes;

  /**
   * Verifies a CloseChannelRes message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a CloseChannelRes message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns CloseChannelRes
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$CloseChannelRes;

  /**
   * Creates a plain object from a CloseChannelRes message. Also converts values to other types if specified.
   * @param message CloseChannelRes
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$CloseChannelRes,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this CloseChannelRes to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Status: typeof replit$goval$api$CloseChannelRes$Status;
}

/**
 * Status enum.
 */

declare var replit$goval$api$CloseChannelRes$Status: {|
  +DISCONNECT: 0, // 0
  +CLOSE: 1, // 1
  +NOTHING: 2, // 2
|};

/**
 * Properties of a ContainerState.
 */
declare type replit$goval$api$IContainerState = {|
  /**
   * ContainerState state
   */
  state?: $Values<typeof replit$goval$api$ContainerState$State> | null,
|};

/**
 * Represents a ContainerState.
 */
declare class replit$goval$api$ContainerState {
  /**
   * Constructs a new ContainerState.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IContainerState): this;

  /**
   * ContainerState state.
   */
  state: $Values<typeof replit$goval$api$ContainerState$State>;

  /**
   * Creates a new ContainerState instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ContainerState instance
   */
  static create(
    properties?: replit$goval$api$IContainerState
  ): replit$goval$api$ContainerState;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ContainerState message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ContainerState,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ContainerState message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ContainerState,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ContainerState message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ContainerState
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ContainerState;

  /**
   * Decodes a ContainerState message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ContainerState
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ContainerState;

  /**
   * Verifies a ContainerState message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ContainerState message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ContainerState
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ContainerState;

  /**
   * Creates a plain object from a ContainerState message. Also converts values to other types if specified.
   * @param message ContainerState
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ContainerState,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ContainerState to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static State: typeof replit$goval$api$ContainerState$State;
}

/**
 * State enum.
 */

declare var replit$goval$api$ContainerState$State: {|
  +SLEEP: 0, // 0
  +READY: 1, // 1
|};

/**
 * Properties of a PortOpen.
 */
declare type replit$goval$api$IPortOpen = {|
  /**
   * PortOpen forwarded
   */
  forwarded?: boolean | null,

  /**
   * PortOpen port
   */
  port?: number | null,

  /**
   * PortOpen address
   */
  address?: string | null,

  /**
   * PortOpen externalPort
   */
  externalPort?: number | null,
|};

/**
 * Represents a PortOpen.
 */
declare class replit$goval$api$PortOpen {
  /**
   * Constructs a new PortOpen.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPortOpen): this;

  /**
   * PortOpen forwarded.
   */
  forwarded: boolean;

  /**
   * PortOpen port.
   */
  port: number;

  /**
   * PortOpen address.
   */
  address: string;

  /**
   * PortOpen externalPort.
   */
  externalPort: number;

  /**
   * Creates a new PortOpen instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PortOpen instance
   */
  static create(
    properties?: replit$goval$api$IPortOpen
  ): replit$goval$api$PortOpen;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PortOpen message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PortOpen,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PortOpen message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PortOpen,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PortOpen message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PortOpen
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PortOpen;

  /**
   * Decodes a PortOpen message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PortOpen
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PortOpen;

  /**
   * Verifies a PortOpen message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PortOpen message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PortOpen
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PortOpen;

  /**
   * Creates a plain object from a PortOpen message. Also converts values to other types if specified.
   * @param message PortOpen
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PortOpen,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PortOpen to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PortClose.
 */
declare type replit$goval$api$IPortClose = {|
  /**
   * PortClose port
   */
  port?: number | null,

  /**
   * PortClose address
   */
  address?: string | null,

  /**
   * PortClose externalPort
   */
  externalPort?: number | null,
|};

/**
 * Represents a PortClose.
 */
declare class replit$goval$api$PortClose {
  /**
   * Constructs a new PortClose.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPortClose): this;

  /**
   * PortClose port.
   */
  port: number;

  /**
   * PortClose address.
   */
  address: string;

  /**
   * PortClose externalPort.
   */
  externalPort: number;

  /**
   * Creates a new PortClose instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PortClose instance
   */
  static create(
    properties?: replit$goval$api$IPortClose
  ): replit$goval$api$PortClose;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PortClose message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PortClose,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PortClose message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PortClose,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PortClose message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PortClose
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PortClose;

  /**
   * Decodes a PortClose message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PortClose
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PortClose;

  /**
   * Verifies a PortClose message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PortClose message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PortClose
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PortClose;

  /**
   * Creates a plain object from a PortClose message. Also converts values to other types if specified.
   * @param message PortClose
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PortClose,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PortClose to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTFetchRequest.
 */
declare type replit$goval$api$IOTFetchRequest = {|
  /**
   * OTFetchRequest versionFrom
   */
  versionFrom?: number | null,

  /**
   * OTFetchRequest versionTo
   */
  versionTo?: number | null,
|};

/**
 * Represents a OTFetchRequest.
 */
declare class replit$goval$api$OTFetchRequest {
  /**
   * Constructs a new OTFetchRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IOTFetchRequest): this;

  /**
   * OTFetchRequest versionFrom.
   */
  versionFrom: number;

  /**
   * OTFetchRequest versionTo.
   */
  versionTo: number;

  /**
   * Creates a new OTFetchRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTFetchRequest instance
   */
  static create(
    properties?: replit$goval$api$IOTFetchRequest
  ): replit$goval$api$OTFetchRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTFetchRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$OTFetchRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTFetchRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$OTFetchRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTFetchRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTFetchRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$OTFetchRequest;

  /**
   * Decodes a OTFetchRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTFetchRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$OTFetchRequest;

  /**
   * Verifies a OTFetchRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTFetchRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTFetchRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$OTFetchRequest;

  /**
   * Creates a plain object from a OTFetchRequest message. Also converts values to other types if specified.
   * @param message OTFetchRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$OTFetchRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTFetchRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTFetchResponse.
 */
declare type replit$goval$api$IOTFetchResponse = {|
  /**
   * OTFetchResponse packets
   */
  packets?: (replit$goval$api$OTPacket | replit$goval$api$IOTPacket)[] | null,
|};

/**
 * Represents a OTFetchResponse.
 */
declare class replit$goval$api$OTFetchResponse {
  /**
   * Constructs a new OTFetchResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IOTFetchResponse): this;

  /**
   * OTFetchResponse packets.
   */
  packets: replit$goval$api$OTPacket[];

  /**
   * Creates a new OTFetchResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTFetchResponse instance
   */
  static create(
    properties?: replit$goval$api$IOTFetchResponse
  ): replit$goval$api$OTFetchResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTFetchResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$OTFetchResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTFetchResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$OTFetchResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTFetchResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTFetchResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$OTFetchResponse;

  /**
   * Decodes a OTFetchResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTFetchResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$OTFetchResponse;

  /**
   * Verifies a OTFetchResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTFetchResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTFetchResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$OTFetchResponse;

  /**
   * Creates a plain object from a OTFetchResponse message. Also converts values to other types if specified.
   * @param message OTFetchResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$OTFetchResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTFetchResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTTransformSelectionRequest.
 */
declare type replit$goval$api$IOTTransformSelectionRequest = {|
  /**
   * OTTransformSelectionRequest indexStart
   */
  indexStart?: number | null,

  /**
   * OTTransformSelectionRequest indexEnd
   */
  indexEnd?: number | null,

  /**
   * OTTransformSelectionRequest versionFrom
   */
  versionFrom?: number | null,

  /**
   * OTTransformSelectionRequest versionTo
   */
  versionTo?: number | null,
|};

/**
 * Represents a OTTransformSelectionRequest.
 */
declare class replit$goval$api$OTTransformSelectionRequest {
  /**
   * Constructs a new OTTransformSelectionRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IOTTransformSelectionRequest): this;

  /**
   * OTTransformSelectionRequest indexStart.
   */
  indexStart: number;

  /**
   * OTTransformSelectionRequest indexEnd.
   */
  indexEnd: number;

  /**
   * OTTransformSelectionRequest versionFrom.
   */
  versionFrom: number;

  /**
   * OTTransformSelectionRequest versionTo.
   */
  versionTo: number;

  /**
   * Creates a new OTTransformSelectionRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTTransformSelectionRequest instance
   */
  static create(
    properties?: replit$goval$api$IOTTransformSelectionRequest
  ): replit$goval$api$OTTransformSelectionRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTTransformSelectionRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$OTTransformSelectionRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTTransformSelectionRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$OTTransformSelectionRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTTransformSelectionRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTTransformSelectionRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$OTTransformSelectionRequest;

  /**
   * Decodes a OTTransformSelectionRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTTransformSelectionRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$OTTransformSelectionRequest;

  /**
   * Verifies a OTTransformSelectionRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTTransformSelectionRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTTransformSelectionRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$OTTransformSelectionRequest;

  /**
   * Creates a plain object from a OTTransformSelectionRequest message. Also converts values to other types if specified.
   * @param message OTTransformSelectionRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$OTTransformSelectionRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTTransformSelectionRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTTransformSelectionResponse.
 */
declare type replit$goval$api$IOTTransformSelectionResponse = {|
  /**
   * OTTransformSelectionResponse indexStart
   */
  indexStart?: number | null,

  /**
   * OTTransformSelectionResponse indexEnd
   */
  indexEnd?: number | null,

  /**
   * OTTransformSelectionResponse version
   */
  version?: number | null,
|};

/**
 * Represents a OTTransformSelectionResponse.
 */
declare class replit$goval$api$OTTransformSelectionResponse {
  /**
   * Constructs a new OTTransformSelectionResponse.
   * @param [properties] Properties to set
   */
  constructor(
    properties?: replit$goval$api$IOTTransformSelectionResponse
  ): this;

  /**
   * OTTransformSelectionResponse indexStart.
   */
  indexStart: number;

  /**
   * OTTransformSelectionResponse indexEnd.
   */
  indexEnd: number;

  /**
   * OTTransformSelectionResponse version.
   */
  version: number;

  /**
   * Creates a new OTTransformSelectionResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTTransformSelectionResponse instance
   */
  static create(
    properties?: replit$goval$api$IOTTransformSelectionResponse
  ): replit$goval$api$OTTransformSelectionResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTTransformSelectionResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$OTTransformSelectionResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTTransformSelectionResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$OTTransformSelectionResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTTransformSelectionResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTTransformSelectionResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$OTTransformSelectionResponse;

  /**
   * Decodes a OTTransformSelectionResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTTransformSelectionResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$OTTransformSelectionResponse;

  /**
   * Verifies a OTTransformSelectionResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTTransformSelectionResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTTransformSelectionResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$OTTransformSelectionResponse;

  /**
   * Creates a plain object from a OTTransformSelectionResponse message. Also converts values to other types if specified.
   * @param message OTTransformSelectionResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$OTTransformSelectionResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTTransformSelectionResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTPacket.
 */
declare type replit$goval$api$IOTPacket = {|
  /**
   * OTPacket spookyVersion
   */
  spookyVersion?: number | null,

  /**
   * OTPacket version
   */
  version?: number | null,

  /**
   * OTPacket op
   */
  op?:
    | (replit$goval$api$OTOpComponent | replit$goval$api$IOTOpComponent)[]
    | null,

  /**
   * OTPacket crc32
   */
  crc32?: number | null,

  /**
   * OTPacket committed
   */
  committed?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,

  /**
   * OTPacket nonce
   */
  nonce?: number | null,

  /**
   * OTPacket userId
   */
  userId?: number | null,

  /**
   * OTPacket author
   */
  author?: $Values<typeof replit$goval$api$OTPacket$Author> | null,
|};

/**
 * Represents a OTPacket.
 */
declare class replit$goval$api$OTPacket {
  /**
   * Constructs a new OTPacket.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IOTPacket): this;

  /**
   * OTPacket spookyVersion.
   */
  spookyVersion: number;

  /**
   * OTPacket version.
   */
  version: number;

  /**
   * OTPacket op.
   */
  op: replit$goval$api$OTOpComponent[];

  /**
   * OTPacket crc32.
   */
  crc32: number;

  /**
   * OTPacket committed.
   */
  committed?: google$protobuf$Timestamp | null;

  /**
   * OTPacket nonce.
   */
  nonce: number;

  /**
   * OTPacket userId.
   */
  userId: number;

  /**
   * OTPacket author.
   */
  author: $Values<typeof replit$goval$api$OTPacket$Author>;

  /**
   * Creates a new OTPacket instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTPacket instance
   */
  static create(
    properties?: replit$goval$api$IOTPacket
  ): replit$goval$api$OTPacket;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTPacket message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$OTPacket,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTPacket message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$OTPacket,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTPacket message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTPacket
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$OTPacket;

  /**
   * Decodes a OTPacket message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTPacket
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$OTPacket;

  /**
   * Verifies a OTPacket message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTPacket message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTPacket
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$OTPacket;

  /**
   * Creates a plain object from a OTPacket message. Also converts values to other types if specified.
   * @param message OTPacket
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$OTPacket,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTPacket to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Author: typeof replit$goval$api$OTPacket$Author;
}

/**
 * Author enum.
 */

declare var replit$goval$api$OTPacket$Author: {|
  +USER: 0, // 0
  +GHOSTWRITER: 1, // 1
|};

/**
 * Properties of a OTOpComponent.
 */
declare type replit$goval$api$IOTOpComponent = {|
  /**
   * OTOpComponent skip
   */
  skip?: number | null,

  /**
   * OTOpComponent delete
   */
  delete?: number | null,

  /**
   * OTOpComponent insert
   */
  insert?: string | null,
|};

/**
 * Represents a OTOpComponent.
 */
declare class replit$goval$api$OTOpComponent {
  /**
   * Constructs a new OTOpComponent.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IOTOpComponent): this;

  /**
   * OTOpComponent skip.
   */
  skip?: number | null;

  /**
   * OTOpComponent delete.
   */
  delete?: number | null;

  /**
   * OTOpComponent insert.
   */
  insert?: string | null;

  /**
   * OTOpComponent opComponent.
   */
  opComponent?: "skip" | "delete" | "insert";

  /**
   * Creates a new OTOpComponent instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTOpComponent instance
   */
  static create(
    properties?: replit$goval$api$IOTOpComponent
  ): replit$goval$api$OTOpComponent;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTOpComponent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$OTOpComponent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTOpComponent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$OTOpComponent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTOpComponent message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTOpComponent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$OTOpComponent;

  /**
   * Decodes a OTOpComponent message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTOpComponent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$OTOpComponent;

  /**
   * Verifies a OTOpComponent message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTOpComponent message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTOpComponent
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$OTOpComponent;

  /**
   * Creates a plain object from a OTOpComponent message. Also converts values to other types if specified.
   * @param message OTOpComponent
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$OTOpComponent,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTOpComponent to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTStatus.
 */
declare type replit$goval$api$IOTStatus = {|
  /**
   * OTStatus contents
   */
  contents?: string | null,

  /**
   * OTStatus version
   */
  version?: number | null,

  /**
   * OTStatus linkedFile
   */
  linkedFile?: replit$goval$api$File | replit$goval$api$IFile | null,

  /**
   * OTStatus cursors
   */
  cursors?: (replit$goval$api$OTCursor | replit$goval$api$IOTCursor)[] | null,
|};

/**
 * Represents a OTStatus.
 */
declare class replit$goval$api$OTStatus {
  /**
   * Constructs a new OTStatus.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IOTStatus): this;

  /**
   * OTStatus contents.
   */
  contents: string;

  /**
   * OTStatus version.
   */
  version: number;

  /**
   * OTStatus linkedFile.
   */
  linkedFile?: replit$goval$api$File | null;

  /**
   * OTStatus cursors.
   */
  cursors: replit$goval$api$OTCursor[];

  /**
   * Creates a new OTStatus instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTStatus instance
   */
  static create(
    properties?: replit$goval$api$IOTStatus
  ): replit$goval$api$OTStatus;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTStatus message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$OTStatus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTStatus message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$OTStatus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTStatus message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTStatus
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$OTStatus;

  /**
   * Decodes a OTStatus message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTStatus
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$OTStatus;

  /**
   * Verifies a OTStatus message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTStatus message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTStatus
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$OTStatus;

  /**
   * Creates a plain object from a OTStatus message. Also converts values to other types if specified.
   * @param message OTStatus
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$OTStatus,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTStatus to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTCursor.
 */
declare type replit$goval$api$IOTCursor = {|
  /**
   * OTCursor position
   */
  position?: number | null,

  /**
   * OTCursor selectionStart
   */
  selectionStart?: number | null,

  /**
   * OTCursor selectionEnd
   */
  selectionEnd?: number | null,

  /**
   * OTCursor user
   */
  user?: replit$goval$api$User | replit$goval$api$IUser | null,

  /**
   * OTCursor id
   */
  id?: string | null,
|};

/**
 * Represents a OTCursor.
 */
declare class replit$goval$api$OTCursor {
  /**
   * Constructs a new OTCursor.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IOTCursor): this;

  /**
   * OTCursor position.
   */
  position: number;

  /**
   * OTCursor selectionStart.
   */
  selectionStart: number;

  /**
   * OTCursor selectionEnd.
   */
  selectionEnd: number;

  /**
   * OTCursor user.
   */
  user?: replit$goval$api$User | null;

  /**
   * OTCursor id.
   */
  id: string;

  /**
   * Creates a new OTCursor instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTCursor instance
   */
  static create(
    properties?: replit$goval$api$IOTCursor
  ): replit$goval$api$OTCursor;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTCursor message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$OTCursor,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTCursor message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$OTCursor,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTCursor message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTCursor
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$OTCursor;

  /**
   * Decodes a OTCursor message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTCursor
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$OTCursor;

  /**
   * Verifies a OTCursor message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTCursor message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTCursor
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$OTCursor;

  /**
   * Creates a plain object from a OTCursor message. Also converts values to other types if specified.
   * @param message OTCursor
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$OTCursor,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTCursor to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ChatMessage.
 */
declare type replit$goval$api$IChatMessage = {|
  /**
   * ChatMessage username
   */
  username?: string | null,

  /**
   * ChatMessage text
   */
  text?: string | null,
|};

/**
 * Represents a ChatMessage.
 */
declare class replit$goval$api$ChatMessage {
  /**
   * Constructs a new ChatMessage.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IChatMessage): this;

  /**
   * ChatMessage username.
   */
  username: string;

  /**
   * ChatMessage text.
   */
  text: string;

  /**
   * Creates a new ChatMessage instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ChatMessage instance
   */
  static create(
    properties?: replit$goval$api$IChatMessage
  ): replit$goval$api$ChatMessage;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ChatMessage message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ChatMessage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ChatMessage message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ChatMessage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ChatMessage message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ChatMessage
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ChatMessage;

  /**
   * Decodes a ChatMessage message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ChatMessage
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ChatMessage;

  /**
   * Verifies a ChatMessage message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ChatMessage message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ChatMessage
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ChatMessage;

  /**
   * Creates a plain object from a ChatMessage message. Also converts values to other types if specified.
   * @param message ChatMessage
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ChatMessage,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ChatMessage to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ChatTyping.
 */
declare type replit$goval$api$IChatTyping = {|
  /**
   * ChatTyping username
   */
  username?: string | null,

  /**
   * ChatTyping typing
   */
  typing?: boolean | null,
|};

/**
 * Represents a ChatTyping.
 */
declare class replit$goval$api$ChatTyping {
  /**
   * Constructs a new ChatTyping.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IChatTyping): this;

  /**
   * ChatTyping username.
   */
  username: string;

  /**
   * ChatTyping typing.
   */
  typing: boolean;

  /**
   * Creates a new ChatTyping instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ChatTyping instance
   */
  static create(
    properties?: replit$goval$api$IChatTyping
  ): replit$goval$api$ChatTyping;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ChatTyping message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ChatTyping,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ChatTyping message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ChatTyping,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ChatTyping message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ChatTyping
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ChatTyping;

  /**
   * Decodes a ChatTyping message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ChatTyping
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ChatTyping;

  /**
   * Verifies a ChatTyping message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ChatTyping message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ChatTyping
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ChatTyping;

  /**
   * Creates a plain object from a ChatTyping message. Also converts values to other types if specified.
   * @param message ChatTyping
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ChatTyping,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ChatTyping to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a User.
 */
declare type replit$goval$api$IUser = {|
  /**
   * User id
   */
  id?: number | null,

  /**
   * User name
   */
  name?: string | null,

  /**
   * User roles
   */
  roles?: string[] | null,

  /**
   * User session
   */
  session?: number | null,

  /**
   * User teams
   */
  teams?: string[] | null,

  /**
   * User bio
   */
  bio?: string | null,

  /**
   * User url
   */
  url?: string | null,

  /**
   * User profileImage
   */
  profileImage?: string | null,
|};

/**
 * Represents a User.
 */
declare class replit$goval$api$User {
  /**
   * Constructs a new User.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IUser): this;

  /**
   * User id.
   */
  id: number;

  /**
   * User name.
   */
  name: string;

  /**
   * User roles.
   */
  roles: string[];

  /**
   * User session.
   */
  session: number;

  /**
   * User teams.
   */
  teams: string[];

  /**
   * User bio.
   */
  bio: string;

  /**
   * User url.
   */
  url: string;

  /**
   * User profileImage.
   */
  profileImage: string;

  /**
   * Creates a new User instance using the specified properties.
   * @param [properties] Properties to set
   * @returns User instance
   */
  static create(properties?: replit$goval$api$IUser): replit$goval$api$User;

  /**
   * [object Object],[object Object],[object Object]
   * @param message User message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$User,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message User message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$User,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a User message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns User
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$User;

  /**
   * Decodes a User message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns User
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$User;

  /**
   * Verifies a User message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a User message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns User
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$User;

  /**
   * Creates a plain object from a User message. Also converts values to other types if specified.
   * @param message User
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$User,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this User to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Roster.
 */
declare type replit$goval$api$IRoster = {|
  /**
   * Roster user
   */
  user?: (replit$goval$api$User | replit$goval$api$IUser)[] | null,

  /**
   * Roster files
   */
  files?: (replit$goval$api$FileOpened | replit$goval$api$IFileOpened)[] | null,
|};

/**
 * Represents a Roster.
 */
declare class replit$goval$api$Roster {
  /**
   * Constructs a new Roster.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IRoster): this;

  /**
   * Roster user.
   */
  user: replit$goval$api$User[];

  /**
   * Roster files.
   */
  files: replit$goval$api$FileOpened[];

  /**
   * Creates a new Roster instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Roster instance
   */
  static create(properties?: replit$goval$api$IRoster): replit$goval$api$Roster;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Roster message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Roster,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Roster message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Roster,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Roster message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Roster
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Roster;

  /**
   * Decodes a Roster message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Roster
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Roster;

  /**
   * Verifies a Roster message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Roster message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Roster
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Roster;

  /**
   * Creates a plain object from a Roster message. Also converts values to other types if specified.
   * @param message Roster
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Roster,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Roster to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an OpenFile.
 */
declare type replit$goval$api$IOpenFile = {|
  /**
   * OpenFile file
   */
  file?: string | null,
|};

/**
 * Represents an OpenFile.
 */
declare class replit$goval$api$OpenFile {
  /**
   * Constructs a new OpenFile.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IOpenFile): this;

  /**
   * OpenFile file.
   */
  file: string;

  /**
   * Creates a new OpenFile instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OpenFile instance
   */
  static create(
    properties?: replit$goval$api$IOpenFile
  ): replit$goval$api$OpenFile;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OpenFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$OpenFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OpenFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$OpenFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an OpenFile message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OpenFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$OpenFile;

  /**
   * Decodes an OpenFile message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OpenFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$OpenFile;

  /**
   * Verifies an OpenFile message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an OpenFile message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OpenFile
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$OpenFile;

  /**
   * Creates a plain object from an OpenFile message. Also converts values to other types if specified.
   * @param message OpenFile
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$OpenFile,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OpenFile to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FileOpened.
 */
declare type replit$goval$api$IFileOpened = {|
  /**
   * FileOpened userId
   */
  userId?: number | null,

  /**
   * FileOpened file
   */
  file?: string | null,

  /**
   * FileOpened session
   */
  session?: number | null,

  /**
   * FileOpened timestamp
   */
  timestamp?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,
|};

/**
 * Represents a FileOpened.
 */
declare class replit$goval$api$FileOpened {
  /**
   * Constructs a new FileOpened.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IFileOpened): this;

  /**
   * FileOpened userId.
   */
  userId: number;

  /**
   * FileOpened file.
   */
  file: string;

  /**
   * FileOpened session.
   */
  session: number;

  /**
   * FileOpened timestamp.
   */
  timestamp?: google$protobuf$Timestamp | null;

  /**
   * Creates a new FileOpened instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FileOpened instance
   */
  static create(
    properties?: replit$goval$api$IFileOpened
  ): replit$goval$api$FileOpened;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileOpened message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$FileOpened,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileOpened message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$FileOpened,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FileOpened message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FileOpened
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$FileOpened;

  /**
   * Decodes a FileOpened message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FileOpened
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$FileOpened;

  /**
   * Verifies a FileOpened message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FileOpened message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FileOpened
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$FileOpened;

  /**
   * Creates a plain object from a FileOpened message. Also converts values to other types if specified.
   * @param message FileOpened
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$FileOpened,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FileOpened to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReplspaceApiOpenFile.
 */
declare type replit$goval$api$IReplspaceApiOpenFile = {|
  /**
   * ReplspaceApiOpenFile file
   */
  file?: string | null,

  /**
   * ReplspaceApiOpenFile waitForClose
   */
  waitForClose?: boolean | null,

  /**
   * ReplspaceApiOpenFile nonce
   */
  nonce?: string | null,
|};

/**
 * Represents a ReplspaceApiOpenFile.
 */
declare class replit$goval$api$ReplspaceApiOpenFile {
  /**
   * Constructs a new ReplspaceApiOpenFile.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IReplspaceApiOpenFile): this;

  /**
   * ReplspaceApiOpenFile file.
   */
  file: string;

  /**
   * ReplspaceApiOpenFile waitForClose.
   */
  waitForClose: boolean;

  /**
   * ReplspaceApiOpenFile nonce.
   */
  nonce: string;

  /**
   * Creates a new ReplspaceApiOpenFile instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReplspaceApiOpenFile instance
   */
  static create(
    properties?: replit$goval$api$IReplspaceApiOpenFile
  ): replit$goval$api$ReplspaceApiOpenFile;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplspaceApiOpenFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ReplspaceApiOpenFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplspaceApiOpenFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ReplspaceApiOpenFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReplspaceApiOpenFile message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReplspaceApiOpenFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ReplspaceApiOpenFile;

  /**
   * Decodes a ReplspaceApiOpenFile message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReplspaceApiOpenFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ReplspaceApiOpenFile;

  /**
   * Verifies a ReplspaceApiOpenFile message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReplspaceApiOpenFile message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReplspaceApiOpenFile
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ReplspaceApiOpenFile;

  /**
   * Creates a plain object from a ReplspaceApiOpenFile message. Also converts values to other types if specified.
   * @param message ReplspaceApiOpenFile
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ReplspaceApiOpenFile,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReplspaceApiOpenFile to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReplspaceApiCloseFile.
 */
declare type replit$goval$api$IReplspaceApiCloseFile = {|
  /**
   * ReplspaceApiCloseFile file
   */
  file?: string | null,

  /**
   * ReplspaceApiCloseFile nonce
   */
  nonce?: string | null,
|};

/**
 * Represents a ReplspaceApiCloseFile.
 */
declare class replit$goval$api$ReplspaceApiCloseFile {
  /**
   * Constructs a new ReplspaceApiCloseFile.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IReplspaceApiCloseFile): this;

  /**
   * ReplspaceApiCloseFile file.
   */
  file: string;

  /**
   * ReplspaceApiCloseFile nonce.
   */
  nonce: string;

  /**
   * Creates a new ReplspaceApiCloseFile instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReplspaceApiCloseFile instance
   */
  static create(
    properties?: replit$goval$api$IReplspaceApiCloseFile
  ): replit$goval$api$ReplspaceApiCloseFile;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplspaceApiCloseFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ReplspaceApiCloseFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplspaceApiCloseFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ReplspaceApiCloseFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReplspaceApiCloseFile message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReplspaceApiCloseFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ReplspaceApiCloseFile;

  /**
   * Decodes a ReplspaceApiCloseFile message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReplspaceApiCloseFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ReplspaceApiCloseFile;

  /**
   * Verifies a ReplspaceApiCloseFile message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReplspaceApiCloseFile message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReplspaceApiCloseFile
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ReplspaceApiCloseFile;

  /**
   * Creates a plain object from a ReplspaceApiCloseFile message. Also converts values to other types if specified.
   * @param message ReplspaceApiCloseFile
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ReplspaceApiCloseFile,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReplspaceApiCloseFile to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReplspaceApiGetGitHubToken.
 */
declare type replit$goval$api$IReplspaceApiGetGitHubToken = {|
  /**
   * ReplspaceApiGetGitHubToken nonce
   */
  nonce?: string | null,
|};

/**
 * Represents a ReplspaceApiGetGitHubToken.
 */
declare class replit$goval$api$ReplspaceApiGetGitHubToken {
  /**
   * Constructs a new ReplspaceApiGetGitHubToken.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IReplspaceApiGetGitHubToken): this;

  /**
   * ReplspaceApiGetGitHubToken nonce.
   */
  nonce: string;

  /**
   * Creates a new ReplspaceApiGetGitHubToken instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReplspaceApiGetGitHubToken instance
   */
  static create(
    properties?: replit$goval$api$IReplspaceApiGetGitHubToken
  ): replit$goval$api$ReplspaceApiGetGitHubToken;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplspaceApiGetGitHubToken message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ReplspaceApiGetGitHubToken,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplspaceApiGetGitHubToken message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ReplspaceApiGetGitHubToken,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReplspaceApiGetGitHubToken message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReplspaceApiGetGitHubToken
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ReplspaceApiGetGitHubToken;

  /**
   * Decodes a ReplspaceApiGetGitHubToken message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReplspaceApiGetGitHubToken
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ReplspaceApiGetGitHubToken;

  /**
   * Verifies a ReplspaceApiGetGitHubToken message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReplspaceApiGetGitHubToken message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReplspaceApiGetGitHubToken
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ReplspaceApiGetGitHubToken;

  /**
   * Creates a plain object from a ReplspaceApiGetGitHubToken message. Also converts values to other types if specified.
   * @param message ReplspaceApiGetGitHubToken
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ReplspaceApiGetGitHubToken,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReplspaceApiGetGitHubToken to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReplspaceApiGitHubToken.
 */
declare type replit$goval$api$IReplspaceApiGitHubToken = {|
  /**
   * ReplspaceApiGitHubToken nonce
   */
  nonce?: string | null,

  /**
   * ReplspaceApiGitHubToken token
   */
  token?: string | null,
|};

/**
 * Represents a ReplspaceApiGitHubToken.
 */
declare class replit$goval$api$ReplspaceApiGitHubToken {
  /**
   * Constructs a new ReplspaceApiGitHubToken.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IReplspaceApiGitHubToken): this;

  /**
   * ReplspaceApiGitHubToken nonce.
   */
  nonce: string;

  /**
   * ReplspaceApiGitHubToken token.
   */
  token: string;

  /**
   * Creates a new ReplspaceApiGitHubToken instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReplspaceApiGitHubToken instance
   */
  static create(
    properties?: replit$goval$api$IReplspaceApiGitHubToken
  ): replit$goval$api$ReplspaceApiGitHubToken;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplspaceApiGitHubToken message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ReplspaceApiGitHubToken,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplspaceApiGitHubToken message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ReplspaceApiGitHubToken,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReplspaceApiGitHubToken message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReplspaceApiGitHubToken
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ReplspaceApiGitHubToken;

  /**
   * Decodes a ReplspaceApiGitHubToken message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReplspaceApiGitHubToken
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ReplspaceApiGitHubToken;

  /**
   * Verifies a ReplspaceApiGitHubToken message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReplspaceApiGitHubToken message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReplspaceApiGitHubToken
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ReplspaceApiGitHubToken;

  /**
   * Creates a plain object from a ReplspaceApiGitHubToken message. Also converts values to other types if specified.
   * @param message ReplspaceApiGitHubToken
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ReplspaceApiGitHubToken,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReplspaceApiGitHubToken to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an UpdateSessionTimestamp.
 */
declare type replit$goval$api$IUpdateSessionTimestamp = {||};

/**
 * Represents an UpdateSessionTimestamp.
 */
declare class replit$goval$api$UpdateSessionTimestamp {
  /**
   * Constructs a new UpdateSessionTimestamp.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IUpdateSessionTimestamp): this;

  /**
   * Creates a new UpdateSessionTimestamp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns UpdateSessionTimestamp instance
   */
  static create(
    properties?: replit$goval$api$IUpdateSessionTimestamp
  ): replit$goval$api$UpdateSessionTimestamp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message UpdateSessionTimestamp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$UpdateSessionTimestamp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message UpdateSessionTimestamp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$UpdateSessionTimestamp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an UpdateSessionTimestamp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns UpdateSessionTimestamp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$UpdateSessionTimestamp;

  /**
   * Decodes an UpdateSessionTimestamp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns UpdateSessionTimestamp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$UpdateSessionTimestamp;

  /**
   * Verifies an UpdateSessionTimestamp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an UpdateSessionTimestamp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns UpdateSessionTimestamp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$UpdateSessionTimestamp;

  /**
   * Creates a plain object from an UpdateSessionTimestamp message. Also converts values to other types if specified.
   * @param message UpdateSessionTimestamp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$UpdateSessionTimestamp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this UpdateSessionTimestamp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a SessionTimestampUpdated.
 */
declare type replit$goval$api$ISessionTimestampUpdated = {|
  /**
   * SessionTimestampUpdated session
   */
  session?: number | null,

  /**
   * SessionTimestampUpdated timestamp
   */
  timestamp?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,
|};

/**
 * Represents a SessionTimestampUpdated.
 */
declare class replit$goval$api$SessionTimestampUpdated {
  /**
   * Constructs a new SessionTimestampUpdated.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ISessionTimestampUpdated): this;

  /**
   * SessionTimestampUpdated session.
   */
  session: number;

  /**
   * SessionTimestampUpdated timestamp.
   */
  timestamp?: google$protobuf$Timestamp | null;

  /**
   * Creates a new SessionTimestampUpdated instance using the specified properties.
   * @param [properties] Properties to set
   * @returns SessionTimestampUpdated instance
   */
  static create(
    properties?: replit$goval$api$ISessionTimestampUpdated
  ): replit$goval$api$SessionTimestampUpdated;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SessionTimestampUpdated message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$SessionTimestampUpdated,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SessionTimestampUpdated message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$SessionTimestampUpdated,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a SessionTimestampUpdated message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns SessionTimestampUpdated
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$SessionTimestampUpdated;

  /**
   * Decodes a SessionTimestampUpdated message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns SessionTimestampUpdated
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$SessionTimestampUpdated;

  /**
   * Verifies a SessionTimestampUpdated message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a SessionTimestampUpdated message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns SessionTimestampUpdated
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$SessionTimestampUpdated;

  /**
   * Creates a plain object from a SessionTimestampUpdated message. Also converts values to other types if specified.
   * @param message SessionTimestampUpdated
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$SessionTimestampUpdated,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this SessionTimestampUpdated to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FollowUser.
 */
declare type replit$goval$api$IFollowUser = {|
  /**
   * FollowUser session
   */
  session?: number | null,
|};

/**
 * Represents a FollowUser.
 */
declare class replit$goval$api$FollowUser {
  /**
   * Constructs a new FollowUser.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IFollowUser): this;

  /**
   * FollowUser session.
   */
  session: number;

  /**
   * Creates a new FollowUser instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FollowUser instance
   */
  static create(
    properties?: replit$goval$api$IFollowUser
  ): replit$goval$api$FollowUser;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FollowUser message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$FollowUser,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FollowUser message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$FollowUser,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FollowUser message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FollowUser
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$FollowUser;

  /**
   * Decodes a FollowUser message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FollowUser
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$FollowUser;

  /**
   * Verifies a FollowUser message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FollowUser message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FollowUser
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$FollowUser;

  /**
   * Creates a plain object from a FollowUser message. Also converts values to other types if specified.
   * @param message FollowUser
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$FollowUser,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FollowUser to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an UnfollowUser.
 */
declare type replit$goval$api$IUnfollowUser = {|
  /**
   * UnfollowUser session
   */
  session?: number | null,
|};

/**
 * Represents an UnfollowUser.
 */
declare class replit$goval$api$UnfollowUser {
  /**
   * Constructs a new UnfollowUser.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IUnfollowUser): this;

  /**
   * UnfollowUser session.
   */
  session: number;

  /**
   * Creates a new UnfollowUser instance using the specified properties.
   * @param [properties] Properties to set
   * @returns UnfollowUser instance
   */
  static create(
    properties?: replit$goval$api$IUnfollowUser
  ): replit$goval$api$UnfollowUser;

  /**
   * [object Object],[object Object],[object Object]
   * @param message UnfollowUser message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$UnfollowUser,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message UnfollowUser message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$UnfollowUser,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an UnfollowUser message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns UnfollowUser
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$UnfollowUser;

  /**
   * Decodes an UnfollowUser message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns UnfollowUser
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$UnfollowUser;

  /**
   * Verifies an UnfollowUser message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an UnfollowUser message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns UnfollowUser
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$UnfollowUser;

  /**
   * Creates a plain object from an UnfollowUser message. Also converts values to other types if specified.
   * @param message UnfollowUser
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$UnfollowUser,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this UnfollowUser to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an Exec.
 */
declare type replit$goval$api$IExec = {|
  /**
   * Exec args
   */
  args?: string[] | null,

  /**
   * Exec env
   */
  env?: {|
    [k: string]: string,
  |} | null,

  /**
   * Exec blocking
   */
  blocking?: boolean | null,

  /**
   * Exec lifecycle
   */
  lifecycle?: $Values<typeof replit$goval$api$Exec$Lifecycle> | null,

  /**
   * Exec splitStderr
   */
  splitStderr?: boolean | null,

  /**
   * Exec splitLogs
   */
  splitLogs?: boolean | null,
|};

/**
 * Represents an Exec.
 */
declare class replit$goval$api$Exec {
  /**
   * Constructs a new Exec.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IExec): this;

  /**
   * Exec args.
   */
  args: string[];

  /**
   * Exec env.
   */
  env: {|
    [k: string]: string,
  |};

  /**
   * Exec blocking.
   */
  blocking: boolean;

  /**
   * Exec lifecycle.
   */
  lifecycle: $Values<typeof replit$goval$api$Exec$Lifecycle>;

  /**
   * Exec splitStderr.
   */
  splitStderr: boolean;

  /**
   * Exec splitLogs.
   */
  splitLogs: boolean;

  /**
   * Creates a new Exec instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Exec instance
   */
  static create(properties?: replit$goval$api$IExec): replit$goval$api$Exec;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Exec message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Exec,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Exec message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Exec,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an Exec message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Exec
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Exec;

  /**
   * Decodes an Exec message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Exec
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Exec;

  /**
   * Verifies an Exec message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an Exec message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Exec
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Exec;

  /**
   * Creates a plain object from an Exec message. Also converts values to other types if specified.
   * @param message Exec
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Exec,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Exec to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Lifecycle: typeof replit$goval$api$Exec$Lifecycle;
}

/**
 * Lifecycle enum.
 */

declare var replit$goval$api$Exec$Lifecycle: {|
  +NON_BLOCKING: 0, // 0
  +BLOCKING: 1, // 1
  +STDIN: 2, // 2
|};

/**
 * Properties of a Package.
 */
declare type replit$goval$api$IPackage = {|
  /**
   * Package name
   */
  name?: string | null,

  /**
   * Package spec
   */
  spec?: string | null,

  /**
   * Package description
   */
  description?: string | null,

  /**
   * Package version
   */
  version?: string | null,

  /**
   * Package homepageURL
   */
  homepageURL?: string | null,

  /**
   * Package documentationURL
   */
  documentationURL?: string | null,

  /**
   * Package sourceCodeURL
   */
  sourceCodeURL?: string | null,

  /**
   * Package bugTrackerURL
   */
  bugTrackerURL?: string | null,

  /**
   * Package author
   */
  author?: string | null,

  /**
   * Package license
   */
  license?: string | null,

  /**
   * Package dependencies
   */
  dependencies?:
    | (replit$goval$api$Package | replit$goval$api$IPackage)[]
    | null,
|};

/**
 * Represents a Package.
 */
declare class replit$goval$api$Package {
  /**
   * Constructs a new Package.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPackage): this;

  /**
   * Package name.
   */
  name: string;

  /**
   * Package spec.
   */
  spec: string;

  /**
   * Package description.
   */
  description: string;

  /**
   * Package version.
   */
  version: string;

  /**
   * Package homepageURL.
   */
  homepageURL: string;

  /**
   * Package documentationURL.
   */
  documentationURL: string;

  /**
   * Package sourceCodeURL.
   */
  sourceCodeURL: string;

  /**
   * Package bugTrackerURL.
   */
  bugTrackerURL: string;

  /**
   * Package author.
   */
  author: string;

  /**
   * Package license.
   */
  license: string;

  /**
   * Package dependencies.
   */
  dependencies: replit$goval$api$Package[];

  /**
   * Creates a new Package instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Package instance
   */
  static create(
    properties?: replit$goval$api$IPackage
  ): replit$goval$api$Package;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Package message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Package,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Package message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Package,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Package message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Package
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Package;

  /**
   * Decodes a Package message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Package
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Package;

  /**
   * Verifies a Package message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Package message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Package
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Package;

  /**
   * Creates a plain object from a Package message. Also converts values to other types if specified.
   * @param message Package
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Package,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Package to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageSearch.
 */
declare type replit$goval$api$IPackageSearch = {|
  /**
   * PackageSearch query
   */
  query?: string | null,
|};

/**
 * Represents a PackageSearch.
 */
declare class replit$goval$api$PackageSearch {
  /**
   * Constructs a new PackageSearch.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPackageSearch): this;

  /**
   * PackageSearch query.
   */
  query: string;

  /**
   * Creates a new PackageSearch instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageSearch instance
   */
  static create(
    properties?: replit$goval$api$IPackageSearch
  ): replit$goval$api$PackageSearch;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageSearch message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PackageSearch,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageSearch message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PackageSearch,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageSearch message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageSearch
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PackageSearch;

  /**
   * Decodes a PackageSearch message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageSearch
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PackageSearch;

  /**
   * Verifies a PackageSearch message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageSearch message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageSearch
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PackageSearch;

  /**
   * Creates a plain object from a PackageSearch message. Also converts values to other types if specified.
   * @param message PackageSearch
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PackageSearch,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageSearch to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageSearchResp.
 */
declare type replit$goval$api$IPackageSearchResp = {|
  /**
   * PackageSearchResp results
   */
  results?: (replit$goval$api$Package | replit$goval$api$IPackage)[] | null,
|};

/**
 * Represents a PackageSearchResp.
 */
declare class replit$goval$api$PackageSearchResp {
  /**
   * Constructs a new PackageSearchResp.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPackageSearchResp): this;

  /**
   * PackageSearchResp results.
   */
  results: replit$goval$api$Package[];

  /**
   * Creates a new PackageSearchResp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageSearchResp instance
   */
  static create(
    properties?: replit$goval$api$IPackageSearchResp
  ): replit$goval$api$PackageSearchResp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageSearchResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PackageSearchResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageSearchResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PackageSearchResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageSearchResp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageSearchResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PackageSearchResp;

  /**
   * Decodes a PackageSearchResp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageSearchResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PackageSearchResp;

  /**
   * Verifies a PackageSearchResp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageSearchResp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageSearchResp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PackageSearchResp;

  /**
   * Creates a plain object from a PackageSearchResp message. Also converts values to other types if specified.
   * @param message PackageSearchResp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PackageSearchResp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageSearchResp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageInfo.
 */
declare type replit$goval$api$IPackageInfo = {|
  /**
   * PackageInfo pkg
   */
  pkg?: replit$goval$api$Package | replit$goval$api$IPackage | null,
|};

/**
 * Represents a PackageInfo.
 */
declare class replit$goval$api$PackageInfo {
  /**
   * Constructs a new PackageInfo.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPackageInfo): this;

  /**
   * PackageInfo pkg.
   */
  pkg?: replit$goval$api$Package | null;

  /**
   * Creates a new PackageInfo instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageInfo instance
   */
  static create(
    properties?: replit$goval$api$IPackageInfo
  ): replit$goval$api$PackageInfo;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageInfo message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PackageInfo,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageInfo message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PackageInfo,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageInfo message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageInfo
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PackageInfo;

  /**
   * Decodes a PackageInfo message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageInfo
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PackageInfo;

  /**
   * Verifies a PackageInfo message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageInfo message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageInfo
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PackageInfo;

  /**
   * Creates a plain object from a PackageInfo message. Also converts values to other types if specified.
   * @param message PackageInfo
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PackageInfo,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageInfo to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageInfoResp.
 */
declare type replit$goval$api$IPackageInfoResp = {|
  /**
   * PackageInfoResp pkg
   */
  pkg?: replit$goval$api$Package | replit$goval$api$IPackage | null,
|};

/**
 * Represents a PackageInfoResp.
 */
declare class replit$goval$api$PackageInfoResp {
  /**
   * Constructs a new PackageInfoResp.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPackageInfoResp): this;

  /**
   * PackageInfoResp pkg.
   */
  pkg?: replit$goval$api$Package | null;

  /**
   * Creates a new PackageInfoResp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageInfoResp instance
   */
  static create(
    properties?: replit$goval$api$IPackageInfoResp
  ): replit$goval$api$PackageInfoResp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageInfoResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PackageInfoResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageInfoResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PackageInfoResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageInfoResp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageInfoResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PackageInfoResp;

  /**
   * Decodes a PackageInfoResp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageInfoResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PackageInfoResp;

  /**
   * Verifies a PackageInfoResp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageInfoResp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageInfoResp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PackageInfoResp;

  /**
   * Creates a plain object from a PackageInfoResp message. Also converts values to other types if specified.
   * @param message PackageInfoResp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PackageInfoResp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageInfoResp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageAdd.
 */
declare type replit$goval$api$IPackageAdd = {|
  /**
   * PackageAdd pkgs
   */
  pkgs?: (replit$goval$api$Package | replit$goval$api$IPackage)[] | null,
|};

/**
 * Represents a PackageAdd.
 */
declare class replit$goval$api$PackageAdd {
  /**
   * Constructs a new PackageAdd.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPackageAdd): this;

  /**
   * PackageAdd pkgs.
   */
  pkgs: replit$goval$api$Package[];

  /**
   * Creates a new PackageAdd instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageAdd instance
   */
  static create(
    properties?: replit$goval$api$IPackageAdd
  ): replit$goval$api$PackageAdd;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageAdd message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PackageAdd,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageAdd message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PackageAdd,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageAdd message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageAdd
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PackageAdd;

  /**
   * Decodes a PackageAdd message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageAdd
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PackageAdd;

  /**
   * Verifies a PackageAdd message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageAdd message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageAdd
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PackageAdd;

  /**
   * Creates a plain object from a PackageAdd message. Also converts values to other types if specified.
   * @param message PackageAdd
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PackageAdd,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageAdd to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageRemove.
 */
declare type replit$goval$api$IPackageRemove = {|
  /**
   * PackageRemove pkgs
   */
  pkgs?: (replit$goval$api$Package | replit$goval$api$IPackage)[] | null,
|};

/**
 * Represents a PackageRemove.
 */
declare class replit$goval$api$PackageRemove {
  /**
   * Constructs a new PackageRemove.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPackageRemove): this;

  /**
   * PackageRemove pkgs.
   */
  pkgs: replit$goval$api$Package[];

  /**
   * Creates a new PackageRemove instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageRemove instance
   */
  static create(
    properties?: replit$goval$api$IPackageRemove
  ): replit$goval$api$PackageRemove;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageRemove message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PackageRemove,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageRemove message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PackageRemove,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageRemove message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageRemove
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PackageRemove;

  /**
   * Decodes a PackageRemove message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageRemove
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PackageRemove;

  /**
   * Verifies a PackageRemove message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageRemove message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageRemove
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PackageRemove;

  /**
   * Creates a plain object from a PackageRemove message. Also converts values to other types if specified.
   * @param message PackageRemove
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PackageRemove,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageRemove to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageInstall.
 */
declare type replit$goval$api$IPackageInstall = {|
  /**
   * PackageInstall fromHosting
   */
  fromHosting?: boolean | null,
|};

/**
 * Represents a PackageInstall.
 */
declare class replit$goval$api$PackageInstall {
  /**
   * Constructs a new PackageInstall.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPackageInstall): this;

  /**
   * PackageInstall fromHosting.
   */
  fromHosting: boolean;

  /**
   * Creates a new PackageInstall instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageInstall instance
   */
  static create(
    properties?: replit$goval$api$IPackageInstall
  ): replit$goval$api$PackageInstall;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageInstall message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PackageInstall,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageInstall message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PackageInstall,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageInstall message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageInstall
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PackageInstall;

  /**
   * Decodes a PackageInstall message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageInstall
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PackageInstall;

  /**
   * Verifies a PackageInstall message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageInstall message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageInstall
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PackageInstall;

  /**
   * Creates a plain object from a PackageInstall message. Also converts values to other types if specified.
   * @param message PackageInstall
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PackageInstall,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageInstall to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageListSpecfile.
 */
declare type replit$goval$api$IPackageListSpecfile = {||};

/**
 * Represents a PackageListSpecfile.
 */
declare class replit$goval$api$PackageListSpecfile {
  /**
   * Constructs a new PackageListSpecfile.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPackageListSpecfile): this;

  /**
   * Creates a new PackageListSpecfile instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageListSpecfile instance
   */
  static create(
    properties?: replit$goval$api$IPackageListSpecfile
  ): replit$goval$api$PackageListSpecfile;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageListSpecfile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PackageListSpecfile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageListSpecfile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PackageListSpecfile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageListSpecfile message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageListSpecfile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PackageListSpecfile;

  /**
   * Decodes a PackageListSpecfile message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageListSpecfile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PackageListSpecfile;

  /**
   * Verifies a PackageListSpecfile message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageListSpecfile message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageListSpecfile
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PackageListSpecfile;

  /**
   * Creates a plain object from a PackageListSpecfile message. Also converts values to other types if specified.
   * @param message PackageListSpecfile
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PackageListSpecfile,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageListSpecfile to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageListSpecfileResp.
 */
declare type replit$goval$api$IPackageListSpecfileResp = {|
  /**
   * PackageListSpecfileResp pkgs
   */
  pkgs?: (replit$goval$api$Package | replit$goval$api$IPackage)[] | null,
|};

/**
 * Represents a PackageListSpecfileResp.
 */
declare class replit$goval$api$PackageListSpecfileResp {
  /**
   * Constructs a new PackageListSpecfileResp.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPackageListSpecfileResp): this;

  /**
   * PackageListSpecfileResp pkgs.
   */
  pkgs: replit$goval$api$Package[];

  /**
   * Creates a new PackageListSpecfileResp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageListSpecfileResp instance
   */
  static create(
    properties?: replit$goval$api$IPackageListSpecfileResp
  ): replit$goval$api$PackageListSpecfileResp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageListSpecfileResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PackageListSpecfileResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageListSpecfileResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PackageListSpecfileResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageListSpecfileResp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageListSpecfileResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PackageListSpecfileResp;

  /**
   * Decodes a PackageListSpecfileResp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageListSpecfileResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PackageListSpecfileResp;

  /**
   * Verifies a PackageListSpecfileResp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageListSpecfileResp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageListSpecfileResp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PackageListSpecfileResp;

  /**
   * Creates a plain object from a PackageListSpecfileResp message. Also converts values to other types if specified.
   * @param message PackageListSpecfileResp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PackageListSpecfileResp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageListSpecfileResp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageCacheSave.
 */
declare type replit$goval$api$IPackageCacheSave = {||};

/**
 * Represents a PackageCacheSave.
 */
declare class replit$goval$api$PackageCacheSave {
  /**
   * Constructs a new PackageCacheSave.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPackageCacheSave): this;

  /**
   * Creates a new PackageCacheSave instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageCacheSave instance
   */
  static create(
    properties?: replit$goval$api$IPackageCacheSave
  ): replit$goval$api$PackageCacheSave;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageCacheSave message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PackageCacheSave,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageCacheSave message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PackageCacheSave,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageCacheSave message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageCacheSave
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PackageCacheSave;

  /**
   * Decodes a PackageCacheSave message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageCacheSave
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PackageCacheSave;

  /**
   * Verifies a PackageCacheSave message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageCacheSave message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageCacheSave
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PackageCacheSave;

  /**
   * Creates a plain object from a PackageCacheSave message. Also converts values to other types if specified.
   * @param message PackageCacheSave
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PackageCacheSave,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageCacheSave to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ChatScrollback.
 */
declare type replit$goval$api$IChatScrollback = {|
  /**
   * ChatScrollback scrollback
   */
  scrollback?:
    | (replit$goval$api$ChatMessage | replit$goval$api$IChatMessage)[]
    | null,
|};

/**
 * Represents a ChatScrollback.
 */
declare class replit$goval$api$ChatScrollback {
  /**
   * Constructs a new ChatScrollback.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IChatScrollback): this;

  /**
   * ChatScrollback scrollback.
   */
  scrollback: replit$goval$api$ChatMessage[];

  /**
   * Creates a new ChatScrollback instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ChatScrollback instance
   */
  static create(
    properties?: replit$goval$api$IChatScrollback
  ): replit$goval$api$ChatScrollback;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ChatScrollback message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ChatScrollback,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ChatScrollback message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ChatScrollback,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ChatScrollback message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ChatScrollback
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ChatScrollback;

  /**
   * Decodes a ChatScrollback message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ChatScrollback
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ChatScrollback;

  /**
   * Verifies a ChatScrollback message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ChatScrollback message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ChatScrollback
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ChatScrollback;

  /**
   * Creates a plain object from a ChatScrollback message. Also converts values to other types if specified.
   * @param message ChatScrollback
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ChatScrollback,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ChatScrollback to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Metrics.
 */
declare type replit$goval$api$IMetrics = {|
  /**
   * Metrics prometheusMetricFamilies
   */
  prometheusMetricFamilies?: Uint8Array[] | null,
|};

/**
 * Represents a Metrics.
 */
declare class replit$goval$api$Metrics {
  /**
   * Constructs a new Metrics.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IMetrics): this;

  /**
   * Metrics prometheusMetricFamilies.
   */
  prometheusMetricFamilies: Uint8Array[];

  /**
   * Creates a new Metrics instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Metrics instance
   */
  static create(
    properties?: replit$goval$api$IMetrics
  ): replit$goval$api$Metrics;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Metrics message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Metrics,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Metrics message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Metrics,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Metrics message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Metrics
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Metrics;

  /**
   * Decodes a Metrics message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Metrics
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Metrics;

  /**
   * Verifies a Metrics message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Metrics message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Metrics
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Metrics;

  /**
   * Creates a plain object from a Metrics message. Also converts values to other types if specified.
   * @param message Metrics
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Metrics,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Metrics to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PprofRequest.
 */
declare type replit$goval$api$IPprofRequest = {|
  /**
   * PprofRequest id
   */
  id?: string | null,

  /**
   * PprofRequest pprofCpuProfileRequest
   */
  pprofCpuProfileRequest?:
    | replit$goval$api$PprofCpuProfileRequest
    | replit$goval$api$IPprofCpuProfileRequest
    | null,

  /**
   * PprofRequest pprofHeapProfileRequest
   */
  pprofHeapProfileRequest?:
    | replit$goval$api$PprofHeapProfileRequest
    | replit$goval$api$IPprofHeapProfileRequest
    | null,

  /**
   * PprofRequest pprofAllocsProfileRequest
   */
  pprofAllocsProfileRequest?:
    | replit$goval$api$PprofAllocsProfileRequest
    | replit$goval$api$IPprofAllocsProfileRequest
    | null,

  /**
   * PprofRequest pprofBlockProfileRequest
   */
  pprofBlockProfileRequest?:
    | replit$goval$api$PprofBlockProfileRequest
    | replit$goval$api$IPprofBlockProfileRequest
    | null,

  /**
   * PprofRequest pprofMutexProfileRequest
   */
  pprofMutexProfileRequest?:
    | replit$goval$api$PprofMutexProfileRequest
    | replit$goval$api$IPprofMutexProfileRequest
    | null,
|};

/**
 * Represents a PprofRequest.
 */
declare class replit$goval$api$PprofRequest {
  /**
   * Constructs a new PprofRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPprofRequest): this;

  /**
   * PprofRequest id.
   */
  id: string;

  /**
   * PprofRequest pprofCpuProfileRequest.
   */
  pprofCpuProfileRequest?: replit$goval$api$PprofCpuProfileRequest | null;

  /**
   * PprofRequest pprofHeapProfileRequest.
   */
  pprofHeapProfileRequest?: replit$goval$api$PprofHeapProfileRequest | null;

  /**
   * PprofRequest pprofAllocsProfileRequest.
   */
  pprofAllocsProfileRequest?: replit$goval$api$PprofAllocsProfileRequest | null;

  /**
   * PprofRequest pprofBlockProfileRequest.
   */
  pprofBlockProfileRequest?: replit$goval$api$PprofBlockProfileRequest | null;

  /**
   * PprofRequest pprofMutexProfileRequest.
   */
  pprofMutexProfileRequest?: replit$goval$api$PprofMutexProfileRequest | null;

  /**
   * PprofRequest body.
   */
  body?:
    | "pprofCpuProfileRequest"
    | "pprofHeapProfileRequest"
    | "pprofAllocsProfileRequest"
    | "pprofBlockProfileRequest"
    | "pprofMutexProfileRequest";

  /**
   * Creates a new PprofRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PprofRequest instance
   */
  static create(
    properties?: replit$goval$api$IPprofRequest
  ): replit$goval$api$PprofRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PprofRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PprofRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PprofRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PprofRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PprofRequest;

  /**
   * Decodes a PprofRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PprofRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PprofRequest;

  /**
   * Verifies a PprofRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PprofRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PprofRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PprofRequest;

  /**
   * Creates a plain object from a PprofRequest message. Also converts values to other types if specified.
   * @param message PprofRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PprofRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PprofRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PprofAllocsProfileRequest.
 */
declare type replit$goval$api$IPprofAllocsProfileRequest = {|
  /**
   * PprofAllocsProfileRequest debug
   */
  debug?: boolean | null,
|};

/**
 * Represents a PprofAllocsProfileRequest.
 */
declare class replit$goval$api$PprofAllocsProfileRequest {
  /**
   * Constructs a new PprofAllocsProfileRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPprofAllocsProfileRequest): this;

  /**
   * PprofAllocsProfileRequest debug.
   */
  debug: boolean;

  /**
   * Creates a new PprofAllocsProfileRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PprofAllocsProfileRequest instance
   */
  static create(
    properties?: replit$goval$api$IPprofAllocsProfileRequest
  ): replit$goval$api$PprofAllocsProfileRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofAllocsProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PprofAllocsProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofAllocsProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PprofAllocsProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PprofAllocsProfileRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PprofAllocsProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PprofAllocsProfileRequest;

  /**
   * Decodes a PprofAllocsProfileRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PprofAllocsProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PprofAllocsProfileRequest;

  /**
   * Verifies a PprofAllocsProfileRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PprofAllocsProfileRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PprofAllocsProfileRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PprofAllocsProfileRequest;

  /**
   * Creates a plain object from a PprofAllocsProfileRequest message. Also converts values to other types if specified.
   * @param message PprofAllocsProfileRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PprofAllocsProfileRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PprofAllocsProfileRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PprofBlockProfileRequest.
 */
declare type replit$goval$api$IPprofBlockProfileRequest = {|
  /**
   * PprofBlockProfileRequest debug
   */
  debug?: boolean | null,
|};

/**
 * Represents a PprofBlockProfileRequest.
 */
declare class replit$goval$api$PprofBlockProfileRequest {
  /**
   * Constructs a new PprofBlockProfileRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPprofBlockProfileRequest): this;

  /**
   * PprofBlockProfileRequest debug.
   */
  debug: boolean;

  /**
   * Creates a new PprofBlockProfileRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PprofBlockProfileRequest instance
   */
  static create(
    properties?: replit$goval$api$IPprofBlockProfileRequest
  ): replit$goval$api$PprofBlockProfileRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofBlockProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PprofBlockProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofBlockProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PprofBlockProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PprofBlockProfileRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PprofBlockProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PprofBlockProfileRequest;

  /**
   * Decodes a PprofBlockProfileRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PprofBlockProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PprofBlockProfileRequest;

  /**
   * Verifies a PprofBlockProfileRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PprofBlockProfileRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PprofBlockProfileRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PprofBlockProfileRequest;

  /**
   * Creates a plain object from a PprofBlockProfileRequest message. Also converts values to other types if specified.
   * @param message PprofBlockProfileRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PprofBlockProfileRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PprofBlockProfileRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PprofCpuProfileRequest.
 */
declare type replit$goval$api$IPprofCpuProfileRequest = {|
  /**
   * PprofCpuProfileRequest seconds
   */
  seconds?: number | null,
|};

/**
 * Represents a PprofCpuProfileRequest.
 */
declare class replit$goval$api$PprofCpuProfileRequest {
  /**
   * Constructs a new PprofCpuProfileRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPprofCpuProfileRequest): this;

  /**
   * PprofCpuProfileRequest seconds.
   */
  seconds: number;

  /**
   * Creates a new PprofCpuProfileRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PprofCpuProfileRequest instance
   */
  static create(
    properties?: replit$goval$api$IPprofCpuProfileRequest
  ): replit$goval$api$PprofCpuProfileRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofCpuProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PprofCpuProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofCpuProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PprofCpuProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PprofCpuProfileRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PprofCpuProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PprofCpuProfileRequest;

  /**
   * Decodes a PprofCpuProfileRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PprofCpuProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PprofCpuProfileRequest;

  /**
   * Verifies a PprofCpuProfileRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PprofCpuProfileRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PprofCpuProfileRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PprofCpuProfileRequest;

  /**
   * Creates a plain object from a PprofCpuProfileRequest message. Also converts values to other types if specified.
   * @param message PprofCpuProfileRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PprofCpuProfileRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PprofCpuProfileRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PprofHeapProfileRequest.
 */
declare type replit$goval$api$IPprofHeapProfileRequest = {|
  /**
   * PprofHeapProfileRequest gc
   */
  gc?: boolean | null,

  /**
   * PprofHeapProfileRequest debug
   */
  debug?: boolean | null,
|};

/**
 * Represents a PprofHeapProfileRequest.
 */
declare class replit$goval$api$PprofHeapProfileRequest {
  /**
   * Constructs a new PprofHeapProfileRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPprofHeapProfileRequest): this;

  /**
   * PprofHeapProfileRequest gc.
   */
  gc: boolean;

  /**
   * PprofHeapProfileRequest debug.
   */
  debug: boolean;

  /**
   * Creates a new PprofHeapProfileRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PprofHeapProfileRequest instance
   */
  static create(
    properties?: replit$goval$api$IPprofHeapProfileRequest
  ): replit$goval$api$PprofHeapProfileRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofHeapProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PprofHeapProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofHeapProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PprofHeapProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PprofHeapProfileRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PprofHeapProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PprofHeapProfileRequest;

  /**
   * Decodes a PprofHeapProfileRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PprofHeapProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PprofHeapProfileRequest;

  /**
   * Verifies a PprofHeapProfileRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PprofHeapProfileRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PprofHeapProfileRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PprofHeapProfileRequest;

  /**
   * Creates a plain object from a PprofHeapProfileRequest message. Also converts values to other types if specified.
   * @param message PprofHeapProfileRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PprofHeapProfileRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PprofHeapProfileRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PprofMutexProfileRequest.
 */
declare type replit$goval$api$IPprofMutexProfileRequest = {|
  /**
   * PprofMutexProfileRequest debug
   */
  debug?: boolean | null,
|};

/**
 * Represents a PprofMutexProfileRequest.
 */
declare class replit$goval$api$PprofMutexProfileRequest {
  /**
   * Constructs a new PprofMutexProfileRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPprofMutexProfileRequest): this;

  /**
   * PprofMutexProfileRequest debug.
   */
  debug: boolean;

  /**
   * Creates a new PprofMutexProfileRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PprofMutexProfileRequest instance
   */
  static create(
    properties?: replit$goval$api$IPprofMutexProfileRequest
  ): replit$goval$api$PprofMutexProfileRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofMutexProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PprofMutexProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofMutexProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PprofMutexProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PprofMutexProfileRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PprofMutexProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PprofMutexProfileRequest;

  /**
   * Decodes a PprofMutexProfileRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PprofMutexProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PprofMutexProfileRequest;

  /**
   * Verifies a PprofMutexProfileRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PprofMutexProfileRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PprofMutexProfileRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PprofMutexProfileRequest;

  /**
   * Creates a plain object from a PprofMutexProfileRequest message. Also converts values to other types if specified.
   * @param message PprofMutexProfileRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PprofMutexProfileRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PprofMutexProfileRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PprofResponse.
 */
declare type replit$goval$api$IPprofResponse = {|
  /**
   * PprofResponse id
   */
  id?: string | null,

  /**
   * PprofResponse profile
   */
  profile?: Uint8Array | null,
|};

/**
 * Represents a PprofResponse.
 */
declare class replit$goval$api$PprofResponse {
  /**
   * Constructs a new PprofResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPprofResponse): this;

  /**
   * PprofResponse id.
   */
  id: string;

  /**
   * PprofResponse profile.
   */
  profile: Uint8Array;

  /**
   * Creates a new PprofResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PprofResponse instance
   */
  static create(
    properties?: replit$goval$api$IPprofResponse
  ): replit$goval$api$PprofResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PprofResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PprofResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PprofResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PprofResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PprofResponse;

  /**
   * Decodes a PprofResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PprofResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PprofResponse;

  /**
   * Verifies a PprofResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PprofResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PprofResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PprofResponse;

  /**
   * Creates a plain object from a PprofResponse message. Also converts values to other types if specified.
   * @param message PprofResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PprofResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PprofResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PTYConfig.
 */
declare type replit$goval$api$IPTYConfig = {|
  /**
   * PTYConfig pipeMode
   */
  pipeMode?: boolean | null,
|};

/**
 * Represents a PTYConfig.
 */
declare class replit$goval$api$PTYConfig {
  /**
   * Constructs a new PTYConfig.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPTYConfig): this;

  /**
   * PTYConfig pipeMode.
   */
  pipeMode: boolean;

  /**
   * Creates a new PTYConfig instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PTYConfig instance
   */
  static create(
    properties?: replit$goval$api$IPTYConfig
  ): replit$goval$api$PTYConfig;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PTYConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PTYConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PTYConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PTYConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PTYConfig message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PTYConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PTYConfig;

  /**
   * Decodes a PTYConfig message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PTYConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PTYConfig;

  /**
   * Verifies a PTYConfig message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PTYConfig message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PTYConfig
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PTYConfig;

  /**
   * Creates a plain object from a PTYConfig message. Also converts values to other types if specified.
   * @param message PTYConfig
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PTYConfig,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PTYConfig to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugMain.
 */
declare type replit$goval$api$IDebugMain = {|
  /**
   * DebugMain session
   */
  session?: string | null,

  /**
   * DebugMain readOnly
   */
  readOnly?: boolean | null,
|};

/**
 * Represents a DebugMain.
 */
declare class replit$goval$api$DebugMain {
  /**
   * Constructs a new DebugMain.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDebugMain): this;

  /**
   * DebugMain session.
   */
  session: string;

  /**
   * DebugMain readOnly.
   */
  readOnly: boolean;

  /**
   * Creates a new DebugMain instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugMain instance
   */
  static create(
    properties?: replit$goval$api$IDebugMain
  ): replit$goval$api$DebugMain;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugMain message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DebugMain,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugMain message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DebugMain,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugMain message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugMain
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DebugMain;

  /**
   * Decodes a DebugMain message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugMain
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DebugMain;

  /**
   * Verifies a DebugMain message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugMain message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugMain
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DebugMain;

  /**
   * Creates a plain object from a DebugMain message. Also converts values to other types if specified.
   * @param message DebugMain
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DebugMain,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugMain to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugMainReply.
 */
declare type replit$goval$api$IDebugMainReply = {|
  /**
   * DebugMainReply joined
   */
  joined?: boolean | null,

  /**
   * DebugMainReply protocol
   */
  protocol?: $Values<typeof replit$goval$api$DebugMainReply$Protocol> | null,
|};

/**
 * Represents a DebugMainReply.
 */
declare class replit$goval$api$DebugMainReply {
  /**
   * Constructs a new DebugMainReply.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDebugMainReply): this;

  /**
   * DebugMainReply joined.
   */
  joined: boolean;

  /**
   * DebugMainReply protocol.
   */
  protocol: $Values<typeof replit$goval$api$DebugMainReply$Protocol>;

  /**
   * Creates a new DebugMainReply instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugMainReply instance
   */
  static create(
    properties?: replit$goval$api$IDebugMainReply
  ): replit$goval$api$DebugMainReply;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugMainReply message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DebugMainReply,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugMainReply message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DebugMainReply,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugMainReply message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugMainReply
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DebugMainReply;

  /**
   * Decodes a DebugMainReply message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugMainReply
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DebugMainReply;

  /**
   * Verifies a DebugMainReply message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugMainReply message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugMainReply
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DebugMainReply;

  /**
   * Creates a plain object from a DebugMainReply message. Also converts values to other types if specified.
   * @param message DebugMainReply
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DebugMainReply,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugMainReply to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Protocol: typeof replit$goval$api$DebugMainReply$Protocol;
}

/**
 * Protocol enum.
 */

declare var replit$goval$api$DebugMainReply$Protocol: {|
  +DAP: 0, // 0
|};

/**
 * Properties of a DebugState.
 */
declare type replit$goval$api$IDebugState = {|
  /**
   * DebugState session
   */
  session?: string | null,

  /**
   * DebugState state
   */
  state?: $Values<typeof replit$goval$api$State> | null,
|};

/**
 * Represents a DebugState.
 */
declare class replit$goval$api$DebugState {
  /**
   * Constructs a new DebugState.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDebugState): this;

  /**
   * DebugState session.
   */
  session: string;

  /**
   * DebugState state.
   */
  state: $Values<typeof replit$goval$api$State>;

  /**
   * Creates a new DebugState instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugState instance
   */
  static create(
    properties?: replit$goval$api$IDebugState
  ): replit$goval$api$DebugState;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugState message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DebugState,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugState message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DebugState,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugState message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugState
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DebugState;

  /**
   * Decodes a DebugState message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugState
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DebugState;

  /**
   * Verifies a DebugState message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugState message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugState
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DebugState;

  /**
   * Creates a plain object from a DebugState message. Also converts values to other types if specified.
   * @param message DebugState
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DebugState,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugState to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugInput.
 */
declare type replit$goval$api$IDebugInput = {|
  /**
   * DebugInput session
   */
  session?: string | null,

  /**
   * DebugInput input
   */
  input?: string | null,

  /**
   * DebugInput adapterInput
   */
  adapterInput?: string | null,
|};

/**
 * Represents a DebugInput.
 */
declare class replit$goval$api$DebugInput {
  /**
   * Constructs a new DebugInput.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDebugInput): this;

  /**
   * DebugInput session.
   */
  session: string;

  /**
   * DebugInput input.
   */
  input?: string | null;

  /**
   * DebugInput adapterInput.
   */
  adapterInput?: string | null;

  /**
   * DebugInput stream.
   */
  stream?: "input" | "adapterInput";

  /**
   * Creates a new DebugInput instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugInput instance
   */
  static create(
    properties?: replit$goval$api$IDebugInput
  ): replit$goval$api$DebugInput;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugInput message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DebugInput,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugInput message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DebugInput,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugInput message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugInput
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DebugInput;

  /**
   * Decodes a DebugInput message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugInput
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DebugInput;

  /**
   * Verifies a DebugInput message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugInput message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugInput
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DebugInput;

  /**
   * Creates a plain object from a DebugInput message. Also converts values to other types if specified.
   * @param message DebugInput
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DebugInput,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugInput to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugOutput.
 */
declare type replit$goval$api$IDebugOutput = {|
  /**
   * DebugOutput session
   */
  session?: string | null,

  /**
   * DebugOutput output
   */
  output?: string | null,

  /**
   * DebugOutput adapterOutput
   */
  adapterOutput?: string | null,
|};

/**
 * Represents a DebugOutput.
 */
declare class replit$goval$api$DebugOutput {
  /**
   * Constructs a new DebugOutput.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDebugOutput): this;

  /**
   * DebugOutput session.
   */
  session: string;

  /**
   * DebugOutput output.
   */
  output?: string | null;

  /**
   * DebugOutput adapterOutput.
   */
  adapterOutput?: string | null;

  /**
   * DebugOutput stream.
   */
  stream?: "output" | "adapterOutput";

  /**
   * Creates a new DebugOutput instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugOutput instance
   */
  static create(
    properties?: replit$goval$api$IDebugOutput
  ): replit$goval$api$DebugOutput;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugOutput message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DebugOutput,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugOutput message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DebugOutput,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugOutput message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugOutput
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DebugOutput;

  /**
   * Decodes a DebugOutput message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugOutput
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DebugOutput;

  /**
   * Verifies a DebugOutput message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugOutput message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugOutput
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DebugOutput;

  /**
   * Creates a plain object from a DebugOutput message. Also converts values to other types if specified.
   * @param message DebugOutput
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DebugOutput,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugOutput to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugStop.
 */
declare type replit$goval$api$IDebugStop = {|
  /**
   * DebugStop session
   */
  session?: string | null,
|};

/**
 * Represents a DebugStop.
 */
declare class replit$goval$api$DebugStop {
  /**
   * Constructs a new DebugStop.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDebugStop): this;

  /**
   * DebugStop session.
   */
  session: string;

  /**
   * Creates a new DebugStop instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugStop instance
   */
  static create(
    properties?: replit$goval$api$IDebugStop
  ): replit$goval$api$DebugStop;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugStop message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DebugStop,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugStop message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DebugStop,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugStop message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugStop
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DebugStop;

  /**
   * Decodes a DebugStop message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugStop
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DebugStop;

  /**
   * Verifies a DebugStop message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugStop message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugStop
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DebugStop;

  /**
   * Creates a plain object from a DebugStop message. Also converts values to other types if specified.
   * @param message DebugStop
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DebugStop,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugStop to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugLeave.
 */
declare type replit$goval$api$IDebugLeave = {|
  /**
   * DebugLeave session
   */
  session?: string | null,
|};

/**
 * Represents a DebugLeave.
 */
declare class replit$goval$api$DebugLeave {
  /**
   * Constructs a new DebugLeave.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDebugLeave): this;

  /**
   * DebugLeave session.
   */
  session: string;

  /**
   * Creates a new DebugLeave instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugLeave instance
   */
  static create(
    properties?: replit$goval$api$IDebugLeave
  ): replit$goval$api$DebugLeave;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugLeave message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DebugLeave,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugLeave message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DebugLeave,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugLeave message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugLeave
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DebugLeave;

  /**
   * Decodes a DebugLeave message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugLeave
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DebugLeave;

  /**
   * Verifies a DebugLeave message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugLeave message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugLeave
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DebugLeave;

  /**
   * Creates a plain object from a DebugLeave message. Also converts values to other types if specified.
   * @param message DebugLeave
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DebugLeave,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugLeave to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugSessions.
 */
declare type replit$goval$api$IDebugSessions = {|
  /**
   * DebugSessions sessions
   */
  sessions?: {|
    [k: string]: $Values<typeof replit$goval$api$State>,
  |} | null,
|};

/**
 * Represents a DebugSessions.
 */
declare class replit$goval$api$DebugSessions {
  /**
   * Constructs a new DebugSessions.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDebugSessions): this;

  /**
   * DebugSessions sessions.
   */
  sessions: {|
    [k: string]: $Values<typeof replit$goval$api$State>,
  |};

  /**
   * Creates a new DebugSessions instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugSessions instance
   */
  static create(
    properties?: replit$goval$api$IDebugSessions
  ): replit$goval$api$DebugSessions;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugSessions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DebugSessions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugSessions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DebugSessions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugSessions message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugSessions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DebugSessions;

  /**
   * Decodes a DebugSessions message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugSessions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DebugSessions;

  /**
   * Verifies a DebugSessions message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugSessions message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugSessions
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DebugSessions;

  /**
   * Creates a plain object from a DebugSessions message. Also converts values to other types if specified.
   * @param message DebugSessions
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DebugSessions,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugSessions to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitGetRequest.
 */
declare type replit$goval$api$IDotReplitGetRequest = {||};

/**
 * Represents a DotReplitGetRequest.
 */
declare class replit$goval$api$DotReplitGetRequest {
  /**
   * Constructs a new DotReplitGetRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDotReplitGetRequest): this;

  /**
   * Creates a new DotReplitGetRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitGetRequest instance
   */
  static create(
    properties?: replit$goval$api$IDotReplitGetRequest
  ): replit$goval$api$DotReplitGetRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitGetRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DotReplitGetRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitGetRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DotReplitGetRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitGetRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitGetRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DotReplitGetRequest;

  /**
   * Decodes a DotReplitGetRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitGetRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DotReplitGetRequest;

  /**
   * Verifies a DotReplitGetRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitGetRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitGetRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DotReplitGetRequest;

  /**
   * Creates a plain object from a DotReplitGetRequest message. Also converts values to other types if specified.
   * @param message DotReplitGetRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DotReplitGetRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitGetRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitGetResponse.
 */
declare type replit$goval$api$IDotReplitGetResponse = {|
  /**
   * DotReplitGetResponse dotReplit
   */
  dotReplit?: replit$goval$api$DotReplit | replit$goval$api$IDotReplit | null,
|};

/**
 * Represents a DotReplitGetResponse.
 */
declare class replit$goval$api$DotReplitGetResponse {
  /**
   * Constructs a new DotReplitGetResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDotReplitGetResponse): this;

  /**
   * DotReplitGetResponse dotReplit.
   */
  dotReplit?: replit$goval$api$DotReplit | null;

  /**
   * Creates a new DotReplitGetResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitGetResponse instance
   */
  static create(
    properties?: replit$goval$api$IDotReplitGetResponse
  ): replit$goval$api$DotReplitGetResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitGetResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DotReplitGetResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitGetResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DotReplitGetResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitGetResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitGetResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DotReplitGetResponse;

  /**
   * Decodes a DotReplitGetResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitGetResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DotReplitGetResponse;

  /**
   * Verifies a DotReplitGetResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitGetResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitGetResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DotReplitGetResponse;

  /**
   * Creates a plain object from a DotReplitGetResponse message. Also converts values to other types if specified.
   * @param message DotReplitGetResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DotReplitGetResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitGetResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a RunConfigGetRequest.
 */
declare type replit$goval$api$IRunConfigGetRequest = {||};

/**
 * Represents a RunConfigGetRequest.
 */
declare class replit$goval$api$RunConfigGetRequest {
  /**
   * Constructs a new RunConfigGetRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IRunConfigGetRequest): this;

  /**
   * Creates a new RunConfigGetRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns RunConfigGetRequest instance
   */
  static create(
    properties?: replit$goval$api$IRunConfigGetRequest
  ): replit$goval$api$RunConfigGetRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RunConfigGetRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$RunConfigGetRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RunConfigGetRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$RunConfigGetRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a RunConfigGetRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns RunConfigGetRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$RunConfigGetRequest;

  /**
   * Decodes a RunConfigGetRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns RunConfigGetRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$RunConfigGetRequest;

  /**
   * Verifies a RunConfigGetRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a RunConfigGetRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns RunConfigGetRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$RunConfigGetRequest;

  /**
   * Creates a plain object from a RunConfigGetRequest message. Also converts values to other types if specified.
   * @param message RunConfigGetRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$RunConfigGetRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this RunConfigGetRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a RunConfigGetResponse.
 */
declare type replit$goval$api$IRunConfigGetResponse = {|
  /**
   * RunConfigGetResponse interp
   */
  interp?:
    | replit$goval$api$DotReplitInterp
    | replit$goval$api$IDotReplitInterp
    | null,

  /**
   * RunConfigGetResponse run
   */
  run?:
    | replit$goval$api$RunConfigGetResponse$Run
    | replit$goval$api$RunConfigGetResponse$IRun
    | null,
|};

/**
 * Represents a RunConfigGetResponse.
 */
declare class replit$goval$api$RunConfigGetResponse {
  /**
   * Constructs a new RunConfigGetResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IRunConfigGetResponse): this;

  /**
   * RunConfigGetResponse interp.
   */
  interp?: replit$goval$api$DotReplitInterp | null;

  /**
   * RunConfigGetResponse run.
   */
  run?: replit$goval$api$RunConfigGetResponse$Run | null;

  /**
   * RunConfigGetResponse config.
   */
  config?: "interp" | "run";

  /**
   * Creates a new RunConfigGetResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns RunConfigGetResponse instance
   */
  static create(
    properties?: replit$goval$api$IRunConfigGetResponse
  ): replit$goval$api$RunConfigGetResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RunConfigGetResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$RunConfigGetResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RunConfigGetResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$RunConfigGetResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a RunConfigGetResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns RunConfigGetResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$RunConfigGetResponse;

  /**
   * Decodes a RunConfigGetResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns RunConfigGetResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$RunConfigGetResponse;

  /**
   * Verifies a RunConfigGetResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a RunConfigGetResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns RunConfigGetResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$RunConfigGetResponse;

  /**
   * Creates a plain object from a RunConfigGetResponse message. Also converts values to other types if specified.
   * @param message RunConfigGetResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$RunConfigGetResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this RunConfigGetResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static IRun: Class<replit$goval$api$RunConfigGetResponse$IRun>;
  static Run: typeof replit$goval$api$RunConfigGetResponse$Run;
}

/**
 * Properties of a Run.
 */
declare type replit$goval$api$RunConfigGetResponse$IRun = {|
  /**
   * Run compile
   */
  compile?: replit$goval$api$Exec | replit$goval$api$IExec | null,

  /**
   * Run run
   */
  run?: replit$goval$api$Exec | replit$goval$api$IExec | null,
|};

/**
 * Represents a Run.
 */
declare class replit$goval$api$RunConfigGetResponse$Run {
  /**
   * Constructs a new Run.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$RunConfigGetResponse$IRun): this;

  /**
   * Run compile.
   */
  compile?: replit$goval$api$Exec | null;

  /**
   * Run run.
   */
  run?: replit$goval$api$Exec | null;

  /**
   * Creates a new Run instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Run instance
   */
  static create(
    properties?: replit$goval$api$RunConfigGetResponse$IRun
  ): replit$goval$api$RunConfigGetResponse$Run;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Run message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$RunConfigGetResponse$Run,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Run message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$RunConfigGetResponse$Run,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Run message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Run
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$RunConfigGetResponse$Run;

  /**
   * Decodes a Run message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Run
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$RunConfigGetResponse$Run;

  /**
   * Verifies a Run message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Run message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Run
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$RunConfigGetResponse$Run;

  /**
   * Creates a plain object from a Run message. Also converts values to other types if specified.
   * @param message Run
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$RunConfigGetResponse$Run,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Run to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitUpdateOp.
 */
declare type replit$goval$api$IDotReplitUpdateOp = {|
  /**
   * DotReplitUpdateOp op
   */
  op?: string | null,

  /**
   * DotReplitUpdateOp path
   */
  path?: string | null,

  /**
   * DotReplitUpdateOp value
   */
  value?: string | null,
|};

/**
 * Represents a DotReplitUpdateOp.
 */
declare class replit$goval$api$DotReplitUpdateOp {
  /**
   * Constructs a new DotReplitUpdateOp.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDotReplitUpdateOp): this;

  /**
   * DotReplitUpdateOp op.
   */
  op: string;

  /**
   * DotReplitUpdateOp path.
   */
  path: string;

  /**
   * DotReplitUpdateOp value.
   */
  value: string;

  /**
   * Creates a new DotReplitUpdateOp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitUpdateOp instance
   */
  static create(
    properties?: replit$goval$api$IDotReplitUpdateOp
  ): replit$goval$api$DotReplitUpdateOp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUpdateOp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DotReplitUpdateOp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUpdateOp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DotReplitUpdateOp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitUpdateOp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitUpdateOp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DotReplitUpdateOp;

  /**
   * Decodes a DotReplitUpdateOp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitUpdateOp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DotReplitUpdateOp;

  /**
   * Verifies a DotReplitUpdateOp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitUpdateOp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitUpdateOp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DotReplitUpdateOp;

  /**
   * Creates a plain object from a DotReplitUpdateOp message. Also converts values to other types if specified.
   * @param message DotReplitUpdateOp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DotReplitUpdateOp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitUpdateOp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitUpdateRequest.
 */
declare type replit$goval$api$IDotReplitUpdateRequest = {|
  /**
   * DotReplitUpdateRequest ops
   */
  ops?:
    | (
        | replit$goval$api$DotReplitUpdateOp
        | replit$goval$api$IDotReplitUpdateOp
      )[]
    | null,
|};

/**
 * Represents a DotReplitUpdateRequest.
 */
declare class replit$goval$api$DotReplitUpdateRequest {
  /**
   * Constructs a new DotReplitUpdateRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDotReplitUpdateRequest): this;

  /**
   * DotReplitUpdateRequest ops.
   */
  ops: replit$goval$api$DotReplitUpdateOp[];

  /**
   * Creates a new DotReplitUpdateRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitUpdateRequest instance
   */
  static create(
    properties?: replit$goval$api$IDotReplitUpdateRequest
  ): replit$goval$api$DotReplitUpdateRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUpdateRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DotReplitUpdateRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUpdateRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DotReplitUpdateRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitUpdateRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitUpdateRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DotReplitUpdateRequest;

  /**
   * Decodes a DotReplitUpdateRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitUpdateRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DotReplitUpdateRequest;

  /**
   * Verifies a DotReplitUpdateRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitUpdateRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitUpdateRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DotReplitUpdateRequest;

  /**
   * Creates a plain object from a DotReplitUpdateRequest message. Also converts values to other types if specified.
   * @param message DotReplitUpdateRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DotReplitUpdateRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitUpdateRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitUpdateResponse.
 */
declare type replit$goval$api$IDotReplitUpdateResponse = {||};

/**
 * Represents a DotReplitUpdateResponse.
 */
declare class replit$goval$api$DotReplitUpdateResponse {
  /**
   * Constructs a new DotReplitUpdateResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDotReplitUpdateResponse): this;

  /**
   * Creates a new DotReplitUpdateResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitUpdateResponse instance
   */
  static create(
    properties?: replit$goval$api$IDotReplitUpdateResponse
  ): replit$goval$api$DotReplitUpdateResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUpdateResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DotReplitUpdateResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUpdateResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DotReplitUpdateResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitUpdateResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitUpdateResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DotReplitUpdateResponse;

  /**
   * Decodes a DotReplitUpdateResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitUpdateResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DotReplitUpdateResponse;

  /**
   * Verifies a DotReplitUpdateResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitUpdateResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitUpdateResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DotReplitUpdateResponse;

  /**
   * Creates a plain object from a DotReplitUpdateResponse message. Also converts values to other types if specified.
   * @param message DotReplitUpdateResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DotReplitUpdateResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitUpdateResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugAddBreakpointRequest.
 */
declare type replit$goval$api$IDebugAddBreakpointRequest = {|
  /**
   * DebugAddBreakpointRequest path
   */
  path?: string | null,

  /**
   * DebugAddBreakpointRequest otVersion
   */
  otVersion?: number | null,

  /**
   * DebugAddBreakpointRequest otIndex
   */
  otIndex?: number | null,

  /**
   * DebugAddBreakpointRequest sessionLocal
   */
  sessionLocal?: boolean | null,

  /**
   * DebugAddBreakpointRequest line
   */
  line?: number | null,

  /**
   * DebugAddBreakpointRequest logMessage
   */
  logMessage?: string | null,
|};

/**
 * Represents a DebugAddBreakpointRequest.
 */
declare class replit$goval$api$DebugAddBreakpointRequest {
  /**
   * Constructs a new DebugAddBreakpointRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDebugAddBreakpointRequest): this;

  /**
   * DebugAddBreakpointRequest path.
   */
  path: string;

  /**
   * DebugAddBreakpointRequest otVersion.
   */
  otVersion: number;

  /**
   * DebugAddBreakpointRequest otIndex.
   */
  otIndex: number;

  /**
   * DebugAddBreakpointRequest sessionLocal.
   */
  sessionLocal: boolean;

  /**
   * DebugAddBreakpointRequest line.
   */
  line: number;

  /**
   * DebugAddBreakpointRequest logMessage.
   */
  logMessage: string;

  /**
   * Creates a new DebugAddBreakpointRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugAddBreakpointRequest instance
   */
  static create(
    properties?: replit$goval$api$IDebugAddBreakpointRequest
  ): replit$goval$api$DebugAddBreakpointRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugAddBreakpointRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DebugAddBreakpointRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugAddBreakpointRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DebugAddBreakpointRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugAddBreakpointRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugAddBreakpointRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DebugAddBreakpointRequest;

  /**
   * Decodes a DebugAddBreakpointRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugAddBreakpointRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DebugAddBreakpointRequest;

  /**
   * Verifies a DebugAddBreakpointRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugAddBreakpointRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugAddBreakpointRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DebugAddBreakpointRequest;

  /**
   * Creates a plain object from a DebugAddBreakpointRequest message. Also converts values to other types if specified.
   * @param message DebugAddBreakpointRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DebugAddBreakpointRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugAddBreakpointRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugUpdateBreakpointRequest.
 */
declare type replit$goval$api$IDebugUpdateBreakpointRequest = {|
  /**
   * DebugUpdateBreakpointRequest breakpointId
   */
  breakpointId?: string | null,

  /**
   * DebugUpdateBreakpointRequest logMessage
   */
  logMessage?: string | null,
|};

/**
 * Represents a DebugUpdateBreakpointRequest.
 */
declare class replit$goval$api$DebugUpdateBreakpointRequest {
  /**
   * Constructs a new DebugUpdateBreakpointRequest.
   * @param [properties] Properties to set
   */
  constructor(
    properties?: replit$goval$api$IDebugUpdateBreakpointRequest
  ): this;

  /**
   * DebugUpdateBreakpointRequest breakpointId.
   */
  breakpointId: string;

  /**
   * DebugUpdateBreakpointRequest logMessage.
   */
  logMessage: string;

  /**
   * Creates a new DebugUpdateBreakpointRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugUpdateBreakpointRequest instance
   */
  static create(
    properties?: replit$goval$api$IDebugUpdateBreakpointRequest
  ): replit$goval$api$DebugUpdateBreakpointRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugUpdateBreakpointRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DebugUpdateBreakpointRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugUpdateBreakpointRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DebugUpdateBreakpointRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugUpdateBreakpointRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugUpdateBreakpointRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DebugUpdateBreakpointRequest;

  /**
   * Decodes a DebugUpdateBreakpointRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugUpdateBreakpointRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DebugUpdateBreakpointRequest;

  /**
   * Verifies a DebugUpdateBreakpointRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugUpdateBreakpointRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugUpdateBreakpointRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DebugUpdateBreakpointRequest;

  /**
   * Creates a plain object from a DebugUpdateBreakpointRequest message. Also converts values to other types if specified.
   * @param message DebugUpdateBreakpointRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DebugUpdateBreakpointRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugUpdateBreakpointRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugRemoveBreakpointRequest.
 */
declare type replit$goval$api$IDebugRemoveBreakpointRequest = {|
  /**
   * DebugRemoveBreakpointRequest breakpointId
   */
  breakpointId?: string | null,
|};

/**
 * Represents a DebugRemoveBreakpointRequest.
 */
declare class replit$goval$api$DebugRemoveBreakpointRequest {
  /**
   * Constructs a new DebugRemoveBreakpointRequest.
   * @param [properties] Properties to set
   */
  constructor(
    properties?: replit$goval$api$IDebugRemoveBreakpointRequest
  ): this;

  /**
   * DebugRemoveBreakpointRequest breakpointId.
   */
  breakpointId: string;

  /**
   * Creates a new DebugRemoveBreakpointRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugRemoveBreakpointRequest instance
   */
  static create(
    properties?: replit$goval$api$IDebugRemoveBreakpointRequest
  ): replit$goval$api$DebugRemoveBreakpointRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugRemoveBreakpointRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DebugRemoveBreakpointRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugRemoveBreakpointRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DebugRemoveBreakpointRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugRemoveBreakpointRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugRemoveBreakpointRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DebugRemoveBreakpointRequest;

  /**
   * Decodes a DebugRemoveBreakpointRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugRemoveBreakpointRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DebugRemoveBreakpointRequest;

  /**
   * Verifies a DebugRemoveBreakpointRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugRemoveBreakpointRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugRemoveBreakpointRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DebugRemoveBreakpointRequest;

  /**
   * Creates a plain object from a DebugRemoveBreakpointRequest message. Also converts values to other types if specified.
   * @param message DebugRemoveBreakpointRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DebugRemoveBreakpointRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugRemoveBreakpointRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugBreakpointEvent.
 */
declare type replit$goval$api$IDebugBreakpointEvent = {|
  /**
   * DebugBreakpointEvent path
   */
  path?: string | null,

  /**
   * DebugBreakpointEvent absolutePath
   */
  absolutePath?: string | null,

  /**
   * DebugBreakpointEvent breakpoints
   */
  breakpoints?:
    | (replit$goval$api$DebugBreakpoint | replit$goval$api$IDebugBreakpoint)[]
    | null,
|};

/**
 * Represents a DebugBreakpointEvent.
 */
declare class replit$goval$api$DebugBreakpointEvent {
  /**
   * Constructs a new DebugBreakpointEvent.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDebugBreakpointEvent): this;

  /**
   * DebugBreakpointEvent path.
   */
  path: string;

  /**
   * DebugBreakpointEvent absolutePath.
   */
  absolutePath: string;

  /**
   * DebugBreakpointEvent breakpoints.
   */
  breakpoints: replit$goval$api$DebugBreakpoint[];

  /**
   * Creates a new DebugBreakpointEvent instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugBreakpointEvent instance
   */
  static create(
    properties?: replit$goval$api$IDebugBreakpointEvent
  ): replit$goval$api$DebugBreakpointEvent;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugBreakpointEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DebugBreakpointEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugBreakpointEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DebugBreakpointEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugBreakpointEvent message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugBreakpointEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DebugBreakpointEvent;

  /**
   * Decodes a DebugBreakpointEvent message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugBreakpointEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DebugBreakpointEvent;

  /**
   * Verifies a DebugBreakpointEvent message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugBreakpointEvent message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugBreakpointEvent
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DebugBreakpointEvent;

  /**
   * Creates a plain object from a DebugBreakpointEvent message. Also converts values to other types if specified.
   * @param message DebugBreakpointEvent
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DebugBreakpointEvent,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugBreakpointEvent to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugBreakpoint.
 */
declare type replit$goval$api$IDebugBreakpoint = {|
  /**
   * DebugBreakpoint breakpointId
   */
  breakpointId?: string | null,

  /**
   * DebugBreakpoint line
   */
  line?: number | null,

  /**
   * DebugBreakpoint otVersion
   */
  otVersion?: number | null,

  /**
   * DebugBreakpoint otIndex
   */
  otIndex?: number | null,

  /**
   * DebugBreakpoint sessionLocal
   */
  sessionLocal?: boolean | null,

  /**
   * DebugBreakpoint logMessage
   */
  logMessage?: string | null,
|};

/**
 * Represents a DebugBreakpoint.
 */
declare class replit$goval$api$DebugBreakpoint {
  /**
   * Constructs a new DebugBreakpoint.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDebugBreakpoint): this;

  /**
   * DebugBreakpoint breakpointId.
   */
  breakpointId: string;

  /**
   * DebugBreakpoint line.
   */
  line: number;

  /**
   * DebugBreakpoint otVersion.
   */
  otVersion: number;

  /**
   * DebugBreakpoint otIndex.
   */
  otIndex: number;

  /**
   * DebugBreakpoint sessionLocal.
   */
  sessionLocal: boolean;

  /**
   * DebugBreakpoint logMessage.
   */
  logMessage: string;

  /**
   * Creates a new DebugBreakpoint instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugBreakpoint instance
   */
  static create(
    properties?: replit$goval$api$IDebugBreakpoint
  ): replit$goval$api$DebugBreakpoint;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugBreakpoint message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DebugBreakpoint,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugBreakpoint message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DebugBreakpoint,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugBreakpoint message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugBreakpoint
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DebugBreakpoint;

  /**
   * Decodes a DebugBreakpoint message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugBreakpoint
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DebugBreakpoint;

  /**
   * Verifies a DebugBreakpoint message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugBreakpoint message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugBreakpoint
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DebugBreakpoint;

  /**
   * Creates a plain object from a DebugBreakpoint message. Also converts values to other types if specified.
   * @param message DebugBreakpoint
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DebugBreakpoint,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugBreakpoint to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplit.
 */
declare type replit$goval$api$IDotReplit = {|
  /**
   * DotReplit run
   */
  run?: replit$goval$api$Exec | replit$goval$api$IExec | null,

  /**
   * DotReplit compile
   */
  compile?: replit$goval$api$Exec | replit$goval$api$IExec | null,

  /**
   * DotReplit debugger
   */
  debugger?:
    | replit$goval$api$DebuggerConfig
    | replit$goval$api$IDebuggerConfig
    | null,

  /**
   * DotReplit language
   */
  language?: string | null,

  /**
   * DotReplit onBoot
   */
  onBoot?: replit$goval$api$Exec | replit$goval$api$IExec | null,

  /**
   * DotReplit packager
   */
  packager?:
    | replit$goval$api$DotReplitPackager
    | replit$goval$api$IDotReplitPackager
    | null,

  /**
   * DotReplit interpreter
   */
  interpreter?:
    | replit$goval$api$DotReplitInterp
    | replit$goval$api$IDotReplitInterp
    | null,

  /**
   * DotReplit entrypoint
   */
  entrypoint?: string | null,

  /**
   * DotReplit languages
   */
  languages?: {|
    [k: string]:
      | replit$goval$api$DotReplitLanguage
      | replit$goval$api$IDotReplitLanguage,
  |} | null,

  /**
   * DotReplit unitTest
   */
  unitTest?:
    | replit$goval$api$DotReplitUnitTest
    | replit$goval$api$IDotReplitUnitTest
    | null,

  /**
   * DotReplit hidden
   */
  hidden?: string[] | null,

  /**
   * DotReplit nix
   */
  nix?: replit$goval$api$NixConfig | replit$goval$api$INixConfig | null,

  /**
   * DotReplit audio
   */
  audio?: boolean | null,

  /**
   * DotReplit hosting
   */
  hosting?:
    | replit$goval$api$HostingConfig
    | replit$goval$api$IHostingConfig
    | null,

  /**
   * DotReplit env
   */
  env?: {|
    [k: string]: string,
  |} | null,

  /**
   * DotReplit gitHubImport
   */
  gitHubImport?:
    | replit$goval$api$GitHubImportConfig
    | replit$goval$api$IGitHubImportConfig
    | null,

  /**
   * DotReplit auth
   */
  auth?: replit$goval$api$AuthConfig | replit$goval$api$IAuthConfig | null,

  /**
   * DotReplit hintsList
   */
  hintsList?:
    | (replit$goval$api$DotReplitHint | replit$goval$api$IDotReplitHint)[]
    | null,

  /**
   * DotReplit ports
   */
  ports?:
    | (replit$goval$api$DotReplitPort | replit$goval$api$IDotReplitPort)[]
    | null,

  /**
   * DotReplit orderedEnv
   */
  orderedEnv?:
    | (replit$goval$api$DotReplitEnvVar | replit$goval$api$IDotReplitEnvVar)[]
    | null,

  /**
   * DotReplit refreshWebViewOnFileChange
   */
  refreshWebViewOnFileChange?: string[] | null,

  /**
   * DotReplit deployment
   */
  deployment?:
    | replit$goval$api$DeploymentConfig
    | replit$goval$api$IDeploymentConfig
    | null,
|};

/**
 * Represents a DotReplit.
 */
declare class replit$goval$api$DotReplit {
  /**
   * Constructs a new DotReplit.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDotReplit): this;

  /**
   * DotReplit run.
   */
  run?: replit$goval$api$Exec | null;

  /**
   * DotReplit compile.
   */
  compile?: replit$goval$api$Exec | null;

  /**
   * DotReplit debugger.
   */
  debugger?: replit$goval$api$DebuggerConfig | null;

  /**
   * DotReplit language.
   */
  language: string;

  /**
   * DotReplit onBoot.
   */
  onBoot?: replit$goval$api$Exec | null;

  /**
   * DotReplit packager.
   */
  packager?: replit$goval$api$DotReplitPackager | null;

  /**
   * DotReplit interpreter.
   */
  interpreter?: replit$goval$api$DotReplitInterp | null;

  /**
   * DotReplit entrypoint.
   */
  entrypoint: string;

  /**
   * DotReplit languages.
   */
  languages: {|
    [k: string]: replit$goval$api$DotReplitLanguage,
  |};

  /**
   * DotReplit unitTest.
   */
  unitTest?: replit$goval$api$DotReplitUnitTest | null;

  /**
   * DotReplit hidden.
   */
  hidden: string[];

  /**
   * DotReplit nix.
   */
  nix?: replit$goval$api$NixConfig | null;

  /**
   * DotReplit audio.
   */
  audio: boolean;

  /**
   * DotReplit hosting.
   */
  hosting?: replit$goval$api$HostingConfig | null;

  /**
   * DotReplit env.
   */
  env: {|
    [k: string]: string,
  |};

  /**
   * DotReplit gitHubImport.
   */
  gitHubImport?: replit$goval$api$GitHubImportConfig | null;

  /**
   * DotReplit auth.
   */
  auth?: replit$goval$api$AuthConfig | null;

  /**
   * DotReplit hintsList.
   */
  hintsList: replit$goval$api$DotReplitHint[];

  /**
   * DotReplit ports.
   */
  ports: replit$goval$api$DotReplitPort[];

  /**
   * DotReplit orderedEnv.
   */
  orderedEnv: replit$goval$api$DotReplitEnvVar[];

  /**
   * DotReplit refreshWebViewOnFileChange.
   */
  refreshWebViewOnFileChange: string[];

  /**
   * DotReplit deployment.
   */
  deployment?: replit$goval$api$DeploymentConfig | null;

  /**
   * Creates a new DotReplit instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplit instance
   */
  static create(
    properties?: replit$goval$api$IDotReplit
  ): replit$goval$api$DotReplit;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplit message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DotReplit,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplit message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DotReplit,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplit message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplit
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DotReplit;

  /**
   * Decodes a DotReplit message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplit
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DotReplit;

  /**
   * Verifies a DotReplit message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplit message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplit
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DotReplit;

  /**
   * Creates a plain object from a DotReplit message. Also converts values to other types if specified.
   * @param message DotReplit
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DotReplit,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplit to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitEnvVar.
 */
declare type replit$goval$api$IDotReplitEnvVar = {|
  /**
   * DotReplitEnvVar key
   */
  key?: string | null,

  /**
   * DotReplitEnvVar value
   */
  value?: string | null,
|};

/**
 * Represents a DotReplitEnvVar.
 */
declare class replit$goval$api$DotReplitEnvVar {
  /**
   * Constructs a new DotReplitEnvVar.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDotReplitEnvVar): this;

  /**
   * DotReplitEnvVar key.
   */
  key: string;

  /**
   * DotReplitEnvVar value.
   */
  value: string;

  /**
   * Creates a new DotReplitEnvVar instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitEnvVar instance
   */
  static create(
    properties?: replit$goval$api$IDotReplitEnvVar
  ): replit$goval$api$DotReplitEnvVar;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitEnvVar message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DotReplitEnvVar,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitEnvVar message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DotReplitEnvVar,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitEnvVar message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitEnvVar
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DotReplitEnvVar;

  /**
   * Decodes a DotReplitEnvVar message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitEnvVar
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DotReplitEnvVar;

  /**
   * Verifies a DotReplitEnvVar message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitEnvVar message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitEnvVar
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DotReplitEnvVar;

  /**
   * Creates a plain object from a DotReplitEnvVar message. Also converts values to other types if specified.
   * @param message DotReplitEnvVar
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DotReplitEnvVar,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitEnvVar to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitPort.
 */
declare type replit$goval$api$IDotReplitPort = {|
  /**
   * DotReplitPort localPort
   */
  localPort?: number | null,

  /**
   * DotReplitPort externalPort
   */
  externalPort?: number | null,
|};

/**
 * Represents a DotReplitPort.
 */
declare class replit$goval$api$DotReplitPort {
  /**
   * Constructs a new DotReplitPort.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDotReplitPort): this;

  /**
   * DotReplitPort localPort.
   */
  localPort: number;

  /**
   * DotReplitPort externalPort.
   */
  externalPort: number;

  /**
   * Creates a new DotReplitPort instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitPort instance
   */
  static create(
    properties?: replit$goval$api$IDotReplitPort
  ): replit$goval$api$DotReplitPort;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitPort message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DotReplitPort,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitPort message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DotReplitPort,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitPort message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitPort
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DotReplitPort;

  /**
   * Decodes a DotReplitPort message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitPort
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DotReplitPort;

  /**
   * Verifies a DotReplitPort message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitPort message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitPort
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DotReplitPort;

  /**
   * Creates a plain object from a DotReplitPort message. Also converts values to other types if specified.
   * @param message DotReplitPort
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DotReplitPort,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitPort to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitHint.
 */
declare type replit$goval$api$IDotReplitHint = {|
  /**
   * DotReplitHint regex
   */
  regex?: string | null,

  /**
   * DotReplitHint message
   */
  message?: string | null,
|};

/**
 * Represents a DotReplitHint.
 */
declare class replit$goval$api$DotReplitHint {
  /**
   * Constructs a new DotReplitHint.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDotReplitHint): this;

  /**
   * DotReplitHint regex.
   */
  regex: string;

  /**
   * DotReplitHint message.
   */
  message: string;

  /**
   * Creates a new DotReplitHint instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitHint instance
   */
  static create(
    properties?: replit$goval$api$IDotReplitHint
  ): replit$goval$api$DotReplitHint;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitHint message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DotReplitHint,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitHint message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DotReplitHint,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitHint message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitHint
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DotReplitHint;

  /**
   * Decodes a DotReplitHint message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitHint
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DotReplitHint;

  /**
   * Verifies a DotReplitHint message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitHint message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitHint
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DotReplitHint;

  /**
   * Creates a plain object from a DotReplitHint message. Also converts values to other types if specified.
   * @param message DotReplitHint
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DotReplitHint,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitHint to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a GitHubImportConfig.
 */
declare type replit$goval$api$IGitHubImportConfig = {|
  /**
   * GitHubImportConfig requiredFiles
   */
  requiredFiles?: string[] | null,
|};

/**
 * Represents a GitHubImportConfig.
 */
declare class replit$goval$api$GitHubImportConfig {
  /**
   * Constructs a new GitHubImportConfig.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IGitHubImportConfig): this;

  /**
   * GitHubImportConfig requiredFiles.
   */
  requiredFiles: string[];

  /**
   * Creates a new GitHubImportConfig instance using the specified properties.
   * @param [properties] Properties to set
   * @returns GitHubImportConfig instance
   */
  static create(
    properties?: replit$goval$api$IGitHubImportConfig
  ): replit$goval$api$GitHubImportConfig;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GitHubImportConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$GitHubImportConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GitHubImportConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$GitHubImportConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a GitHubImportConfig message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns GitHubImportConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$GitHubImportConfig;

  /**
   * Decodes a GitHubImportConfig message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns GitHubImportConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$GitHubImportConfig;

  /**
   * Verifies a GitHubImportConfig message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a GitHubImportConfig message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns GitHubImportConfig
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$GitHubImportConfig;

  /**
   * Creates a plain object from a GitHubImportConfig message. Also converts values to other types if specified.
   * @param message GitHubImportConfig
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$GitHubImportConfig,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this GitHubImportConfig to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DeploymentConfig.
 */
declare type replit$goval$api$IDeploymentConfig = {|
  /**
   * DeploymentConfig run
   */
  run?: replit$goval$api$Exec | replit$goval$api$IExec | null,

  /**
   * DeploymentConfig build
   */
  build?: replit$goval$api$Exec | replit$goval$api$IExec | null,
|};

/**
 * Represents a DeploymentConfig.
 */
declare class replit$goval$api$DeploymentConfig {
  /**
   * Constructs a new DeploymentConfig.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDeploymentConfig): this;

  /**
   * DeploymentConfig run.
   */
  run?: replit$goval$api$Exec | null;

  /**
   * DeploymentConfig build.
   */
  build?: replit$goval$api$Exec | null;

  /**
   * Creates a new DeploymentConfig instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DeploymentConfig instance
   */
  static create(
    properties?: replit$goval$api$IDeploymentConfig
  ): replit$goval$api$DeploymentConfig;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DeploymentConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DeploymentConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DeploymentConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DeploymentConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DeploymentConfig message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DeploymentConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DeploymentConfig;

  /**
   * Decodes a DeploymentConfig message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DeploymentConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DeploymentConfig;

  /**
   * Verifies a DeploymentConfig message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DeploymentConfig message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DeploymentConfig
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DeploymentConfig;

  /**
   * Creates a plain object from a DeploymentConfig message. Also converts values to other types if specified.
   * @param message DeploymentConfig
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DeploymentConfig,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DeploymentConfig to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a NixConfig.
 */
declare type replit$goval$api$INixConfig = {|
  /**
   * NixConfig channel
   */
  channel?: string | null,
|};

/**
 * Represents a NixConfig.
 */
declare class replit$goval$api$NixConfig {
  /**
   * Constructs a new NixConfig.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$INixConfig): this;

  /**
   * NixConfig channel.
   */
  channel: string;

  /**
   * Creates a new NixConfig instance using the specified properties.
   * @param [properties] Properties to set
   * @returns NixConfig instance
   */
  static create(
    properties?: replit$goval$api$INixConfig
  ): replit$goval$api$NixConfig;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$NixConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message NixConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$NixConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a NixConfig message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns NixConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$NixConfig;

  /**
   * Decodes a NixConfig message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns NixConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$NixConfig;

  /**
   * Verifies a NixConfig message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a NixConfig message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns NixConfig
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$NixConfig;

  /**
   * Creates a plain object from a NixConfig message. Also converts values to other types if specified.
   * @param message NixConfig
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$NixConfig,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this NixConfig to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a HostingConfig.
 */
declare type replit$goval$api$IHostingConfig = {|
  /**
   * HostingConfig route
   */
  route?: string | null,

  /**
   * HostingConfig directory
   */
  directory?: string | null,
|};

/**
 * Represents a HostingConfig.
 */
declare class replit$goval$api$HostingConfig {
  /**
   * Constructs a new HostingConfig.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IHostingConfig): this;

  /**
   * HostingConfig route.
   */
  route: string;

  /**
   * HostingConfig directory.
   */
  directory: string;

  /**
   * Creates a new HostingConfig instance using the specified properties.
   * @param [properties] Properties to set
   * @returns HostingConfig instance
   */
  static create(
    properties?: replit$goval$api$IHostingConfig
  ): replit$goval$api$HostingConfig;

  /**
   * [object Object],[object Object],[object Object]
   * @param message HostingConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$HostingConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message HostingConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$HostingConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a HostingConfig message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns HostingConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$HostingConfig;

  /**
   * Decodes a HostingConfig message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns HostingConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$HostingConfig;

  /**
   * Verifies a HostingConfig message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a HostingConfig message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns HostingConfig
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$HostingConfig;

  /**
   * Creates a plain object from a HostingConfig message. Also converts values to other types if specified.
   * @param message HostingConfig
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$HostingConfig,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this HostingConfig to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an AuthConfig.
 */
declare type replit$goval$api$IAuthConfig = {|
  /**
   * AuthConfig pageEnabled
   */
  pageEnabled?: boolean | null,

  /**
   * AuthConfig pageTitle
   */
  pageTitle?: string | null,

  /**
   * AuthConfig pageDescription
   */
  pageDescription?: string | null,

  /**
   * AuthConfig pageColor
   */
  pageColor?: string | null,

  /**
   * AuthConfig pageImage
   */
  pageImage?: string | null,

  /**
   * AuthConfig buttonEnabled
   */
  buttonEnabled?: boolean | null,
|};

/**
 * Represents an AuthConfig.
 */
declare class replit$goval$api$AuthConfig {
  /**
   * Constructs a new AuthConfig.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IAuthConfig): this;

  /**
   * AuthConfig pageEnabled.
   */
  pageEnabled: boolean;

  /**
   * AuthConfig pageTitle.
   */
  pageTitle: string;

  /**
   * AuthConfig pageDescription.
   */
  pageDescription: string;

  /**
   * AuthConfig pageColor.
   */
  pageColor: string;

  /**
   * AuthConfig pageImage.
   */
  pageImage: string;

  /**
   * AuthConfig buttonEnabled.
   */
  buttonEnabled: boolean;

  /**
   * Creates a new AuthConfig instance using the specified properties.
   * @param [properties] Properties to set
   * @returns AuthConfig instance
   */
  static create(
    properties?: replit$goval$api$IAuthConfig
  ): replit$goval$api$AuthConfig;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AuthConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$AuthConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AuthConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$AuthConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an AuthConfig message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns AuthConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$AuthConfig;

  /**
   * Decodes an AuthConfig message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns AuthConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$AuthConfig;

  /**
   * Verifies an AuthConfig message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an AuthConfig message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns AuthConfig
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$AuthConfig;

  /**
   * Creates a plain object from an AuthConfig message. Also converts values to other types if specified.
   * @param message AuthConfig
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$AuthConfig,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this AuthConfig to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitInterp.
 */
declare type replit$goval$api$IDotReplitInterp = {|
  /**
   * DotReplitInterp command
   */
  command?: replit$goval$api$Exec | replit$goval$api$IExec | null,

  /**
   * DotReplitInterp prompt
   */
  prompt?: Uint8Array | null,
|};

/**
 * Represents a DotReplitInterp.
 */
declare class replit$goval$api$DotReplitInterp {
  /**
   * Constructs a new DotReplitInterp.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDotReplitInterp): this;

  /**
   * DotReplitInterp command.
   */
  command?: replit$goval$api$Exec | null;

  /**
   * DotReplitInterp prompt.
   */
  prompt: Uint8Array;

  /**
   * Creates a new DotReplitInterp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitInterp instance
   */
  static create(
    properties?: replit$goval$api$IDotReplitInterp
  ): replit$goval$api$DotReplitInterp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitInterp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DotReplitInterp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitInterp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DotReplitInterp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitInterp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitInterp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DotReplitInterp;

  /**
   * Decodes a DotReplitInterp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitInterp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DotReplitInterp;

  /**
   * Verifies a DotReplitInterp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitInterp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitInterp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DotReplitInterp;

  /**
   * Creates a plain object from a DotReplitInterp message. Also converts values to other types if specified.
   * @param message DotReplitInterp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DotReplitInterp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitInterp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitLanguage.
 */
declare type replit$goval$api$IDotReplitLanguage = {|
  /**
   * DotReplitLanguage pattern
   */
  pattern?: string | null,

  /**
   * DotReplitLanguage syntax
   */
  syntax?: string | null,

  /**
   * DotReplitLanguage languageServer
   */
  languageServer?:
    | replit$goval$api$LanguageServerConfig
    | replit$goval$api$ILanguageServerConfig
    | null,
|};

/**
 * Represents a DotReplitLanguage.
 */
declare class replit$goval$api$DotReplitLanguage {
  /**
   * Constructs a new DotReplitLanguage.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDotReplitLanguage): this;

  /**
   * DotReplitLanguage pattern.
   */
  pattern: string;

  /**
   * DotReplitLanguage syntax.
   */
  syntax: string;

  /**
   * DotReplitLanguage languageServer.
   */
  languageServer?: replit$goval$api$LanguageServerConfig | null;

  /**
   * Creates a new DotReplitLanguage instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitLanguage instance
   */
  static create(
    properties?: replit$goval$api$IDotReplitLanguage
  ): replit$goval$api$DotReplitLanguage;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitLanguage message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DotReplitLanguage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitLanguage message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DotReplitLanguage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitLanguage message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitLanguage
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DotReplitLanguage;

  /**
   * Decodes a DotReplitLanguage message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitLanguage
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DotReplitLanguage;

  /**
   * Verifies a DotReplitLanguage message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitLanguage message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitLanguage
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DotReplitLanguage;

  /**
   * Creates a plain object from a DotReplitLanguage message. Also converts values to other types if specified.
   * @param message DotReplitLanguage
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DotReplitLanguage,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitLanguage to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a LanguageServerConfig.
 */
declare type replit$goval$api$ILanguageServerConfig = {|
  /**
   * LanguageServerConfig startCommand
   */
  startCommand?: replit$goval$api$Exec | replit$goval$api$IExec | null,

  /**
   * LanguageServerConfig configurationJson
   */
  configurationJson?: string | null,

  /**
   * LanguageServerConfig initializationOptionsJson
   */
  initializationOptionsJson?: string | null,
|};

/**
 * Represents a LanguageServerConfig.
 */
declare class replit$goval$api$LanguageServerConfig {
  /**
   * Constructs a new LanguageServerConfig.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ILanguageServerConfig): this;

  /**
   * LanguageServerConfig startCommand.
   */
  startCommand?: replit$goval$api$Exec | null;

  /**
   * LanguageServerConfig configurationJson.
   */
  configurationJson: string;

  /**
   * LanguageServerConfig initializationOptionsJson.
   */
  initializationOptionsJson: string;

  /**
   * Creates a new LanguageServerConfig instance using the specified properties.
   * @param [properties] Properties to set
   * @returns LanguageServerConfig instance
   */
  static create(
    properties?: replit$goval$api$ILanguageServerConfig
  ): replit$goval$api$LanguageServerConfig;

  /**
   * [object Object],[object Object],[object Object]
   * @param message LanguageServerConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$LanguageServerConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message LanguageServerConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$LanguageServerConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a LanguageServerConfig message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns LanguageServerConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$LanguageServerConfig;

  /**
   * Decodes a LanguageServerConfig message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns LanguageServerConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$LanguageServerConfig;

  /**
   * Verifies a LanguageServerConfig message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a LanguageServerConfig message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns LanguageServerConfig
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$LanguageServerConfig;

  /**
   * Creates a plain object from a LanguageServerConfig message. Also converts values to other types if specified.
   * @param message LanguageServerConfig
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$LanguageServerConfig,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this LanguageServerConfig to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitPackager.
 */
declare type replit$goval$api$IDotReplitPackager = {|
  /**
   * DotReplitPackager afterInstall
   */
  afterInstall?: replit$goval$api$Exec | replit$goval$api$IExec | null,

  /**
   * DotReplitPackager language
   */
  language?: string | null,

  /**
   * DotReplitPackager features
   */
  features?:
    | replit$goval$api$DotReplitPackagerFeatures
    | replit$goval$api$IDotReplitPackagerFeatures
    | null,

  /**
   * DotReplitPackager env
   */
  env?: {|
    [k: string]: string,
  |} | null,

  /**
   * DotReplitPackager ignoredPaths
   */
  ignoredPaths?: string[] | null,

  /**
   * DotReplitPackager ignoredPackages
   */
  ignoredPackages?: string[] | null,
|};

/**
 * Represents a DotReplitPackager.
 */
declare class replit$goval$api$DotReplitPackager {
  /**
   * Constructs a new DotReplitPackager.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDotReplitPackager): this;

  /**
   * DotReplitPackager afterInstall.
   */
  afterInstall?: replit$goval$api$Exec | null;

  /**
   * DotReplitPackager language.
   */
  language: string;

  /**
   * DotReplitPackager features.
   */
  features?: replit$goval$api$DotReplitPackagerFeatures | null;

  /**
   * DotReplitPackager env.
   */
  env: {|
    [k: string]: string,
  |};

  /**
   * DotReplitPackager ignoredPaths.
   */
  ignoredPaths: string[];

  /**
   * DotReplitPackager ignoredPackages.
   */
  ignoredPackages: string[];

  /**
   * Creates a new DotReplitPackager instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitPackager instance
   */
  static create(
    properties?: replit$goval$api$IDotReplitPackager
  ): replit$goval$api$DotReplitPackager;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitPackager message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DotReplitPackager,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitPackager message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DotReplitPackager,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitPackager message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitPackager
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DotReplitPackager;

  /**
   * Decodes a DotReplitPackager message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitPackager
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DotReplitPackager;

  /**
   * Verifies a DotReplitPackager message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitPackager message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitPackager
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DotReplitPackager;

  /**
   * Creates a plain object from a DotReplitPackager message. Also converts values to other types if specified.
   * @param message DotReplitPackager
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DotReplitPackager,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitPackager to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitPackagerFeatures.
 */
declare type replit$goval$api$IDotReplitPackagerFeatures = {|
  /**
   * DotReplitPackagerFeatures packageSearch
   */
  packageSearch?: boolean | null,

  /**
   * DotReplitPackagerFeatures guessImports
   */
  guessImports?: boolean | null,

  /**
   * DotReplitPackagerFeatures enabledForHosting
   */
  enabledForHosting?: boolean | null,
|};

/**
 * Represents a DotReplitPackagerFeatures.
 */
declare class replit$goval$api$DotReplitPackagerFeatures {
  /**
   * Constructs a new DotReplitPackagerFeatures.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDotReplitPackagerFeatures): this;

  /**
   * DotReplitPackagerFeatures packageSearch.
   */
  packageSearch: boolean;

  /**
   * DotReplitPackagerFeatures guessImports.
   */
  guessImports: boolean;

  /**
   * DotReplitPackagerFeatures enabledForHosting.
   */
  enabledForHosting: boolean;

  /**
   * Creates a new DotReplitPackagerFeatures instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitPackagerFeatures instance
   */
  static create(
    properties?: replit$goval$api$IDotReplitPackagerFeatures
  ): replit$goval$api$DotReplitPackagerFeatures;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitPackagerFeatures message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DotReplitPackagerFeatures,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitPackagerFeatures message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DotReplitPackagerFeatures,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitPackagerFeatures message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitPackagerFeatures
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DotReplitPackagerFeatures;

  /**
   * Decodes a DotReplitPackagerFeatures message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitPackagerFeatures
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DotReplitPackagerFeatures;

  /**
   * Verifies a DotReplitPackagerFeatures message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitPackagerFeatures message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitPackagerFeatures
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DotReplitPackagerFeatures;

  /**
   * Creates a plain object from a DotReplitPackagerFeatures message. Also converts values to other types if specified.
   * @param message DotReplitPackagerFeatures
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DotReplitPackagerFeatures,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitPackagerFeatures to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitUnitTest.
 */
declare type replit$goval$api$IDotReplitUnitTest = {|
  /**
   * DotReplitUnitTest language
   */
  language?: string | null,
|};

/**
 * Represents a DotReplitUnitTest.
 */
declare class replit$goval$api$DotReplitUnitTest {
  /**
   * Constructs a new DotReplitUnitTest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDotReplitUnitTest): this;

  /**
   * DotReplitUnitTest language.
   */
  language: string;

  /**
   * Creates a new DotReplitUnitTest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitUnitTest instance
   */
  static create(
    properties?: replit$goval$api$IDotReplitUnitTest
  ): replit$goval$api$DotReplitUnitTest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUnitTest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DotReplitUnitTest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUnitTest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DotReplitUnitTest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitUnitTest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitUnitTest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DotReplitUnitTest;

  /**
   * Decodes a DotReplitUnitTest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitUnitTest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DotReplitUnitTest;

  /**
   * Verifies a DotReplitUnitTest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitUnitTest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitUnitTest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DotReplitUnitTest;

  /**
   * Creates a plain object from a DotReplitUnitTest message. Also converts values to other types if specified.
   * @param message DotReplitUnitTest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DotReplitUnitTest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitUnitTest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebuggerConfig.
 */
declare type replit$goval$api$IDebuggerConfig = {|
  /**
   * DebuggerConfig support
   */
  support?: boolean | null,

  /**
   * DebuggerConfig compile
   */
  compile?:
    | replit$goval$api$CompileConfig
    | replit$goval$api$ICompileConfig
    | null,

  /**
   * DebuggerConfig interactive
   */
  interactive?: replit$goval$api$DapConfig | replit$goval$api$IDapConfig | null,

  /**
   * DebuggerConfig timeTravel
   */
  timeTravel?:
    | replit$goval$api$TimeTravelConfig
    | replit$goval$api$ITimeTravelConfig
    | null,

  /**
   * DebuggerConfig dapTransport
   */
  dapTransport?: string | null,

  /**
   * DebuggerConfig dapConnectTimeout
   */
  dapConnectTimeout?: number | null,

  /**
   * DebuggerConfig dapIntegratedAdapter
   */
  dapIntegratedAdapter?:
    | replit$goval$api$DapIntegratedAdapterConfig
    | replit$goval$api$IDapIntegratedAdapterConfig
    | null,

  /**
   * DebuggerConfig dapStartCommand
   */
  dapStartCommand?: replit$goval$api$Exec | replit$goval$api$IExec | null,

  /**
   * DebuggerConfig dapInitializeMessage
   */
  dapInitializeMessage?:
    | google$protobuf$Struct
    | google$protobuf$IStruct
    | null,

  /**
   * DebuggerConfig dapLaunchMessage
   */
  dapLaunchMessage?: google$protobuf$Struct | google$protobuf$IStruct | null,
|};

/**
 * Represents a DebuggerConfig.
 */
declare class replit$goval$api$DebuggerConfig {
  /**
   * Constructs a new DebuggerConfig.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDebuggerConfig): this;

  /**
   * DebuggerConfig support.
   */
  support: boolean;

  /**
   * DebuggerConfig compile.
   */
  compile?: replit$goval$api$CompileConfig | null;

  /**
   * DebuggerConfig interactive.
   */
  interactive?: replit$goval$api$DapConfig | null;

  /**
   * DebuggerConfig timeTravel.
   */
  timeTravel?: replit$goval$api$TimeTravelConfig | null;

  /**
   * DebuggerConfig dapTransport.
   */
  dapTransport: string;

  /**
   * DebuggerConfig dapConnectTimeout.
   */
  dapConnectTimeout: number;

  /**
   * DebuggerConfig dapIntegratedAdapter.
   */
  dapIntegratedAdapter?: replit$goval$api$DapIntegratedAdapterConfig | null;

  /**
   * DebuggerConfig dapStartCommand.
   */
  dapStartCommand?: replit$goval$api$Exec | null;

  /**
   * DebuggerConfig dapInitializeMessage.
   */
  dapInitializeMessage?: google$protobuf$Struct | null;

  /**
   * DebuggerConfig dapLaunchMessage.
   */
  dapLaunchMessage?: google$protobuf$Struct | null;

  /**
   * Creates a new DebuggerConfig instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebuggerConfig instance
   */
  static create(
    properties?: replit$goval$api$IDebuggerConfig
  ): replit$goval$api$DebuggerConfig;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebuggerConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DebuggerConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebuggerConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DebuggerConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebuggerConfig message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebuggerConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DebuggerConfig;

  /**
   * Decodes a DebuggerConfig message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebuggerConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DebuggerConfig;

  /**
   * Verifies a DebuggerConfig message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebuggerConfig message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebuggerConfig
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DebuggerConfig;

  /**
   * Creates a plain object from a DebuggerConfig message. Also converts values to other types if specified.
   * @param message DebuggerConfig
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DebuggerConfig,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebuggerConfig to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a CompileConfig.
 */
declare type replit$goval$api$ICompileConfig = {|
  /**
   * CompileConfig command
   */
  command?: replit$goval$api$Exec | replit$goval$api$IExec | null,

  /**
   * CompileConfig onlyMain
   */
  onlyMain?: boolean | null,

  /**
   * CompileConfig noFileArgs
   */
  noFileArgs?: boolean | null,
|};

/**
 * Represents a CompileConfig.
 */
declare class replit$goval$api$CompileConfig {
  /**
   * Constructs a new CompileConfig.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ICompileConfig): this;

  /**
   * CompileConfig command.
   */
  command?: replit$goval$api$Exec | null;

  /**
   * CompileConfig onlyMain.
   */
  onlyMain: boolean;

  /**
   * CompileConfig noFileArgs.
   */
  noFileArgs: boolean;

  /**
   * Creates a new CompileConfig instance using the specified properties.
   * @param [properties] Properties to set
   * @returns CompileConfig instance
   */
  static create(
    properties?: replit$goval$api$ICompileConfig
  ): replit$goval$api$CompileConfig;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CompileConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$CompileConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CompileConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$CompileConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a CompileConfig message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns CompileConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$CompileConfig;

  /**
   * Decodes a CompileConfig message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns CompileConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$CompileConfig;

  /**
   * Verifies a CompileConfig message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a CompileConfig message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns CompileConfig
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$CompileConfig;

  /**
   * Creates a plain object from a CompileConfig message. Also converts values to other types if specified.
   * @param message CompileConfig
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$CompileConfig,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this CompileConfig to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DapConfig.
 */
declare type replit$goval$api$IDapConfig = {|
  /**
   * DapConfig transport
   */
  transport?: string | null,

  /**
   * DapConfig connectTimeout
   */
  connectTimeout?: number | null,

  /**
   * DapConfig integratedAdapter
   */
  integratedAdapter?:
    | replit$goval$api$DapIntegratedAdapterConfig
    | replit$goval$api$IDapIntegratedAdapterConfig
    | null,

  /**
   * DapConfig startCommand
   */
  startCommand?: replit$goval$api$Exec | replit$goval$api$IExec | null,

  /**
   * DapConfig initializeMessage
   */
  initializeMessage?: google$protobuf$Struct | google$protobuf$IStruct | null,

  /**
   * DapConfig launchMessage
   */
  launchMessage?: google$protobuf$Struct | google$protobuf$IStruct | null,
|};

/**
 * Represents a DapConfig.
 */
declare class replit$goval$api$DapConfig {
  /**
   * Constructs a new DapConfig.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDapConfig): this;

  /**
   * DapConfig transport.
   */
  transport: string;

  /**
   * DapConfig connectTimeout.
   */
  connectTimeout: number;

  /**
   * DapConfig integratedAdapter.
   */
  integratedAdapter?: replit$goval$api$DapIntegratedAdapterConfig | null;

  /**
   * DapConfig startCommand.
   */
  startCommand?: replit$goval$api$Exec | null;

  /**
   * DapConfig initializeMessage.
   */
  initializeMessage?: google$protobuf$Struct | null;

  /**
   * DapConfig launchMessage.
   */
  launchMessage?: google$protobuf$Struct | null;

  /**
   * Creates a new DapConfig instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DapConfig instance
   */
  static create(
    properties?: replit$goval$api$IDapConfig
  ): replit$goval$api$DapConfig;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DapConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DapConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DapConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DapConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DapConfig message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DapConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DapConfig;

  /**
   * Decodes a DapConfig message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DapConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DapConfig;

  /**
   * Verifies a DapConfig message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DapConfig message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DapConfig
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DapConfig;

  /**
   * Creates a plain object from a DapConfig message. Also converts values to other types if specified.
   * @param message DapConfig
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DapConfig,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DapConfig to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a TimeTravelConfig.
 */
declare type replit$goval$api$ITimeTravelConfig = {|
  /**
   * TimeTravelConfig record
   */
  record?: replit$goval$api$Exec | replit$goval$api$IExec | null,

  /**
   * TimeTravelConfig debug
   */
  debug?: replit$goval$api$DapConfig | replit$goval$api$IDapConfig | null,
|};

/**
 * Represents a TimeTravelConfig.
 */
declare class replit$goval$api$TimeTravelConfig {
  /**
   * Constructs a new TimeTravelConfig.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ITimeTravelConfig): this;

  /**
   * TimeTravelConfig record.
   */
  record?: replit$goval$api$Exec | null;

  /**
   * TimeTravelConfig debug.
   */
  debug?: replit$goval$api$DapConfig | null;

  /**
   * Creates a new TimeTravelConfig instance using the specified properties.
   * @param [properties] Properties to set
   * @returns TimeTravelConfig instance
   */
  static create(
    properties?: replit$goval$api$ITimeTravelConfig
  ): replit$goval$api$TimeTravelConfig;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TimeTravelConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$TimeTravelConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TimeTravelConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$TimeTravelConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a TimeTravelConfig message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns TimeTravelConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$TimeTravelConfig;

  /**
   * Decodes a TimeTravelConfig message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns TimeTravelConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$TimeTravelConfig;

  /**
   * Verifies a TimeTravelConfig message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a TimeTravelConfig message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns TimeTravelConfig
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$TimeTravelConfig;

  /**
   * Creates a plain object from a TimeTravelConfig message. Also converts values to other types if specified.
   * @param message TimeTravelConfig
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$TimeTravelConfig,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this TimeTravelConfig to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DapIntegratedAdapterConfig.
 */
declare type replit$goval$api$IDapIntegratedAdapterConfig = {|
  /**
   * DapIntegratedAdapterConfig dapTcpAddress
   */
  dapTcpAddress?: string | null,
|};

/**
 * Represents a DapIntegratedAdapterConfig.
 */
declare class replit$goval$api$DapIntegratedAdapterConfig {
  /**
   * Constructs a new DapIntegratedAdapterConfig.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IDapIntegratedAdapterConfig): this;

  /**
   * DapIntegratedAdapterConfig dapTcpAddress.
   */
  dapTcpAddress: string;

  /**
   * Creates a new DapIntegratedAdapterConfig instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DapIntegratedAdapterConfig instance
   */
  static create(
    properties?: replit$goval$api$IDapIntegratedAdapterConfig
  ): replit$goval$api$DapIntegratedAdapterConfig;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DapIntegratedAdapterConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$DapIntegratedAdapterConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DapIntegratedAdapterConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$DapIntegratedAdapterConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DapIntegratedAdapterConfig message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DapIntegratedAdapterConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$DapIntegratedAdapterConfig;

  /**
   * Decodes a DapIntegratedAdapterConfig message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DapIntegratedAdapterConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$DapIntegratedAdapterConfig;

  /**
   * Verifies a DapIntegratedAdapterConfig message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DapIntegratedAdapterConfig message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DapIntegratedAdapterConfig
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$DapIntegratedAdapterConfig;

  /**
   * Creates a plain object from a DapIntegratedAdapterConfig message. Also converts values to other types if specified.
   * @param message DapIntegratedAdapterConfig
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$DapIntegratedAdapterConfig,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DapIntegratedAdapterConfig to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ProxyGoingAway.
 */
declare type replit$goval$api$IProxyGoingAway = {||};

/**
 * Represents a ProxyGoingAway.
 */
declare class replit$goval$api$ProxyGoingAway {
  /**
   * Constructs a new ProxyGoingAway.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IProxyGoingAway): this;

  /**
   * Creates a new ProxyGoingAway instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ProxyGoingAway instance
   */
  static create(
    properties?: replit$goval$api$IProxyGoingAway
  ): replit$goval$api$ProxyGoingAway;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ProxyGoingAway message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ProxyGoingAway,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ProxyGoingAway message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ProxyGoingAway,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ProxyGoingAway message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ProxyGoingAway
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ProxyGoingAway;

  /**
   * Decodes a ProxyGoingAway message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ProxyGoingAway
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ProxyGoingAway;

  /**
   * Verifies a ProxyGoingAway message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ProxyGoingAway message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ProxyGoingAway
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ProxyGoingAway;

  /**
   * Creates a plain object from a ProxyGoingAway message. Also converts values to other types if specified.
   * @param message ProxyGoingAway
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ProxyGoingAway,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ProxyGoingAway to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FirewallDenied.
 */
declare type replit$goval$api$IFirewallDenied = {||};

/**
 * Represents a FirewallDenied.
 */
declare class replit$goval$api$FirewallDenied {
  /**
   * Constructs a new FirewallDenied.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IFirewallDenied): this;

  /**
   * Creates a new FirewallDenied instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FirewallDenied instance
   */
  static create(
    properties?: replit$goval$api$IFirewallDenied
  ): replit$goval$api$FirewallDenied;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FirewallDenied message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$FirewallDenied,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FirewallDenied message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$FirewallDenied,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FirewallDenied message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FirewallDenied
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$FirewallDenied;

  /**
   * Decodes a FirewallDenied message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FirewallDenied
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$FirewallDenied;

  /**
   * Verifies a FirewallDenied message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FirewallDenied message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FirewallDenied
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$FirewallDenied;

  /**
   * Creates a plain object from a FirewallDenied message. Also converts values to other types if specified.
   * @param message FirewallDenied
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$FirewallDenied,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FirewallDenied to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReplLogMessage.
 */
declare type replit$goval$api$IReplLogMessage = {|
  /**
   * ReplLogMessage timestamp
   */
  timestamp?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,

  /**
   * ReplLogMessage replId
   */
  replId?: string | null,

  /**
   * ReplLogMessage logLine
   */
  logLine?: string | null,

  /**
   * ReplLogMessage userName
   */
  userName?: string | null,
|};

/**
 * Represents a ReplLogMessage.
 */
declare class replit$goval$api$ReplLogMessage {
  /**
   * Constructs a new ReplLogMessage.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IReplLogMessage): this;

  /**
   * ReplLogMessage timestamp.
   */
  timestamp?: google$protobuf$Timestamp | null;

  /**
   * ReplLogMessage replId.
   */
  replId: string;

  /**
   * ReplLogMessage logLine.
   */
  logLine: string;

  /**
   * ReplLogMessage userName.
   */
  userName: string;

  /**
   * Creates a new ReplLogMessage instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReplLogMessage instance
   */
  static create(
    properties?: replit$goval$api$IReplLogMessage
  ): replit$goval$api$ReplLogMessage;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplLogMessage message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ReplLogMessage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplLogMessage message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ReplLogMessage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReplLogMessage message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReplLogMessage
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ReplLogMessage;

  /**
   * Decodes a ReplLogMessage message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReplLogMessage
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ReplLogMessage;

  /**
   * Verifies a ReplLogMessage message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReplLogMessage message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReplLogMessage
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ReplLogMessage;

  /**
   * Creates a plain object from a ReplLogMessage message. Also converts values to other types if specified.
   * @param message ReplLogMessage
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ReplLogMessage,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReplLogMessage to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a UserEvent.
 */
declare type replit$goval$api$IUserEvent = {|
  /**
   * UserEvent eventName
   */
  eventName?: string | null,

  /**
   * UserEvent eventData
   */
  eventData?: google$protobuf$Struct | google$protobuf$IStruct | null,

  /**
   * UserEvent version
   */
  version?: number | null,
|};

/**
 * Represents a UserEvent.
 */
declare class replit$goval$api$UserEvent {
  /**
   * Constructs a new UserEvent.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IUserEvent): this;

  /**
   * UserEvent eventName.
   */
  eventName: string;

  /**
   * UserEvent eventData.
   */
  eventData?: google$protobuf$Struct | null;

  /**
   * UserEvent version.
   */
  version: number;

  /**
   * Creates a new UserEvent instance using the specified properties.
   * @param [properties] Properties to set
   * @returns UserEvent instance
   */
  static create(
    properties?: replit$goval$api$IUserEvent
  ): replit$goval$api$UserEvent;

  /**
   * [object Object],[object Object],[object Object]
   * @param message UserEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$UserEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message UserEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$UserEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a UserEvent message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns UserEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$UserEvent;

  /**
   * Decodes a UserEvent message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns UserEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$UserEvent;

  /**
   * Verifies a UserEvent message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a UserEvent message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns UserEvent
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$UserEvent;

  /**
   * Creates a plain object from a UserEvent message. Also converts values to other types if specified.
   * @param message UserEvent
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$UserEvent,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this UserEvent to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReplToken.
 */
declare type replit$goval$api$IReplToken = {|
  /**
   * ReplToken iat
   */
  iat?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,

  /**
   * ReplToken exp
   */
  exp?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,

  /**
   * ReplToken salt
   */
  salt?: string | null,

  /**
   * ReplToken cluster
   */
  cluster?: string | null,

  /**
   * ReplToken persistence
   */
  persistence?: $Values<typeof replit$goval$api$repl$Persistence> | null,

  /**
   * ReplToken repl
   */
  repl?: replit$goval$api$repl$Repl | replit$goval$api$repl$IRepl | null,

  /**
   * ReplToken id
   */
  id?:
    | replit$goval$api$ReplToken$ReplID
    | replit$goval$api$ReplToken$IReplID
    | null,

  /**
   * ReplToken classroom
   */
  classroom?:
    | replit$goval$api$ReplToken$ClassroomMetadata
    | replit$goval$api$ReplToken$IClassroomMetadata
    | null,

  /**
   * ReplToken resourceLimits
   */
  resourceLimits?:
    | replit$goval$api$repl$ResourceLimits
    | replit$goval$api$repl$IResourceLimits
    | null,

  /**
   * ReplToken interactiveResourceLimits
   */
  interactiveResourceLimits?:
    | replit$goval$api$repl$ResourceLimits
    | replit$goval$api$repl$IResourceLimits
    | null,

  /**
   * ReplToken format
   */
  format?: $Values<typeof replit$goval$api$ReplToken$WireFormat> | null,

  /**
   * ReplToken presenced
   */
  presenced?:
    | replit$goval$api$ReplToken$Presenced
    | replit$goval$api$ReplToken$IPresenced
    | null,

  /**
   * ReplToken flags
   */
  flags?: string[] | null,

  /**
   * ReplToken permissions
   */
  permissions?:
    | replit$goval$api$repl$Permissions
    | replit$goval$api$repl$IPermissions
    | null,

  /**
   * ReplToken features
   */
  features?:
    | (replit$goval$api$features$Feature | replit$goval$api$features$IFeature)[]
    | null,
|};

/**
 * Represents a ReplToken.
 */
declare class replit$goval$api$ReplToken {
  /**
   * Constructs a new ReplToken.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IReplToken): this;

  /**
   * ReplToken iat.
   */
  iat?: google$protobuf$Timestamp | null;

  /**
   * ReplToken exp.
   */
  exp?: google$protobuf$Timestamp | null;

  /**
   * ReplToken salt.
   */
  salt: string;

  /**
   * ReplToken cluster.
   */
  cluster: string;

  /**
   * ReplToken persistence.
   */
  persistence: $Values<typeof replit$goval$api$repl$Persistence>;

  /**
   * ReplToken repl.
   */
  repl?: replit$goval$api$repl$Repl | null;

  /**
   * ReplToken id.
   */
  id?: replit$goval$api$ReplToken$ReplID | null;

  /**
   * ReplToken classroom.
   */
  classroom?: replit$goval$api$ReplToken$ClassroomMetadata | null;

  /**
   * ReplToken resourceLimits.
   */
  resourceLimits?: replit$goval$api$repl$ResourceLimits | null;

  /**
   * ReplToken interactiveResourceLimits.
   */
  interactiveResourceLimits?: replit$goval$api$repl$ResourceLimits | null;

  /**
   * ReplToken format.
   */
  format: $Values<typeof replit$goval$api$ReplToken$WireFormat>;

  /**
   * ReplToken presenced.
   */
  presenced?: replit$goval$api$ReplToken$Presenced | null;

  /**
   * ReplToken flags.
   */
  flags: string[];

  /**
   * ReplToken permissions.
   */
  permissions?: replit$goval$api$repl$Permissions | null;

  /**
   * ReplToken features.
   */
  features: replit$goval$api$features$Feature[];

  /**
   * ReplToken metadata.
   */
  metadata?: "repl" | "id" | "classroom";

  /**
   * Creates a new ReplToken instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReplToken instance
   */
  static create(
    properties?: replit$goval$api$IReplToken
  ): replit$goval$api$ReplToken;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplToken message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ReplToken,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplToken message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ReplToken,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReplToken message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReplToken
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ReplToken;

  /**
   * Decodes a ReplToken message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReplToken
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ReplToken;

  /**
   * Verifies a ReplToken message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReplToken message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReplToken
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ReplToken;

  /**
   * Creates a plain object from a ReplToken message. Also converts values to other types if specified.
   * @param message ReplToken
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ReplToken,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReplToken to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static WireFormat: typeof replit$goval$api$ReplToken$WireFormat;
  static IClassroomMetadata: Class<replit$goval$api$ReplToken$IClassroomMetadata>;
  static IReplID: Class<replit$goval$api$ReplToken$IReplID>;
  static IPresenced: Class<replit$goval$api$ReplToken$IPresenced>;
  static ClassroomMetadata: typeof replit$goval$api$ReplToken$ClassroomMetadata;
  static ReplID: typeof replit$goval$api$ReplToken$ReplID;
  static Presenced: typeof replit$goval$api$ReplToken$Presenced;
}

/**
 * Properties of a ClassroomMetadata.
 */
declare type replit$goval$api$ReplToken$IClassroomMetadata = {|
  /**
   * ClassroomMetadata id
   */
  id?: string | null,

  /**
   * ClassroomMetadata language
   */
  language?: string | null,
|};

/**
 * Represents a ClassroomMetadata.
 */
declare class replit$goval$api$ReplToken$ClassroomMetadata {
  /**
   * Constructs a new ClassroomMetadata.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ReplToken$IClassroomMetadata): this;

  /**
   * ClassroomMetadata id.
   */
  id: string;

  /**
   * ClassroomMetadata language.
   */
  language: string;

  /**
   * Creates a new ClassroomMetadata instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ClassroomMetadata instance
   */
  static create(
    properties?: replit$goval$api$ReplToken$IClassroomMetadata
  ): replit$goval$api$ReplToken$ClassroomMetadata;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ClassroomMetadata message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ReplToken$ClassroomMetadata,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ClassroomMetadata message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ReplToken$ClassroomMetadata,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ClassroomMetadata message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ClassroomMetadata
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ReplToken$ClassroomMetadata;

  /**
   * Decodes a ClassroomMetadata message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ClassroomMetadata
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ReplToken$ClassroomMetadata;

  /**
   * Verifies a ClassroomMetadata message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ClassroomMetadata message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ClassroomMetadata
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ReplToken$ClassroomMetadata;

  /**
   * Creates a plain object from a ClassroomMetadata message. Also converts values to other types if specified.
   * @param message ClassroomMetadata
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ReplToken$ClassroomMetadata,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ClassroomMetadata to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReplID.
 */
declare type replit$goval$api$ReplToken$IReplID = {|
  /**
   * ReplID id
   */
  id?: string | null,

  /**
   * ReplID sourceRepl
   */
  sourceRepl?: string | null,
|};

/**
 * Represents a ReplID.
 */
declare class replit$goval$api$ReplToken$ReplID {
  /**
   * Constructs a new ReplID.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ReplToken$IReplID): this;

  /**
   * ReplID id.
   */
  id: string;

  /**
   * ReplID sourceRepl.
   */
  sourceRepl: string;

  /**
   * Creates a new ReplID instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReplID instance
   */
  static create(
    properties?: replit$goval$api$ReplToken$IReplID
  ): replit$goval$api$ReplToken$ReplID;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplID message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ReplToken$ReplID,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplID message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ReplToken$ReplID,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReplID message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReplID
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ReplToken$ReplID;

  /**
   * Decodes a ReplID message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReplID
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ReplToken$ReplID;

  /**
   * Verifies a ReplID message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReplID message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReplID
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ReplToken$ReplID;

  /**
   * Creates a plain object from a ReplID message. Also converts values to other types if specified.
   * @param message ReplID
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ReplToken$ReplID,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReplID to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * WireFormat enum.
 */

declare var replit$goval$api$ReplToken$WireFormat: {|
  +PROTOBUF: 0, // 0
  +JSON: 1, // 1
|};

/**
 * Properties of a Presenced.
 */
declare type replit$goval$api$ReplToken$IPresenced = {|
  /**
   * Presenced bearerID
   */
  bearerID?: number | null,

  /**
   * Presenced bearerName
   */
  bearerName?: string | null,
|};

/**
 * Represents a Presenced.
 */
declare class replit$goval$api$ReplToken$Presenced {
  /**
   * Constructs a new Presenced.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ReplToken$IPresenced): this;

  /**
   * Presenced bearerID.
   */
  bearerID: number;

  /**
   * Presenced bearerName.
   */
  bearerName: string;

  /**
   * Creates a new Presenced instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Presenced instance
   */
  static create(
    properties?: replit$goval$api$ReplToken$IPresenced
  ): replit$goval$api$ReplToken$Presenced;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Presenced message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ReplToken$Presenced,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Presenced message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ReplToken$Presenced,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Presenced message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Presenced
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ReplToken$Presenced;

  /**
   * Decodes a Presenced message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Presenced
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ReplToken$Presenced;

  /**
   * Verifies a Presenced message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Presenced message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Presenced
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ReplToken$Presenced;

  /**
   * Creates a plain object from a Presenced message. Also converts values to other types if specified.
   * @param message Presenced
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ReplToken$Presenced,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Presenced to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a TLSCertificate.
 */
declare type replit$goval$api$ITLSCertificate = {|
  /**
   * TLSCertificate domain
   */
  domain?: string | null,

  /**
   * TLSCertificate cert
   */
  cert?: Uint8Array | null,
|};

/**
 * Represents a TLSCertificate.
 */
declare class replit$goval$api$TLSCertificate {
  /**
   * Constructs a new TLSCertificate.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ITLSCertificate): this;

  /**
   * TLSCertificate domain.
   */
  domain: string;

  /**
   * TLSCertificate cert.
   */
  cert: Uint8Array;

  /**
   * Creates a new TLSCertificate instance using the specified properties.
   * @param [properties] Properties to set
   * @returns TLSCertificate instance
   */
  static create(
    properties?: replit$goval$api$ITLSCertificate
  ): replit$goval$api$TLSCertificate;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TLSCertificate message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$TLSCertificate,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TLSCertificate message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$TLSCertificate,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a TLSCertificate message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns TLSCertificate
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$TLSCertificate;

  /**
   * Decodes a TLSCertificate message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns TLSCertificate
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$TLSCertificate;

  /**
   * Verifies a TLSCertificate message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a TLSCertificate message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns TLSCertificate
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$TLSCertificate;

  /**
   * Creates a plain object from a TLSCertificate message. Also converts values to other types if specified.
   * @param message TLSCertificate
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$TLSCertificate,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this TLSCertificate to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReplTransfer.
 */
declare type replit$goval$api$IReplTransfer = {|
  /**
   * ReplTransfer repl
   */
  repl?: replit$goval$api$repl$Repl | replit$goval$api$repl$IRepl | null,

  /**
   * ReplTransfer replLimits
   */
  replLimits?:
    | replit$goval$api$repl$ResourceLimits
    | replit$goval$api$repl$IResourceLimits
    | null,

  /**
   * ReplTransfer userLimits
   */
  userLimits?:
    | replit$goval$api$repl$ResourceLimits
    | replit$goval$api$repl$IResourceLimits
    | null,

  /**
   * ReplTransfer customDomains
   */
  customDomains?: string[] | null,

  /**
   * ReplTransfer certificates
   */
  certificates?:
    | (replit$goval$api$TLSCertificate | replit$goval$api$ITLSCertificate)[]
    | null,

  /**
   * ReplTransfer flags
   */
  flags?: string[] | null,
|};

/**
 * Represents a ReplTransfer.
 */
declare class replit$goval$api$ReplTransfer {
  /**
   * Constructs a new ReplTransfer.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IReplTransfer): this;

  /**
   * ReplTransfer repl.
   */
  repl?: replit$goval$api$repl$Repl | null;

  /**
   * ReplTransfer replLimits.
   */
  replLimits?: replit$goval$api$repl$ResourceLimits | null;

  /**
   * ReplTransfer userLimits.
   */
  userLimits?: replit$goval$api$repl$ResourceLimits | null;

  /**
   * ReplTransfer customDomains.
   */
  customDomains: string[];

  /**
   * ReplTransfer certificates.
   */
  certificates: replit$goval$api$TLSCertificate[];

  /**
   * ReplTransfer flags.
   */
  flags: string[];

  /**
   * Creates a new ReplTransfer instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReplTransfer instance
   */
  static create(
    properties?: replit$goval$api$IReplTransfer
  ): replit$goval$api$ReplTransfer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplTransfer message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ReplTransfer,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplTransfer message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ReplTransfer,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReplTransfer message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReplTransfer
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ReplTransfer;

  /**
   * Decodes a ReplTransfer message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReplTransfer
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ReplTransfer;

  /**
   * Verifies a ReplTransfer message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReplTransfer message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReplTransfer
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ReplTransfer;

  /**
   * Creates a plain object from a ReplTransfer message. Also converts values to other types if specified.
   * @param message ReplTransfer
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ReplTransfer,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReplTransfer to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an AllowReplRequest.
 */
declare type replit$goval$api$IAllowReplRequest = {|
  /**
   * AllowReplRequest replTransfer
   */
  replTransfer?:
    | replit$goval$api$ReplTransfer
    | replit$goval$api$IReplTransfer
    | null,
|};

/**
 * Represents an AllowReplRequest.
 */
declare class replit$goval$api$AllowReplRequest {
  /**
   * Constructs a new AllowReplRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IAllowReplRequest): this;

  /**
   * AllowReplRequest replTransfer.
   */
  replTransfer?: replit$goval$api$ReplTransfer | null;

  /**
   * Creates a new AllowReplRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns AllowReplRequest instance
   */
  static create(
    properties?: replit$goval$api$IAllowReplRequest
  ): replit$goval$api$AllowReplRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AllowReplRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$AllowReplRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AllowReplRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$AllowReplRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an AllowReplRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns AllowReplRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$AllowReplRequest;

  /**
   * Decodes an AllowReplRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns AllowReplRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$AllowReplRequest;

  /**
   * Verifies an AllowReplRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an AllowReplRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns AllowReplRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$AllowReplRequest;

  /**
   * Creates a plain object from an AllowReplRequest message. Also converts values to other types if specified.
   * @param message AllowReplRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$AllowReplRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this AllowReplRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ClusterMetadata.
 */
declare type replit$goval$api$IClusterMetadata = {|
  /**
   * ClusterMetadata id
   */
  id?: string | null,

  /**
   * ClusterMetadata conmanURL
   */
  conmanURL?: string | null,

  /**
   * ClusterMetadata gurl
   */
  gurl?: string | null,

  /**
   * ClusterMetadata proxy
   */
  proxy?: string | null,
|};

/**
 * Represents a ClusterMetadata.
 */
declare class replit$goval$api$ClusterMetadata {
  /**
   * Constructs a new ClusterMetadata.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IClusterMetadata): this;

  /**
   * ClusterMetadata id.
   */
  id: string;

  /**
   * ClusterMetadata conmanURL.
   */
  conmanURL: string;

  /**
   * ClusterMetadata gurl.
   */
  gurl: string;

  /**
   * ClusterMetadata proxy.
   */
  proxy: string;

  /**
   * Creates a new ClusterMetadata instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ClusterMetadata instance
   */
  static create(
    properties?: replit$goval$api$IClusterMetadata
  ): replit$goval$api$ClusterMetadata;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ClusterMetadata message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ClusterMetadata,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ClusterMetadata message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ClusterMetadata,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ClusterMetadata message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ClusterMetadata
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ClusterMetadata;

  /**
   * Decodes a ClusterMetadata message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ClusterMetadata
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ClusterMetadata;

  /**
   * Verifies a ClusterMetadata message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ClusterMetadata message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ClusterMetadata
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ClusterMetadata;

  /**
   * Creates a plain object from a ClusterMetadata message. Also converts values to other types if specified.
   * @param message ClusterMetadata
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ClusterMetadata,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ClusterMetadata to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an EvictReplRequest.
 */
declare type replit$goval$api$IEvictReplRequest = {|
  /**
   * EvictReplRequest clusterMetadata
   */
  clusterMetadata?:
    | replit$goval$api$ClusterMetadata
    | replit$goval$api$IClusterMetadata
    | null,

  /**
   * EvictReplRequest token
   */
  token?: string | null,

  /**
   * EvictReplRequest user
   */
  user?: string | null,

  /**
   * EvictReplRequest slug
   */
  slug?: string | null,
|};

/**
 * Represents an EvictReplRequest.
 */
declare class replit$goval$api$EvictReplRequest {
  /**
   * Constructs a new EvictReplRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IEvictReplRequest): this;

  /**
   * EvictReplRequest clusterMetadata.
   */
  clusterMetadata?: replit$goval$api$ClusterMetadata | null;

  /**
   * EvictReplRequest token.
   */
  token: string;

  /**
   * EvictReplRequest user.
   */
  user: string;

  /**
   * EvictReplRequest slug.
   */
  slug: string;

  /**
   * Creates a new EvictReplRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns EvictReplRequest instance
   */
  static create(
    properties?: replit$goval$api$IEvictReplRequest
  ): replit$goval$api$EvictReplRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message EvictReplRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$EvictReplRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message EvictReplRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$EvictReplRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an EvictReplRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns EvictReplRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$EvictReplRequest;

  /**
   * Decodes an EvictReplRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns EvictReplRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$EvictReplRequest;

  /**
   * Verifies an EvictReplRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an EvictReplRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns EvictReplRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$EvictReplRequest;

  /**
   * Creates a plain object from an EvictReplRequest message. Also converts values to other types if specified.
   * @param message EvictReplRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$EvictReplRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this EvictReplRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an EvictReplResponse.
 */
declare type replit$goval$api$IEvictReplResponse = {|
  /**
   * EvictReplResponse replTransfer
   */
  replTransfer?:
    | replit$goval$api$ReplTransfer
    | replit$goval$api$IReplTransfer
    | null,
|};

/**
 * Represents an EvictReplResponse.
 */
declare class replit$goval$api$EvictReplResponse {
  /**
   * Constructs a new EvictReplResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IEvictReplResponse): this;

  /**
   * EvictReplResponse replTransfer.
   */
  replTransfer?: replit$goval$api$ReplTransfer | null;

  /**
   * Creates a new EvictReplResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns EvictReplResponse instance
   */
  static create(
    properties?: replit$goval$api$IEvictReplResponse
  ): replit$goval$api$EvictReplResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message EvictReplResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$EvictReplResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message EvictReplResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$EvictReplResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an EvictReplResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns EvictReplResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$EvictReplResponse;

  /**
   * Decodes an EvictReplResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns EvictReplResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$EvictReplResponse;

  /**
   * Verifies an EvictReplResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an EvictReplResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns EvictReplResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$EvictReplResponse;

  /**
   * Creates a plain object from an EvictReplResponse message. Also converts values to other types if specified.
   * @param message EvictReplResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$EvictReplResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this EvictReplResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * TokenVersion enum.
 */

declare var replit$goval$api$TokenVersion: {|
  +BARE_REPL_TOKEN: 0, // 0
  +TYPE_AWARE_TOKEN: 1, // 1
|};

/**
 * Properties of a GovalSigningAuthority.
 */
declare type replit$goval$api$IGovalSigningAuthority = {|
  /**
   * GovalSigningAuthority keyId
   */
  keyId?: string | null,

  /**
   * GovalSigningAuthority signedCert
   */
  signedCert?: string | null,

  /**
   * GovalSigningAuthority version
   */
  version?: $Values<typeof replit$goval$api$TokenVersion> | null,

  /**
   * GovalSigningAuthority issuer
   */
  issuer?: string | null,
|};

/**
 * Represents a GovalSigningAuthority.
 */
declare class replit$goval$api$GovalSigningAuthority {
  /**
   * Constructs a new GovalSigningAuthority.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IGovalSigningAuthority): this;

  /**
   * GovalSigningAuthority keyId.
   */
  keyId?: string | null;

  /**
   * GovalSigningAuthority signedCert.
   */
  signedCert?: string | null;

  /**
   * GovalSigningAuthority version.
   */
  version: $Values<typeof replit$goval$api$TokenVersion>;

  /**
   * GovalSigningAuthority issuer.
   */
  issuer: string;

  /**
   * GovalSigningAuthority cert.
   */
  cert?: "keyId" | "signedCert";

  /**
   * Creates a new GovalSigningAuthority instance using the specified properties.
   * @param [properties] Properties to set
   * @returns GovalSigningAuthority instance
   */
  static create(
    properties?: replit$goval$api$IGovalSigningAuthority
  ): replit$goval$api$GovalSigningAuthority;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalSigningAuthority message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$GovalSigningAuthority,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalSigningAuthority message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$GovalSigningAuthority,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a GovalSigningAuthority message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns GovalSigningAuthority
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$GovalSigningAuthority;

  /**
   * Decodes a GovalSigningAuthority message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns GovalSigningAuthority
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$GovalSigningAuthority;

  /**
   * Verifies a GovalSigningAuthority message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a GovalSigningAuthority message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns GovalSigningAuthority
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$GovalSigningAuthority;

  /**
   * Creates a plain object from a GovalSigningAuthority message. Also converts values to other types if specified.
   * @param message GovalSigningAuthority
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$GovalSigningAuthority,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this GovalSigningAuthority to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * FlagClaim enum.
 */

declare var replit$goval$api$FlagClaim: {|
  +MINT_GOVAL_TOKEN: 0, // 0
  +SIGN_INTERMEDIATE_CERT: 1, // 1
  +IDENTITY: 5, // 5
  +GHOSTWRITER: 6, // 6
  +ANY_REPLID: 2, // 2
  +ANY_USER: 3, // 3
  +ANY_CLUSTER: 4, // 4
|};

/**
 * Properties of a CertificateClaim.
 */
declare type replit$goval$api$ICertificateClaim = {|
  /**
   * CertificateClaim replid
   */
  replid?: string | null,

  /**
   * CertificateClaim user
   */
  user?: string | null,

  /**
   * CertificateClaim cluster
   */
  cluster?: string | null,

  /**
   * CertificateClaim flag
   */
  flag?: $Values<typeof replit$goval$api$FlagClaim> | null,
|};

/**
 * Represents a CertificateClaim.
 */
declare class replit$goval$api$CertificateClaim {
  /**
   * Constructs a new CertificateClaim.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ICertificateClaim): this;

  /**
   * CertificateClaim replid.
   */
  replid?: string | null;

  /**
   * CertificateClaim user.
   */
  user?: string | null;

  /**
   * CertificateClaim cluster.
   */
  cluster?: string | null;

  /**
   * CertificateClaim flag.
   */
  flag?: $Values<typeof replit$goval$api$FlagClaim> | null;

  /**
   * CertificateClaim claim.
   */
  claim?: "replid" | "user" | "cluster" | "flag";

  /**
   * Creates a new CertificateClaim instance using the specified properties.
   * @param [properties] Properties to set
   * @returns CertificateClaim instance
   */
  static create(
    properties?: replit$goval$api$ICertificateClaim
  ): replit$goval$api$CertificateClaim;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CertificateClaim message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$CertificateClaim,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CertificateClaim message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$CertificateClaim,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a CertificateClaim message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns CertificateClaim
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$CertificateClaim;

  /**
   * Decodes a CertificateClaim message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns CertificateClaim
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$CertificateClaim;

  /**
   * Verifies a CertificateClaim message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a CertificateClaim message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns CertificateClaim
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$CertificateClaim;

  /**
   * Creates a plain object from a CertificateClaim message. Also converts values to other types if specified.
   * @param message CertificateClaim
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$CertificateClaim,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this CertificateClaim to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a GovalCert.
 */
declare type replit$goval$api$IGovalCert = {|
  /**
   * GovalCert iat
   */
  iat?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,

  /**
   * GovalCert exp
   */
  exp?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,

  /**
   * GovalCert claims
   */
  claims?:
    | (replit$goval$api$CertificateClaim | replit$goval$api$ICertificateClaim)[]
    | null,

  /**
   * GovalCert publicKey
   */
  publicKey?: string | null,
|};

/**
 * Represents a GovalCert.
 */
declare class replit$goval$api$GovalCert {
  /**
   * Constructs a new GovalCert.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IGovalCert): this;

  /**
   * GovalCert iat.
   */
  iat?: google$protobuf$Timestamp | null;

  /**
   * GovalCert exp.
   */
  exp?: google$protobuf$Timestamp | null;

  /**
   * GovalCert claims.
   */
  claims: replit$goval$api$CertificateClaim[];

  /**
   * GovalCert publicKey.
   */
  publicKey: string;

  /**
   * Creates a new GovalCert instance using the specified properties.
   * @param [properties] Properties to set
   * @returns GovalCert instance
   */
  static create(
    properties?: replit$goval$api$IGovalCert
  ): replit$goval$api$GovalCert;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalCert message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$GovalCert,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalCert message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$GovalCert,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a GovalCert message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns GovalCert
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$GovalCert;

  /**
   * Decodes a GovalCert message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns GovalCert
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$GovalCert;

  /**
   * Verifies a GovalCert message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a GovalCert message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns GovalCert
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$GovalCert;

  /**
   * Creates a plain object from a GovalCert message. Also converts values to other types if specified.
   * @param message GovalCert
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$GovalCert,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this GovalCert to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a GovalToken.
 */
declare type replit$goval$api$IGovalToken = {|
  /**
   * GovalToken iat
   */
  iat?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,

  /**
   * GovalToken exp
   */
  exp?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,

  /**
   * GovalToken replid
   */
  replid?: string | null,

  /**
   * GovalToken replToken
   */
  replToken?: replit$goval$api$ReplToken | replit$goval$api$IReplToken | null,

  /**
   * GovalToken replIdentity
   */
  replIdentity?:
    | replit$goval$api$GovalReplIdentity
    | replit$goval$api$IGovalReplIdentity
    | null,
|};

/**
 * Represents a GovalToken.
 */
declare class replit$goval$api$GovalToken {
  /**
   * Constructs a new GovalToken.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IGovalToken): this;

  /**
   * GovalToken iat.
   */
  iat?: google$protobuf$Timestamp | null;

  /**
   * GovalToken exp.
   */
  exp?: google$protobuf$Timestamp | null;

  /**
   * GovalToken replid.
   */
  replid: string;

  /**
   * GovalToken replToken.
   */
  replToken?: replit$goval$api$ReplToken | null;

  /**
   * GovalToken replIdentity.
   */
  replIdentity?: replit$goval$api$GovalReplIdentity | null;

  /**
   * GovalToken Token.
   */
  Token?: "replToken" | "replIdentity";

  /**
   * Creates a new GovalToken instance using the specified properties.
   * @param [properties] Properties to set
   * @returns GovalToken instance
   */
  static create(
    properties?: replit$goval$api$IGovalToken
  ): replit$goval$api$GovalToken;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalToken message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$GovalToken,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalToken message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$GovalToken,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a GovalToken message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns GovalToken
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$GovalToken;

  /**
   * Decodes a GovalToken message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns GovalToken
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$GovalToken;

  /**
   * Verifies a GovalToken message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a GovalToken message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns GovalToken
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$GovalToken;

  /**
   * Creates a plain object from a GovalToken message. Also converts values to other types if specified.
   * @param message GovalToken
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$GovalToken,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this GovalToken to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a GovalReplIdentity.
 */
declare type replit$goval$api$IGovalReplIdentity = {|
  /**
   * GovalReplIdentity replid
   */
  replid?: string | null,

  /**
   * GovalReplIdentity user
   */
  user?: string | null,

  /**
   * GovalReplIdentity slug
   */
  slug?: string | null,

  /**
   * GovalReplIdentity aud
   */
  aud?: string | null,

  /**
   * GovalReplIdentity ephemeral
   */
  ephemeral?: boolean | null,

  /**
   * GovalReplIdentity originReplid
   */
  originReplid?: string | null,
|};

/**
 * Represents a GovalReplIdentity.
 */
declare class replit$goval$api$GovalReplIdentity {
  /**
   * Constructs a new GovalReplIdentity.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IGovalReplIdentity): this;

  /**
   * GovalReplIdentity replid.
   */
  replid: string;

  /**
   * GovalReplIdentity user.
   */
  user: string;

  /**
   * GovalReplIdentity slug.
   */
  slug: string;

  /**
   * GovalReplIdentity aud.
   */
  aud: string;

  /**
   * GovalReplIdentity ephemeral.
   */
  ephemeral: boolean;

  /**
   * GovalReplIdentity originReplid.
   */
  originReplid: string;

  /**
   * Creates a new GovalReplIdentity instance using the specified properties.
   * @param [properties] Properties to set
   * @returns GovalReplIdentity instance
   */
  static create(
    properties?: replit$goval$api$IGovalReplIdentity
  ): replit$goval$api$GovalReplIdentity;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalReplIdentity message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$GovalReplIdentity,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalReplIdentity message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$GovalReplIdentity,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a GovalReplIdentity message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns GovalReplIdentity
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$GovalReplIdentity;

  /**
   * Decodes a GovalReplIdentity message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns GovalReplIdentity
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$GovalReplIdentity;

  /**
   * Verifies a GovalReplIdentity message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a GovalReplIdentity message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns GovalReplIdentity
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$GovalReplIdentity;

  /**
   * Creates a plain object from a GovalReplIdentity message. Also converts values to other types if specified.
   * @param message GovalReplIdentity
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$GovalReplIdentity,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this GovalReplIdentity to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a LoreCommand.
 */
declare type replit$goval$api$ILoreCommand = {|
  /**
   * LoreCommand clusterTransfer
   */
  clusterTransfer?:
    | replit$goval$api$ClusterTransfer
    | replit$goval$api$IClusterTransfer
    | null,

  /**
   * LoreCommand softTakedown
   */
  softTakedown?:
    | replit$goval$api$SoftTakedown
    | replit$goval$api$ISoftTakedown
    | null,

  /**
   * LoreCommand govalCommand
   */
  govalCommand?:
    | replit$goval$api$GovalCommand
    | replit$goval$api$IGovalCommand
    | null,

  /**
   * LoreCommand multiGovalCommand
   */
  multiGovalCommand?:
    | replit$goval$api$MultiGovalCommand
    | replit$goval$api$IMultiGovalCommand
    | null,

  /**
   * LoreCommand restore
   */
  restore?: replit$goval$api$Restore | replit$goval$api$IRestore | null,
|};

/**
 * Represents a LoreCommand.
 */
declare class replit$goval$api$LoreCommand {
  /**
   * Constructs a new LoreCommand.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ILoreCommand): this;

  /**
   * LoreCommand clusterTransfer.
   */
  clusterTransfer?: replit$goval$api$ClusterTransfer | null;

  /**
   * LoreCommand softTakedown.
   */
  softTakedown?: replit$goval$api$SoftTakedown | null;

  /**
   * LoreCommand govalCommand.
   */
  govalCommand?: replit$goval$api$GovalCommand | null;

  /**
   * LoreCommand multiGovalCommand.
   */
  multiGovalCommand?: replit$goval$api$MultiGovalCommand | null;

  /**
   * LoreCommand restore.
   */
  restore?: replit$goval$api$Restore | null;

  /**
   * LoreCommand command.
   */
  command?:
    | "clusterTransfer"
    | "softTakedown"
    | "govalCommand"
    | "multiGovalCommand"
    | "restore";

  /**
   * Creates a new LoreCommand instance using the specified properties.
   * @param [properties] Properties to set
   * @returns LoreCommand instance
   */
  static create(
    properties?: replit$goval$api$ILoreCommand
  ): replit$goval$api$LoreCommand;

  /**
   * [object Object],[object Object],[object Object]
   * @param message LoreCommand message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$LoreCommand,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message LoreCommand message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$LoreCommand,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a LoreCommand message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns LoreCommand
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$LoreCommand;

  /**
   * Decodes a LoreCommand message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns LoreCommand
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$LoreCommand;

  /**
   * Verifies a LoreCommand message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a LoreCommand message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns LoreCommand
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$LoreCommand;

  /**
   * Creates a plain object from a LoreCommand message. Also converts values to other types if specified.
   * @param message LoreCommand
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$LoreCommand,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this LoreCommand to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ClusterTransfer.
 */
declare type replit$goval$api$IClusterTransfer = {|
  /**
   * ClusterTransfer replId
   */
  replId?: string | null,

  /**
   * ClusterTransfer user
   */
  user?: string | null,

  /**
   * ClusterTransfer newClusterId
   */
  newClusterId?: string | null,

  /**
   * ClusterTransfer newContinentId
   */
  newContinentId?: string | null,

  /**
   * ClusterTransfer transferId
   */
  transferId?: string | null,
|};

/**
 * Represents a ClusterTransfer.
 */
declare class replit$goval$api$ClusterTransfer {
  /**
   * Constructs a new ClusterTransfer.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IClusterTransfer): this;

  /**
   * ClusterTransfer replId.
   */
  replId: string;

  /**
   * ClusterTransfer user.
   */
  user: string;

  /**
   * ClusterTransfer newClusterId.
   */
  newClusterId?: string | null;

  /**
   * ClusterTransfer newContinentId.
   */
  newContinentId?: string | null;

  /**
   * ClusterTransfer transferId.
   */
  transferId: string;

  /**
   * ClusterTransfer location.
   */
  location?: "newClusterId" | "newContinentId";

  /**
   * Creates a new ClusterTransfer instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ClusterTransfer instance
   */
  static create(
    properties?: replit$goval$api$IClusterTransfer
  ): replit$goval$api$ClusterTransfer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ClusterTransfer message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$ClusterTransfer,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ClusterTransfer message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$ClusterTransfer,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ClusterTransfer message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ClusterTransfer
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$ClusterTransfer;

  /**
   * Decodes a ClusterTransfer message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ClusterTransfer
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$ClusterTransfer;

  /**
   * Verifies a ClusterTransfer message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ClusterTransfer message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ClusterTransfer
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$ClusterTransfer;

  /**
   * Creates a plain object from a ClusterTransfer message. Also converts values to other types if specified.
   * @param message ClusterTransfer
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$ClusterTransfer,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ClusterTransfer to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a SoftTakedown.
 */
declare type replit$goval$api$ISoftTakedown = {|
  /**
   * SoftTakedown replId
   */
  replId?: string | null,

  /**
   * SoftTakedown softTakedownId
   */
  softTakedownId?: string | null,
|};

/**
 * Represents a SoftTakedown.
 */
declare class replit$goval$api$SoftTakedown {
  /**
   * Constructs a new SoftTakedown.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$ISoftTakedown): this;

  /**
   * SoftTakedown replId.
   */
  replId: string;

  /**
   * SoftTakedown softTakedownId.
   */
  softTakedownId: string;

  /**
   * Creates a new SoftTakedown instance using the specified properties.
   * @param [properties] Properties to set
   * @returns SoftTakedown instance
   */
  static create(
    properties?: replit$goval$api$ISoftTakedown
  ): replit$goval$api$SoftTakedown;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SoftTakedown message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$SoftTakedown,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SoftTakedown message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$SoftTakedown,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a SoftTakedown message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns SoftTakedown
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$SoftTakedown;

  /**
   * Decodes a SoftTakedown message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns SoftTakedown
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$SoftTakedown;

  /**
   * Verifies a SoftTakedown message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a SoftTakedown message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns SoftTakedown
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$SoftTakedown;

  /**
   * Creates a plain object from a SoftTakedown message. Also converts values to other types if specified.
   * @param message SoftTakedown
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$SoftTakedown,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this SoftTakedown to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a GovalCommand.
 */
declare type replit$goval$api$IGovalCommand = {|
  /**
   * GovalCommand updateMetadata
   */
  updateMetadata?:
    | replit$goval$api$repl$Metadata
    | replit$goval$api$repl$IMetadata
    | null,

  /**
   * GovalCommand partialUpdateMetadata
   */
  partialUpdateMetadata?:
    | replit$goval$api$PartialUpdateMetadata
    | replit$goval$api$IPartialUpdateMetadata
    | null,

  /**
   * GovalCommand killRepl
   */
  killRepl?: replit$goval$api$KillRepl | replit$goval$api$IKillRepl | null,

  /**
   * GovalCommand updateSourceRepl
   */
  updateSourceRepl?:
    | replit$goval$api$UpdateSourceRepl
    | replit$goval$api$IUpdateSourceRepl
    | null,

  /**
   * GovalCommand updateReplFlags
   */
  updateReplFlags?:
    | replit$goval$api$UpdateReplFlags
    | replit$goval$api$IUpdateReplFlags
    | null,
|};

/**
 * Represents a GovalCommand.
 */
declare class replit$goval$api$GovalCommand {
  /**
   * Constructs a new GovalCommand.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IGovalCommand): this;

  /**
   * GovalCommand updateMetadata.
   */
  updateMetadata?: replit$goval$api$repl$Metadata | null;

  /**
   * GovalCommand partialUpdateMetadata.
   */
  partialUpdateMetadata?: replit$goval$api$PartialUpdateMetadata | null;

  /**
   * GovalCommand killRepl.
   */
  killRepl?: replit$goval$api$KillRepl | null;

  /**
   * GovalCommand updateSourceRepl.
   */
  updateSourceRepl?: replit$goval$api$UpdateSourceRepl | null;

  /**
   * GovalCommand updateReplFlags.
   */
  updateReplFlags?: replit$goval$api$UpdateReplFlags | null;

  /**
   * GovalCommand command.
   */
  command?:
    | "updateMetadata"
    | "partialUpdateMetadata"
    | "killRepl"
    | "updateSourceRepl"
    | "updateReplFlags";

  /**
   * Creates a new GovalCommand instance using the specified properties.
   * @param [properties] Properties to set
   * @returns GovalCommand instance
   */
  static create(
    properties?: replit$goval$api$IGovalCommand
  ): replit$goval$api$GovalCommand;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalCommand message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$GovalCommand,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalCommand message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$GovalCommand,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a GovalCommand message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns GovalCommand
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$GovalCommand;

  /**
   * Decodes a GovalCommand message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns GovalCommand
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$GovalCommand;

  /**
   * Verifies a GovalCommand message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a GovalCommand message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns GovalCommand
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$GovalCommand;

  /**
   * Creates a plain object from a GovalCommand message. Also converts values to other types if specified.
   * @param message GovalCommand
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$GovalCommand,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this GovalCommand to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PartialUpdateMetadata.
 */
declare type replit$goval$api$IPartialUpdateMetadata = {|
  /**
   * PartialUpdateMetadata fieldMask
   */
  fieldMask?: google$protobuf$FieldMask | google$protobuf$IFieldMask | null,

  /**
   * PartialUpdateMetadata updateMetadata
   */
  updateMetadata?:
    | replit$goval$api$repl$Metadata
    | replit$goval$api$repl$IMetadata
    | null,
|};

/**
 * Represents a PartialUpdateMetadata.
 */
declare class replit$goval$api$PartialUpdateMetadata {
  /**
   * Constructs a new PartialUpdateMetadata.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IPartialUpdateMetadata): this;

  /**
   * PartialUpdateMetadata fieldMask.
   */
  fieldMask?: google$protobuf$FieldMask | null;

  /**
   * PartialUpdateMetadata updateMetadata.
   */
  updateMetadata?: replit$goval$api$repl$Metadata | null;

  /**
   * Creates a new PartialUpdateMetadata instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PartialUpdateMetadata instance
   */
  static create(
    properties?: replit$goval$api$IPartialUpdateMetadata
  ): replit$goval$api$PartialUpdateMetadata;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PartialUpdateMetadata message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$PartialUpdateMetadata,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PartialUpdateMetadata message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$PartialUpdateMetadata,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PartialUpdateMetadata message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PartialUpdateMetadata
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$PartialUpdateMetadata;

  /**
   * Decodes a PartialUpdateMetadata message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PartialUpdateMetadata
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$PartialUpdateMetadata;

  /**
   * Verifies a PartialUpdateMetadata message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PartialUpdateMetadata message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PartialUpdateMetadata
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$PartialUpdateMetadata;

  /**
   * Creates a plain object from a PartialUpdateMetadata message. Also converts values to other types if specified.
   * @param message PartialUpdateMetadata
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$PartialUpdateMetadata,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PartialUpdateMetadata to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a MultiGovalCommand.
 */
declare type replit$goval$api$IMultiGovalCommand = {|
  /**
   * MultiGovalCommand replId
   */
  replId?: string | null,

  /**
   * MultiGovalCommand govalCommands
   */
  govalCommands?:
    | (replit$goval$api$GovalCommand | replit$goval$api$IGovalCommand)[]
    | null,
|};

/**
 * Represents a MultiGovalCommand.
 */
declare class replit$goval$api$MultiGovalCommand {
  /**
   * Constructs a new MultiGovalCommand.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IMultiGovalCommand): this;

  /**
   * MultiGovalCommand replId.
   */
  replId: string;

  /**
   * MultiGovalCommand govalCommands.
   */
  govalCommands: replit$goval$api$GovalCommand[];

  /**
   * Creates a new MultiGovalCommand instance using the specified properties.
   * @param [properties] Properties to set
   * @returns MultiGovalCommand instance
   */
  static create(
    properties?: replit$goval$api$IMultiGovalCommand
  ): replit$goval$api$MultiGovalCommand;

  /**
   * [object Object],[object Object],[object Object]
   * @param message MultiGovalCommand message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$MultiGovalCommand,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message MultiGovalCommand message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$MultiGovalCommand,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a MultiGovalCommand message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns MultiGovalCommand
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$MultiGovalCommand;

  /**
   * Decodes a MultiGovalCommand message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns MultiGovalCommand
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$MultiGovalCommand;

  /**
   * Verifies a MultiGovalCommand message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a MultiGovalCommand message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns MultiGovalCommand
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$MultiGovalCommand;

  /**
   * Creates a plain object from a MultiGovalCommand message. Also converts values to other types if specified.
   * @param message MultiGovalCommand
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$MultiGovalCommand,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this MultiGovalCommand to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a KillRepl.
 */
declare type replit$goval$api$IKillRepl = {|
  /**
   * KillRepl replId
   */
  replId?: string | null,
|};

/**
 * Represents a KillRepl.
 */
declare class replit$goval$api$KillRepl {
  /**
   * Constructs a new KillRepl.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IKillRepl): this;

  /**
   * KillRepl replId.
   */
  replId: string;

  /**
   * Creates a new KillRepl instance using the specified properties.
   * @param [properties] Properties to set
   * @returns KillRepl instance
   */
  static create(
    properties?: replit$goval$api$IKillRepl
  ): replit$goval$api$KillRepl;

  /**
   * [object Object],[object Object],[object Object]
   * @param message KillRepl message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$KillRepl,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message KillRepl message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$KillRepl,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a KillRepl message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns KillRepl
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$KillRepl;

  /**
   * Decodes a KillRepl message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns KillRepl
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$KillRepl;

  /**
   * Verifies a KillRepl message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a KillRepl message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns KillRepl
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$KillRepl;

  /**
   * Creates a plain object from a KillRepl message. Also converts values to other types if specified.
   * @param message KillRepl
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$KillRepl,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this KillRepl to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Restore.
 */
declare type replit$goval$api$IRestore = {|
  /**
   * Restore replId
   */
  replId?: string | null,

  /**
   * Restore restoreReplId
   */
  restoreReplId?: string | null,
|};

/**
 * Represents a Restore.
 */
declare class replit$goval$api$Restore {
  /**
   * Constructs a new Restore.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IRestore): this;

  /**
   * Restore replId.
   */
  replId: string;

  /**
   * Restore restoreReplId.
   */
  restoreReplId: string;

  /**
   * Creates a new Restore instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Restore instance
   */
  static create(
    properties?: replit$goval$api$IRestore
  ): replit$goval$api$Restore;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Restore message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$Restore,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Restore message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$Restore,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Restore message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Restore
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$Restore;

  /**
   * Decodes a Restore message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Restore
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$Restore;

  /**
   * Verifies a Restore message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Restore message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Restore
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$Restore;

  /**
   * Creates a plain object from a Restore message. Also converts values to other types if specified.
   * @param message Restore
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$Restore,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Restore to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an UpdateSourceRepl.
 */
declare type replit$goval$api$IUpdateSourceRepl = {|
  /**
   * UpdateSourceRepl replId
   */
  replId?: string | null,

  /**
   * UpdateSourceRepl sourceReplId
   */
  sourceReplId?: string | null,
|};

/**
 * Represents an UpdateSourceRepl.
 */
declare class replit$goval$api$UpdateSourceRepl {
  /**
   * Constructs a new UpdateSourceRepl.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IUpdateSourceRepl): this;

  /**
   * UpdateSourceRepl replId.
   */
  replId: string;

  /**
   * UpdateSourceRepl sourceReplId.
   */
  sourceReplId: string;

  /**
   * Creates a new UpdateSourceRepl instance using the specified properties.
   * @param [properties] Properties to set
   * @returns UpdateSourceRepl instance
   */
  static create(
    properties?: replit$goval$api$IUpdateSourceRepl
  ): replit$goval$api$UpdateSourceRepl;

  /**
   * [object Object],[object Object],[object Object]
   * @param message UpdateSourceRepl message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$UpdateSourceRepl,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message UpdateSourceRepl message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$UpdateSourceRepl,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an UpdateSourceRepl message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns UpdateSourceRepl
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$UpdateSourceRepl;

  /**
   * Decodes an UpdateSourceRepl message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns UpdateSourceRepl
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$UpdateSourceRepl;

  /**
   * Verifies an UpdateSourceRepl message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an UpdateSourceRepl message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns UpdateSourceRepl
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$UpdateSourceRepl;

  /**
   * Creates a plain object from an UpdateSourceRepl message. Also converts values to other types if specified.
   * @param message UpdateSourceRepl
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$UpdateSourceRepl,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this UpdateSourceRepl to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an UpdateReplFlags.
 */
declare type replit$goval$api$IUpdateReplFlags = {|
  /**
   * UpdateReplFlags replId
   */
  replId?: string | null,

  /**
   * UpdateReplFlags flags
   */
  flags?: string[] | null,
|};

/**
 * Represents an UpdateReplFlags.
 */
declare class replit$goval$api$UpdateReplFlags {
  /**
   * Constructs a new UpdateReplFlags.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$IUpdateReplFlags): this;

  /**
   * UpdateReplFlags replId.
   */
  replId: string;

  /**
   * UpdateReplFlags flags.
   */
  flags: string[];

  /**
   * Creates a new UpdateReplFlags instance using the specified properties.
   * @param [properties] Properties to set
   * @returns UpdateReplFlags instance
   */
  static create(
    properties?: replit$goval$api$IUpdateReplFlags
  ): replit$goval$api$UpdateReplFlags;

  /**
   * [object Object],[object Object],[object Object]
   * @param message UpdateReplFlags message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$UpdateReplFlags,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message UpdateReplFlags message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$UpdateReplFlags,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an UpdateReplFlags message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns UpdateReplFlags
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$UpdateReplFlags;

  /**
   * Decodes an UpdateReplFlags message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns UpdateReplFlags
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$UpdateReplFlags;

  /**
   * Verifies an UpdateReplFlags message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an UpdateReplFlags message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns UpdateReplFlags
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$UpdateReplFlags;

  /**
   * Creates a plain object from an UpdateReplFlags message. Also converts values to other types if specified.
   * @param message UpdateReplFlags
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$UpdateReplFlags,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this UpdateReplFlags to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

declare var npm$namespace$replit$goval$api$features: {|
  IGpu: Class<replit$goval$api$features$IGpu>,
  IBoosted: Class<replit$goval$api$features$IBoosted>,
  IFeature: Class<replit$goval$api$features$IFeature>,
  Gpu: typeof replit$goval$api$features$Gpu,
  Boosted: typeof replit$goval$api$features$Boosted,
  Feature: typeof replit$goval$api$features$Feature,
|};

/**
 * Properties of a Gpu.
 */
declare type replit$goval$api$features$IGpu = {||};

/**
 * Represents a Gpu.
 */
declare class replit$goval$api$features$Gpu {
  /**
   * Constructs a new Gpu.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$features$IGpu): this;

  /**
   * Creates a new Gpu instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Gpu instance
   */
  static create(
    properties?: replit$goval$api$features$IGpu
  ): replit$goval$api$features$Gpu;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Gpu message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$features$Gpu,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Gpu message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$features$Gpu,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Gpu message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Gpu
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$features$Gpu;

  /**
   * Decodes a Gpu message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Gpu
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$features$Gpu;

  /**
   * Verifies a Gpu message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Gpu message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Gpu
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$features$Gpu;

  /**
   * Creates a plain object from a Gpu message. Also converts values to other types if specified.
   * @param message Gpu
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$features$Gpu,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Gpu to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Boosted.
 */
declare type replit$goval$api$features$IBoosted = {||};

/**
 * Represents a Boosted.
 */
declare class replit$goval$api$features$Boosted {
  /**
   * Constructs a new Boosted.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$features$IBoosted): this;

  /**
   * Creates a new Boosted instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Boosted instance
   */
  static create(
    properties?: replit$goval$api$features$IBoosted
  ): replit$goval$api$features$Boosted;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Boosted message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$features$Boosted,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Boosted message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$features$Boosted,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Boosted message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Boosted
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$features$Boosted;

  /**
   * Decodes a Boosted message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Boosted
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$features$Boosted;

  /**
   * Verifies a Boosted message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Boosted message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Boosted
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$features$Boosted;

  /**
   * Creates a plain object from a Boosted message. Also converts values to other types if specified.
   * @param message Boosted
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$features$Boosted,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Boosted to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Feature.
 */
declare type replit$goval$api$features$IFeature = {|
  /**
   * Feature gpu
   */
  gpu?: replit$goval$api$features$Gpu | replit$goval$api$features$IGpu | null,

  /**
   * Feature boosted
   */
  boosted?:
    | replit$goval$api$features$Boosted
    | replit$goval$api$features$IBoosted
    | null,

  /**
   * Feature required
   */
  required?: boolean | null,
|};

/**
 * Represents a Feature.
 */
declare class replit$goval$api$features$Feature {
  /**
   * Constructs a new Feature.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$features$IFeature): this;

  /**
   * Feature gpu.
   */
  gpu?: replit$goval$api$features$Gpu | null;

  /**
   * Feature boosted.
   */
  boosted?: replit$goval$api$features$Boosted | null;

  /**
   * Feature required.
   */
  required: boolean;

  /**
   * Feature feature.
   */
  feature?: "gpu" | "boosted";

  /**
   * Creates a new Feature instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Feature instance
   */
  static create(
    properties?: replit$goval$api$features$IFeature
  ): replit$goval$api$features$Feature;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Feature message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$features$Feature,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Feature message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$features$Feature,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Feature message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Feature
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$features$Feature;

  /**
   * Decodes a Feature message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Feature
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$features$Feature;

  /**
   * Verifies a Feature message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Feature message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Feature
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$features$Feature;

  /**
   * Creates a plain object from a Feature message. Also converts values to other types if specified.
   * @param message Feature
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$features$Feature,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Feature to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

declare var npm$namespace$replit$goval$api$repl: {|
  Persistence: typeof replit$goval$api$repl$Persistence,
  IBuckets: Class<replit$goval$api$repl$IBuckets>,
  IRepl: Class<replit$goval$api$repl$IRepl>,
  IResourceLimits: Class<replit$goval$api$repl$IResourceLimits>,
  IPermissions: Class<replit$goval$api$repl$IPermissions>,
  IMetadata: Class<replit$goval$api$repl$IMetadata>,
  Buckets: typeof replit$goval$api$repl$Buckets,
  Repl: typeof replit$goval$api$repl$Repl,
  ResourceLimits: typeof replit$goval$api$repl$ResourceLimits,
  Permissions: typeof replit$goval$api$repl$Permissions,
  Metadata: typeof replit$goval$api$repl$Metadata,
|};

/**
 * Properties of a Buckets.
 */
declare type replit$goval$api$repl$IBuckets = {|
  /**
   * Buckets snapshots
   */
  snapshots?: string | null,

  /**
   * Buckets metadata
   */
  metadata?: string | null,
|};

/**
 * Represents a Buckets.
 */
declare class replit$goval$api$repl$Buckets {
  /**
   * Constructs a new Buckets.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$repl$IBuckets): this;

  /**
   * Buckets snapshots.
   */
  snapshots: string;

  /**
   * Buckets metadata.
   */
  metadata: string;

  /**
   * Creates a new Buckets instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Buckets instance
   */
  static create(
    properties?: replit$goval$api$repl$IBuckets
  ): replit$goval$api$repl$Buckets;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Buckets message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$repl$Buckets,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Buckets message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$repl$Buckets,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Buckets message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Buckets
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$repl$Buckets;

  /**
   * Decodes a Buckets message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Buckets
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$repl$Buckets;

  /**
   * Verifies a Buckets message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Buckets message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Buckets
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$repl$Buckets;

  /**
   * Creates a plain object from a Buckets message. Also converts values to other types if specified.
   * @param message Buckets
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$repl$Buckets,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Buckets to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Repl.
 */
declare type replit$goval$api$repl$IRepl = {|
  /**
   * Repl id
   */
  id?: string | null,

  /**
   * Repl language
   */
  language?: string | null,

  /**
   * Repl bucket
   */
  bucket?: string | null,

  /**
   * Repl slug
   */
  slug?: string | null,

  /**
   * Repl user
   */
  user?: string | null,

  /**
   * Repl sourceRepl
   */
  sourceRepl?: string | null,

  /**
   * Repl database
   */
  database?: string | null,

  /**
   * Repl buckets
   */
  buckets?:
    | replit$goval$api$repl$Buckets
    | replit$goval$api$repl$IBuckets
    | null,
|};

/**
 * Represents a Repl.
 */
declare class replit$goval$api$repl$Repl {
  /**
   * Constructs a new Repl.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$repl$IRepl): this;

  /**
   * Repl id.
   */
  id: string;

  /**
   * Repl language.
   */
  language: string;

  /**
   * Repl bucket.
   */
  bucket: string;

  /**
   * Repl slug.
   */
  slug: string;

  /**
   * Repl user.
   */
  user: string;

  /**
   * Repl sourceRepl.
   */
  sourceRepl: string;

  /**
   * Repl database.
   */
  database: string;

  /**
   * Repl buckets.
   */
  buckets?: replit$goval$api$repl$Buckets | null;

  /**
   * Creates a new Repl instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Repl instance
   */
  static create(
    properties?: replit$goval$api$repl$IRepl
  ): replit$goval$api$repl$Repl;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Repl message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$repl$Repl,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Repl message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$repl$Repl,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Repl message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Repl
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$repl$Repl;

  /**
   * Decodes a Repl message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Repl
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$repl$Repl;

  /**
   * Verifies a Repl message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Repl message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Repl
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$repl$Repl;

  /**
   * Creates a plain object from a Repl message. Also converts values to other types if specified.
   * @param message Repl
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$repl$Repl,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Repl to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ResourceLimits.
 */
declare type replit$goval$api$repl$IResourceLimits = {|
  /**
   * ResourceLimits net
   */
  net?: boolean | null,

  /**
   * ResourceLimits memory
   */
  memory?: number | null,

  /**
   * ResourceLimits threads
   */
  threads?: number | null,

  /**
   * ResourceLimits shares
   */
  shares?: number | null,

  /**
   * ResourceLimits disk
   */
  disk?: number | null,

  /**
   * ResourceLimits cache
   */
  cache?: $Values<
    typeof replit$goval$api$repl$ResourceLimits$Cachability
  > | null,

  /**
   * ResourceLimits restrictNetwork
   */
  restrictNetwork?: boolean | null,

  /**
   * ResourceLimits preventWakeup
   */
  preventWakeup?: boolean | null,
|};

/**
 * Represents a ResourceLimits.
 */
declare class replit$goval$api$repl$ResourceLimits {
  /**
   * Constructs a new ResourceLimits.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$repl$IResourceLimits): this;

  /**
   * ResourceLimits net.
   */
  net: boolean;

  /**
   * ResourceLimits memory.
   */
  memory: number;

  /**
   * ResourceLimits threads.
   */
  threads: number;

  /**
   * ResourceLimits shares.
   */
  shares: number;

  /**
   * ResourceLimits disk.
   */
  disk: number;

  /**
   * ResourceLimits cache.
   */
  cache: $Values<typeof replit$goval$api$repl$ResourceLimits$Cachability>;

  /**
   * ResourceLimits restrictNetwork.
   */
  restrictNetwork: boolean;

  /**
   * ResourceLimits preventWakeup.
   */
  preventWakeup: boolean;

  /**
   * Creates a new ResourceLimits instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ResourceLimits instance
   */
  static create(
    properties?: replit$goval$api$repl$IResourceLimits
  ): replit$goval$api$repl$ResourceLimits;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ResourceLimits message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$repl$ResourceLimits,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ResourceLimits message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$repl$ResourceLimits,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ResourceLimits message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ResourceLimits
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$repl$ResourceLimits;

  /**
   * Decodes a ResourceLimits message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ResourceLimits
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$repl$ResourceLimits;

  /**
   * Verifies a ResourceLimits message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ResourceLimits message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ResourceLimits
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$repl$ResourceLimits;

  /**
   * Creates a plain object from a ResourceLimits message. Also converts values to other types if specified.
   * @param message ResourceLimits
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$repl$ResourceLimits,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ResourceLimits to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Cachability: typeof replit$goval$api$repl$ResourceLimits$Cachability;
}

/**
 * Cachability enum.
 */

declare var replit$goval$api$repl$ResourceLimits$Cachability: {|
  +NONE: 0, // 0
  +USER: 1, // 1
  +REPL: 2, // 2
|};

/**
 * Properties of a Permissions.
 */
declare type replit$goval$api$repl$IPermissions = {|
  /**
   * Permissions toggleAlwaysOn
   */
  toggleAlwaysOn?: boolean | null,
|};

/**
 * Represents a Permissions.
 */
declare class replit$goval$api$repl$Permissions {
  /**
   * Constructs a new Permissions.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$repl$IPermissions): this;

  /**
   * Permissions toggleAlwaysOn.
   */
  toggleAlwaysOn: boolean;

  /**
   * Creates a new Permissions instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Permissions instance
   */
  static create(
    properties?: replit$goval$api$repl$IPermissions
  ): replit$goval$api$repl$Permissions;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Permissions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$repl$Permissions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Permissions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$repl$Permissions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Permissions message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Permissions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$repl$Permissions;

  /**
   * Decodes a Permissions message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Permissions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$repl$Permissions;

  /**
   * Verifies a Permissions message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Permissions message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Permissions
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$repl$Permissions;

  /**
   * Creates a plain object from a Permissions message. Also converts values to other types if specified.
   * @param message Permissions
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$repl$Permissions,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Permissions to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Persistence enum.
 */

declare var replit$goval$api$repl$Persistence: {|
  +PERSISTENT: 0, // 0
  +EPHEMERAL: 1, // 1
  +NONE: 2, // 2
  +READ_ONLY: 3, // 3
|};

/**
 * Properties of a Metadata.
 */
declare type replit$goval$api$repl$IMetadata = {|
  /**
   * Metadata repl
   */
  repl?: replit$goval$api$repl$Repl | replit$goval$api$repl$IRepl | null,

  /**
   * Metadata resourceLimits
   */
  resourceLimits?:
    | replit$goval$api$repl$ResourceLimits
    | replit$goval$api$repl$IResourceLimits
    | null,

  /**
   * Metadata interactiveResourceLimits
   */
  interactiveResourceLimits?:
    | replit$goval$api$repl$ResourceLimits
    | replit$goval$api$repl$IResourceLimits
    | null,

  /**
   * Metadata persistence
   */
  persistence?: $Values<typeof replit$goval$api$repl$Persistence> | null,

  /**
   * Metadata flags
   */
  flags?: string[] | null,

  /**
   * Metadata permissions
   */
  permissions?:
    | replit$goval$api$repl$Permissions
    | replit$goval$api$repl$IPermissions
    | null,

  /**
   * Metadata features
   */
  features?:
    | (replit$goval$api$features$Feature | replit$goval$api$features$IFeature)[]
    | null,
|};

/**
 * Represents a Metadata.
 */
declare class replit$goval$api$repl$Metadata {
  /**
   * Constructs a new Metadata.
   * @param [properties] Properties to set
   */
  constructor(properties?: replit$goval$api$repl$IMetadata): this;

  /**
   * Metadata repl.
   */
  repl?: replit$goval$api$repl$Repl | null;

  /**
   * Metadata resourceLimits.
   */
  resourceLimits?: replit$goval$api$repl$ResourceLimits | null;

  /**
   * Metadata interactiveResourceLimits.
   */
  interactiveResourceLimits?: replit$goval$api$repl$ResourceLimits | null;

  /**
   * Metadata persistence.
   */
  persistence: $Values<typeof replit$goval$api$repl$Persistence>;

  /**
   * Metadata flags.
   */
  flags: string[];

  /**
   * Metadata permissions.
   */
  permissions?: replit$goval$api$repl$Permissions | null;

  /**
   * Metadata features.
   */
  features: replit$goval$api$features$Feature[];

  /**
   * Creates a new Metadata instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Metadata instance
   */
  static create(
    properties?: replit$goval$api$repl$IMetadata
  ): replit$goval$api$repl$Metadata;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Metadata message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: replit$goval$api$repl$Metadata,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Metadata message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: replit$goval$api$repl$Metadata,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Metadata message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Metadata
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): replit$goval$api$repl$Metadata;

  /**
   * Decodes a Metadata message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Metadata
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): replit$goval$api$repl$Metadata;

  /**
   * Verifies a Metadata message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Metadata
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): replit$goval$api$repl$Metadata;

  /**
   * Creates a plain object from a Metadata message. Also converts values to other types if specified.
   * @param message Metadata
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: replit$goval$api$repl$Metadata,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Metadata to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}
export var google = npm$namespace$google;

declare var npm$namespace$google: {|
  protobuf: typeof npm$namespace$google$protobuf,
|};

declare var npm$namespace$google$protobuf: {|
  NullValue: typeof google$protobuf$NullValue,
  ITimestamp: Class<google$protobuf$ITimestamp>,
  IStruct: Class<google$protobuf$IStruct>,
  IValue: Class<google$protobuf$IValue>,
  IListValue: Class<google$protobuf$IListValue>,
  IFieldMask: Class<google$protobuf$IFieldMask>,
  Timestamp: typeof google$protobuf$Timestamp,
  Struct: typeof google$protobuf$Struct,
  Value: typeof google$protobuf$Value,
  ListValue: typeof google$protobuf$ListValue,
  FieldMask: typeof google$protobuf$FieldMask,
|};

/**
 * Properties of a Timestamp.
 */
declare type google$protobuf$ITimestamp = {|
  /**
   * Timestamp seconds
   */
  seconds?: number | null,

  /**
   * Timestamp nanos
   */
  nanos?: number | null,
|};

/**
 * Represents a Timestamp.
 */
declare class google$protobuf$Timestamp {
  /**
   * Constructs a new Timestamp.
   * @param [properties] Properties to set
   */
  constructor(properties?: google$protobuf$ITimestamp): this;

  /**
   * Timestamp seconds.
   */
  seconds: number;

  /**
   * Timestamp nanos.
   */
  nanos: number;

  /**
   * Creates a new Timestamp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Timestamp instance
   */
  static create(
    properties?: google$protobuf$ITimestamp
  ): google$protobuf$Timestamp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Timestamp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: google$protobuf$Timestamp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Timestamp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: google$protobuf$Timestamp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Timestamp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Timestamp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$Timestamp;

  /**
   * Decodes a Timestamp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Timestamp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$Timestamp;

  /**
   * Verifies a Timestamp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Timestamp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): google$protobuf$Timestamp;

  /**
   * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
   * @param message Timestamp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: google$protobuf$Timestamp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Timestamp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Struct.
 */
declare type google$protobuf$IStruct = {|
  /**
   * Struct fields
   */
  fields?: {|
    [k: string]: google$protobuf$Value | google$protobuf$IValue,
  |} | null,
|};

/**
 * Represents a Struct.
 */
declare class google$protobuf$Struct {
  /**
   * Constructs a new Struct.
   * @param [properties] Properties to set
   */
  constructor(properties?: google$protobuf$IStruct): this;

  /**
   * Struct fields.
   */
  fields: {|
    [k: string]: google$protobuf$Value,
  |};

  /**
   * Creates a new Struct instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Struct instance
   */
  static create(properties?: google$protobuf$IStruct): google$protobuf$Struct;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Struct message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: google$protobuf$Struct,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Struct message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: google$protobuf$Struct,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Struct message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Struct
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$Struct;

  /**
   * Decodes a Struct message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Struct
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$Struct;

  /**
   * Verifies a Struct message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Struct message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Struct
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): google$protobuf$Struct;

  /**
   * Creates a plain object from a Struct message. Also converts values to other types if specified.
   * @param message Struct
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: google$protobuf$Struct,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Struct to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Value.
 */
declare type google$protobuf$IValue = {|
  /**
   * Value nullValue
   */
  nullValue?: $Values<typeof google$protobuf$NullValue> | null,

  /**
   * Value numberValue
   */
  numberValue?: number | null,

  /**
   * Value stringValue
   */
  stringValue?: string | null,

  /**
   * Value boolValue
   */
  boolValue?: boolean | null,

  /**
   * Value structValue
   */
  structValue?: google$protobuf$Struct | google$protobuf$IStruct | null,

  /**
   * Value listValue
   */
  listValue?: google$protobuf$ListValue | google$protobuf$IListValue | null,
|};

/**
 * Represents a Value.
 */
declare class google$protobuf$Value {
  /**
   * Constructs a new Value.
   * @param [properties] Properties to set
   */
  constructor(properties?: google$protobuf$IValue): this;

  /**
   * Value nullValue.
   */
  nullValue?: $Values<typeof google$protobuf$NullValue> | null;

  /**
   * Value numberValue.
   */
  numberValue?: number | null;

  /**
   * Value stringValue.
   */
  stringValue?: string | null;

  /**
   * Value boolValue.
   */
  boolValue?: boolean | null;

  /**
   * Value structValue.
   */
  structValue?: google$protobuf$Struct | null;

  /**
   * Value listValue.
   */
  listValue?: google$protobuf$ListValue | null;

  /**
   * Value kind.
   */
  kind?:
    | "nullValue"
    | "numberValue"
    | "stringValue"
    | "boolValue"
    | "structValue"
    | "listValue";

  /**
   * Creates a new Value instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Value instance
   */
  static create(properties?: google$protobuf$IValue): google$protobuf$Value;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Value message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: google$protobuf$Value,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Value message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: google$protobuf$Value,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Value message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Value
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$Value;

  /**
   * Decodes a Value message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Value
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$Value;

  /**
   * Verifies a Value message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Value message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Value
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): google$protobuf$Value;

  /**
   * Creates a plain object from a Value message. Also converts values to other types if specified.
   * @param message Value
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: google$protobuf$Value,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Value to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * NullValue enum.
 */

declare var google$protobuf$NullValue: {|
  +NULL_VALUE: 0, // 0
|};

/**
 * Properties of a ListValue.
 */
declare type google$protobuf$IListValue = {|
  /**
   * ListValue values
   */
  values?: (google$protobuf$Value | google$protobuf$IValue)[] | null,
|};

/**
 * Represents a ListValue.
 */
declare class google$protobuf$ListValue {
  /**
   * Constructs a new ListValue.
   * @param [properties] Properties to set
   */
  constructor(properties?: google$protobuf$IListValue): this;

  /**
   * ListValue values.
   */
  values: google$protobuf$Value[];

  /**
   * Creates a new ListValue instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ListValue instance
   */
  static create(
    properties?: google$protobuf$IListValue
  ): google$protobuf$ListValue;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ListValue message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: google$protobuf$ListValue,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ListValue message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: google$protobuf$ListValue,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ListValue message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ListValue
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$ListValue;

  /**
   * Decodes a ListValue message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ListValue
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$ListValue;

  /**
   * Verifies a ListValue message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ListValue message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ListValue
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): google$protobuf$ListValue;

  /**
   * Creates a plain object from a ListValue message. Also converts values to other types if specified.
   * @param message ListValue
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: google$protobuf$ListValue,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ListValue to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FieldMask.
 */
declare type google$protobuf$IFieldMask = {|
  /**
   * FieldMask paths
   */
  paths?: string[] | null,
|};

/**
 * Represents a FieldMask.
 */
declare class google$protobuf$FieldMask {
  /**
   * Constructs a new FieldMask.
   * @param [properties] Properties to set
   */
  constructor(properties?: google$protobuf$IFieldMask): this;

  /**
   * FieldMask paths.
   */
  paths: string[];

  /**
   * Creates a new FieldMask instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FieldMask instance
   */
  static create(
    properties?: google$protobuf$IFieldMask
  ): google$protobuf$FieldMask;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FieldMask message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: google$protobuf$FieldMask,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FieldMask message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: google$protobuf$FieldMask,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FieldMask message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FieldMask
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$FieldMask;

  /**
   * Decodes a FieldMask message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FieldMask
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$FieldMask;

  /**
   * Verifies a FieldMask message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FieldMask message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FieldMask
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): google$protobuf$FieldMask;

  /**
   * Creates a plain object from a FieldMask message. Also converts values to other types if specified.
   * @param message FieldMask
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: google$protobuf$FieldMask,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FieldMask to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}
export var api = npm$namespace$replit$goval$api;
